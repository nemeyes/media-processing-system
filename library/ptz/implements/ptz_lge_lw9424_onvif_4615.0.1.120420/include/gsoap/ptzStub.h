/* ptzStub.h
   Generated by gSOAP 2.7.16 from ptz.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef ptzStub_H
#define ptzStub_H
#define SOAP_NAMESPACE_OF_tptz	"http://www.onvif.org/ver20/ptz/wsdl"
#define SOAP_NAMESPACE_OF_tt	"http://www.onvif.org/ver10/schema"
#define SOAP_NAMESPACE_OF_xmime5	"http://www.w3.org/2005/05/xmlmime"
#define SOAP_NAMESPACE_OF_wsnt	"http://docs.oasis-open.org/wsn/b-2"
#define SOAP_NAMESPACE_OF_xop	"http://www.w3.org/2004/08/xop/include"
#define SOAP_NAMESPACE_OF_wsa5	"http://www.w3.org/2005/08/addressing"
#define SOAP_NAMESPACE_OF_wsbf	"http://docs.oasis-open.org/wsrf/bf-2"
#define SOAP_NAMESPACE_OF_wstop	"http://docs.oasis-open.org/wsn/t-1"
#ifndef WITH_NONAMESPACES
#define WITH_NONAMESPACES
#endif
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_tt__RotateMode
#define SOAP_TYPE_tt__RotateMode (584)
/* tt:RotateMode */
enum tt__RotateMode {tt__RotateMode__OFF = 0, tt__RotateMode__ON = 1, tt__RotateMode__AUTO = 2};
#endif

#ifndef SOAP_TYPE_tt__VideoEncoding
#define SOAP_TYPE_tt__VideoEncoding (585)
/* tt:VideoEncoding */
enum tt__VideoEncoding {tt__VideoEncoding__JPEG = 0, tt__VideoEncoding__MPEG4 = 1, tt__VideoEncoding__H264 = 2};
#endif

#ifndef SOAP_TYPE_tt__Mpeg4Profile
#define SOAP_TYPE_tt__Mpeg4Profile (586)
/* tt:Mpeg4Profile */
enum tt__Mpeg4Profile {tt__Mpeg4Profile__SP = 0, tt__Mpeg4Profile__ASP = 1};
#endif

#ifndef SOAP_TYPE_tt__H264Profile
#define SOAP_TYPE_tt__H264Profile (587)
/* tt:H264Profile */
enum tt__H264Profile {tt__H264Profile__Baseline = 0, tt__H264Profile__Main = 1, tt__H264Profile__Extended = 2, tt__H264Profile__High = 3};
#endif

#ifndef SOAP_TYPE_tt__AudioEncoding
#define SOAP_TYPE_tt__AudioEncoding (588)
/* tt:AudioEncoding */
enum tt__AudioEncoding {tt__AudioEncoding__G711 = 0, tt__AudioEncoding__G726 = 1, tt__AudioEncoding__AAC = 2};
#endif

#ifndef SOAP_TYPE_tt__StreamType
#define SOAP_TYPE_tt__StreamType (589)
/* tt:StreamType */
enum tt__StreamType {tt__StreamType__RTP_Unicast = 0, tt__StreamType__RTP_Multicast = 1};
#endif

#ifndef SOAP_TYPE_tt__TransportProtocol
#define SOAP_TYPE_tt__TransportProtocol (590)
/* tt:TransportProtocol */
enum tt__TransportProtocol {tt__TransportProtocol__UDP = 0, tt__TransportProtocol__TCP = 1, tt__TransportProtocol__RTSP = 2, tt__TransportProtocol__HTTP = 3};
#endif

#ifndef SOAP_TYPE_tt__ScopeDefinition
#define SOAP_TYPE_tt__ScopeDefinition (591)
/* tt:ScopeDefinition */
enum tt__ScopeDefinition {tt__ScopeDefinition__Fixed = 0, tt__ScopeDefinition__Configurable = 1};
#endif

#ifndef SOAP_TYPE_tt__DiscoveryMode
#define SOAP_TYPE_tt__DiscoveryMode (592)
/* tt:DiscoveryMode */
enum tt__DiscoveryMode {tt__DiscoveryMode__Discoverable = 0, tt__DiscoveryMode__NonDiscoverable = 1};
#endif

#ifndef SOAP_TYPE_tt__Duplex
#define SOAP_TYPE_tt__Duplex (594)
/* tt:Duplex */
enum tt__Duplex {tt__Duplex__Full = 0, tt__Duplex__Half = 1};
#endif

#ifndef SOAP_TYPE_tt__IPv6DHCPConfiguration
#define SOAP_TYPE_tt__IPv6DHCPConfiguration (596)
/* tt:IPv6DHCPConfiguration */
enum tt__IPv6DHCPConfiguration {tt__IPv6DHCPConfiguration__Auto = 0, tt__IPv6DHCPConfiguration__Stateful = 1, tt__IPv6DHCPConfiguration__Stateless = 2, tt__IPv6DHCPConfiguration__Off = 3};
#endif

#ifndef SOAP_TYPE_tt__NetworkProtocolType
#define SOAP_TYPE_tt__NetworkProtocolType (597)
/* tt:NetworkProtocolType */
enum tt__NetworkProtocolType {tt__NetworkProtocolType__HTTP = 0, tt__NetworkProtocolType__HTTPS = 1, tt__NetworkProtocolType__RTSP = 2};
#endif

#ifndef SOAP_TYPE_tt__NetworkHostType
#define SOAP_TYPE_tt__NetworkHostType (598)
/* tt:NetworkHostType */
enum tt__NetworkHostType {tt__NetworkHostType__IPv4 = 0, tt__NetworkHostType__IPv6 = 1, tt__NetworkHostType__DNS = 2};
#endif

#ifndef SOAP_TYPE_tt__IPType
#define SOAP_TYPE_tt__IPType (602)
/* tt:IPType */
enum tt__IPType {tt__IPType__IPv4 = 0, tt__IPType__IPv6 = 1};
#endif

#ifndef SOAP_TYPE_tt__IPAddressFilterType
#define SOAP_TYPE_tt__IPAddressFilterType (605)
/* tt:IPAddressFilterType */
enum tt__IPAddressFilterType {tt__IPAddressFilterType__Allow = 0, tt__IPAddressFilterType__Deny = 1};
#endif

#ifndef SOAP_TYPE_tt__DynamicDNSType
#define SOAP_TYPE_tt__DynamicDNSType (606)
/* tt:DynamicDNSType */
enum tt__DynamicDNSType {tt__DynamicDNSType__NoUpdate = 0, tt__DynamicDNSType__ClientUpdates = 1, tt__DynamicDNSType__ServerUpdates = 2};
#endif

#ifndef SOAP_TYPE_tt__Dot11StationMode
#define SOAP_TYPE_tt__Dot11StationMode (608)
/* tt:Dot11StationMode */
enum tt__Dot11StationMode {tt__Dot11StationMode__Ad_hoc = 0, tt__Dot11StationMode__Infrastructure = 1, tt__Dot11StationMode__Extended = 2};
#endif

#ifndef SOAP_TYPE_tt__Dot11SecurityMode
#define SOAP_TYPE_tt__Dot11SecurityMode (609)
/* tt:Dot11SecurityMode */
enum tt__Dot11SecurityMode {tt__Dot11SecurityMode__None = 0, tt__Dot11SecurityMode__WEP = 1, tt__Dot11SecurityMode__PSK = 2, tt__Dot11SecurityMode__Dot1X = 3, tt__Dot11SecurityMode__Extended = 4};
#endif

#ifndef SOAP_TYPE_tt__Dot11Cipher
#define SOAP_TYPE_tt__Dot11Cipher (610)
/* tt:Dot11Cipher */
enum tt__Dot11Cipher {tt__Dot11Cipher__CCMP = 0, tt__Dot11Cipher__TKIP = 1, tt__Dot11Cipher__Any = 2, tt__Dot11Cipher__Extended = 3};
#endif

#ifndef SOAP_TYPE_tt__Dot11SignalStrength
#define SOAP_TYPE_tt__Dot11SignalStrength (613)
/* tt:Dot11SignalStrength */
enum tt__Dot11SignalStrength {tt__Dot11SignalStrength__None = 0, tt__Dot11SignalStrength__Very_x0020Bad = 1, tt__Dot11SignalStrength__Bad = 2, tt__Dot11SignalStrength__Good = 3, tt__Dot11SignalStrength__Very_x0020Good = 4, tt__Dot11SignalStrength__Extended = 5};
#endif

#ifndef SOAP_TYPE_tt__Dot11AuthAndMangementSuite
#define SOAP_TYPE_tt__Dot11AuthAndMangementSuite (614)
/* tt:Dot11AuthAndMangementSuite */
enum tt__Dot11AuthAndMangementSuite {tt__Dot11AuthAndMangementSuite__None = 0, tt__Dot11AuthAndMangementSuite__Dot1X = 1, tt__Dot11AuthAndMangementSuite__PSK = 2, tt__Dot11AuthAndMangementSuite__Extended = 3};
#endif

#ifndef SOAP_TYPE_tt__CapabilityCategory
#define SOAP_TYPE_tt__CapabilityCategory (615)
/* tt:CapabilityCategory */
enum tt__CapabilityCategory {tt__CapabilityCategory__All = 0, tt__CapabilityCategory__Analytics = 1, tt__CapabilityCategory__Device = 2, tt__CapabilityCategory__Events = 3, tt__CapabilityCategory__Imaging = 4, tt__CapabilityCategory__Media = 5, tt__CapabilityCategory__PTZ = 6};
#endif

#ifndef SOAP_TYPE_tt__SystemLogType
#define SOAP_TYPE_tt__SystemLogType (616)
/* tt:SystemLogType */
enum tt__SystemLogType {tt__SystemLogType__System = 0, tt__SystemLogType__Access = 1};
#endif

#ifndef SOAP_TYPE_tt__FactoryDefaultType
#define SOAP_TYPE_tt__FactoryDefaultType (617)
/* tt:FactoryDefaultType */
enum tt__FactoryDefaultType {tt__FactoryDefaultType__Hard = 0, tt__FactoryDefaultType__Soft = 1};
#endif

#ifndef SOAP_TYPE_tt__SetDateTimeType
#define SOAP_TYPE_tt__SetDateTimeType (618)
/* tt:SetDateTimeType */
enum tt__SetDateTimeType {tt__SetDateTimeType__Manual = 0, tt__SetDateTimeType__NTP = 1};
#endif

#ifndef SOAP_TYPE_tt__UserLevel
#define SOAP_TYPE_tt__UserLevel (619)
/* tt:UserLevel */
enum tt__UserLevel {tt__UserLevel__Administrator = 0, tt__UserLevel__Operator = 1, tt__UserLevel__User = 2, tt__UserLevel__Anonymous = 3, tt__UserLevel__Extended = 4};
#endif

#ifndef SOAP_TYPE_tt__RelayLogicalState
#define SOAP_TYPE_tt__RelayLogicalState (620)
/* tt:RelayLogicalState */
enum tt__RelayLogicalState {tt__RelayLogicalState__active = 0, tt__RelayLogicalState__inactive = 1};
#endif

#ifndef SOAP_TYPE_tt__RelayIdleState
#define SOAP_TYPE_tt__RelayIdleState (621)
/* tt:RelayIdleState */
enum tt__RelayIdleState {tt__RelayIdleState__closed = 0, tt__RelayIdleState__open = 1};
#endif

#ifndef SOAP_TYPE_tt__RelayMode
#define SOAP_TYPE_tt__RelayMode (622)
/* tt:RelayMode */
enum tt__RelayMode {tt__RelayMode__Monostable = 0, tt__RelayMode__Bistable = 1};
#endif

#ifndef SOAP_TYPE_tt__EFlipMode
#define SOAP_TYPE_tt__EFlipMode (623)
/* tt:EFlipMode */
enum tt__EFlipMode {tt__EFlipMode__OFF = 0, tt__EFlipMode__ON = 1, tt__EFlipMode__Extended = 2};
#endif

#ifndef SOAP_TYPE_tt__ReverseMode
#define SOAP_TYPE_tt__ReverseMode (624)
/* tt:ReverseMode */
enum tt__ReverseMode {tt__ReverseMode__OFF = 0, tt__ReverseMode__ON = 1, tt__ReverseMode__AUTO = 2, tt__ReverseMode__Extended = 3};
#endif

#ifndef SOAP_TYPE_tt__MoveStatus
#define SOAP_TYPE_tt__MoveStatus (626)
/* tt:MoveStatus */
enum tt__MoveStatus {tt__MoveStatus__IDLE = 0, tt__MoveStatus__MOVING = 1, tt__MoveStatus__UNKNOWN = 2};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourState
#define SOAP_TYPE_tt__PTZPresetTourState (627)
/* tt:PTZPresetTourState */
enum tt__PTZPresetTourState {tt__PTZPresetTourState__Idle = 0, tt__PTZPresetTourState__Touring = 1, tt__PTZPresetTourState__Paused = 2, tt__PTZPresetTourState__Extended = 3};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourDirection
#define SOAP_TYPE_tt__PTZPresetTourDirection (628)
/* tt:PTZPresetTourDirection */
enum tt__PTZPresetTourDirection {tt__PTZPresetTourDirection__Forward = 0, tt__PTZPresetTourDirection__Backward = 1, tt__PTZPresetTourDirection__Extended = 2};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourOperation
#define SOAP_TYPE_tt__PTZPresetTourOperation (629)
/* tt:PTZPresetTourOperation */
enum tt__PTZPresetTourOperation {tt__PTZPresetTourOperation__Start = 0, tt__PTZPresetTourOperation__Stop = 1, tt__PTZPresetTourOperation__Pause = 2, tt__PTZPresetTourOperation__Extended = 3};
#endif

#ifndef SOAP_TYPE_tt__AutoFocusMode
#define SOAP_TYPE_tt__AutoFocusMode (630)
/* tt:AutoFocusMode */
enum tt__AutoFocusMode {tt__AutoFocusMode__AUTO = 0, tt__AutoFocusMode__MANUAL = 1};
#endif

#ifndef SOAP_TYPE_tt__WideDynamicMode
#define SOAP_TYPE_tt__WideDynamicMode (631)
/* tt:WideDynamicMode */
enum tt__WideDynamicMode {tt__WideDynamicMode__OFF = 0, tt__WideDynamicMode__ON = 1};
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensationMode
#define SOAP_TYPE_tt__BacklightCompensationMode (632)
/* tt:BacklightCompensationMode */
enum tt__BacklightCompensationMode {tt__BacklightCompensationMode__OFF = 0, tt__BacklightCompensationMode__ON = 1};
#endif

#ifndef SOAP_TYPE_tt__ExposurePriority
#define SOAP_TYPE_tt__ExposurePriority (633)
/* tt:ExposurePriority */
enum tt__ExposurePriority {tt__ExposurePriority__LowNoise = 0, tt__ExposurePriority__FrameRate = 1};
#endif

#ifndef SOAP_TYPE_tt__ExposureMode
#define SOAP_TYPE_tt__ExposureMode (634)
/* tt:ExposureMode */
enum tt__ExposureMode {tt__ExposureMode__AUTO = 0, tt__ExposureMode__MANUAL = 1};
#endif

#ifndef SOAP_TYPE_tt__Enabled
#define SOAP_TYPE_tt__Enabled (635)
/* tt:Enabled */
enum tt__Enabled {tt__Enabled__ENABLED = 0, tt__Enabled__DISABLED = 1};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceMode
#define SOAP_TYPE_tt__WhiteBalanceMode (636)
/* tt:WhiteBalanceMode */
enum tt__WhiteBalanceMode {tt__WhiteBalanceMode__AUTO = 0, tt__WhiteBalanceMode__MANUAL = 1};
#endif

#ifndef SOAP_TYPE_tt__IrCutFilterMode
#define SOAP_TYPE_tt__IrCutFilterMode (637)
/* tt:IrCutFilterMode */
enum tt__IrCutFilterMode {tt__IrCutFilterMode__ON = 0, tt__IrCutFilterMode__OFF = 1, tt__IrCutFilterMode__AUTO = 2};
#endif

#ifndef SOAP_TYPE_tt__ImageStabilizationMode
#define SOAP_TYPE_tt__ImageStabilizationMode (638)
/* tt:ImageStabilizationMode */
enum tt__ImageStabilizationMode {tt__ImageStabilizationMode__OFF = 0, tt__ImageStabilizationMode__ON = 1, tt__ImageStabilizationMode__AUTO = 2, tt__ImageStabilizationMode__Extended = 3};
#endif

#ifndef SOAP_TYPE_tt__PropertyOperation
#define SOAP_TYPE_tt__PropertyOperation (640)
/* tt:PropertyOperation */
enum tt__PropertyOperation {tt__PropertyOperation__Initialized = 0, tt__PropertyOperation__Deleted = 1, tt__PropertyOperation__Changed = 2};
#endif

#ifndef SOAP_TYPE_tt__Direction
#define SOAP_TYPE_tt__Direction (641)
/* tt:Direction */
enum tt__Direction {tt__Direction__Left = 0, tt__Direction__Right = 1, tt__Direction__Any = 2};
#endif

#ifndef SOAP_TYPE_tt__ClassType
#define SOAP_TYPE_tt__ClassType (642)
/* tt:ClassType */
enum tt__ClassType {tt__ClassType__Animal = 0, tt__ClassType__Face = 1, tt__ClassType__Human = 2, tt__ClassType__Vehical = 3, tt__ClassType__Other = 4};
#endif

#ifndef SOAP_TYPE_tt__ReceiverMode
#define SOAP_TYPE_tt__ReceiverMode (643)
/* tt:ReceiverMode */
enum tt__ReceiverMode {tt__ReceiverMode__AutoConnect = 0, tt__ReceiverMode__AlwaysConnect = 1, tt__ReceiverMode__NeverConnect = 2, tt__ReceiverMode__Unknown = 3};
#endif

#ifndef SOAP_TYPE_tt__ReceiverState
#define SOAP_TYPE_tt__ReceiverState (644)
/* tt:ReceiverState */
enum tt__ReceiverState {tt__ReceiverState__NotConnected = 0, tt__ReceiverState__Connecting = 1, tt__ReceiverState__Connected = 2, tt__ReceiverState__Unknown = 3};
#endif

#ifndef SOAP_TYPE_tt__SearchState
#define SOAP_TYPE_tt__SearchState (647)
/* tt:SearchState */
enum tt__SearchState {tt__SearchState__Queued = 0, tt__SearchState__Searching = 1, tt__SearchState__Completed = 2, tt__SearchState__Unknown = 3};
#endif

#ifndef SOAP_TYPE_tt__RecordingStatus
#define SOAP_TYPE_tt__RecordingStatus (648)
/* tt:RecordingStatus */
enum tt__RecordingStatus {tt__RecordingStatus__Initiated = 0, tt__RecordingStatus__Recording = 1, tt__RecordingStatus__Stopped = 2, tt__RecordingStatus__Removing = 3, tt__RecordingStatus__Removed = 4, tt__RecordingStatus__Unknown = 5};
#endif

#ifndef SOAP_TYPE_tt__TrackType
#define SOAP_TYPE_tt__TrackType (649)
/* tt:TrackType */
enum tt__TrackType {tt__TrackType__Video = 0, tt__TrackType__Audio = 1, tt__TrackType__Metadata = 2, tt__TrackType__Extended = 3};
#endif

#ifndef SOAP_TYPE_tt__ModeOfOperation
#define SOAP_TYPE_tt__ModeOfOperation (652)
/* tt:ModeOfOperation */
enum tt__ModeOfOperation {tt__ModeOfOperation__Idle = 0, tt__ModeOfOperation__Active = 1, tt__ModeOfOperation__Unknown = 2};
#endif

#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (653)
/* wsa5:RelationshipType */
enum wsa5__RelationshipType {wsa5__RelationshipType__http___x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply = 0};
#endif

#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (654)
/* wsa5:FaultCodesType */
enum wsa5__FaultCodesType {wsa5__FaultCodesType__wsa5__InvalidAddressingHeader = 0, wsa5__FaultCodesType__wsa5__InvalidAddress = 1, wsa5__FaultCodesType__wsa5__InvalidEPR = 2, wsa5__FaultCodesType__wsa5__InvalidCardinality = 3, wsa5__FaultCodesType__wsa5__MissingAddressInEPR = 4, wsa5__FaultCodesType__wsa5__DuplicateMessageID = 5, wsa5__FaultCodesType__wsa5__ActionMismatch = 6, wsa5__FaultCodesType__wsa5__MessageAddressingHeaderRequired = 7, wsa5__FaultCodesType__wsa5__DestinationUnreachable = 8, wsa5__FaultCodesType__wsa5__ActionNotSupported = 9, wsa5__FaultCodesType__wsa5__EndpointUnavailable = 10};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (9)
typedef struct soap_dom_element xsd__anyType;
#endif
#ifndef SOAP_TYPE_xsd__anyAttribute
#define SOAP_TYPE_xsd__anyAttribute (11)
typedef struct soap_dom_attribute xsd__anyAttribute;
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif





#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (16)
/* Base64 schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_xsd__base64Binary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary(): __ptr(NULL), id(NULL), type(NULL), options(NULL), soap(NULL) { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
};
#endif

#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (22)
/* hexBinary schema type: */
class SOAP_CMAC xsd__hexBinary
{
public:
	unsigned char *__ptr;
	int __size;
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_xsd__hexBinary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__hexBinary(): __ptr(NULL) { xsd__hexBinary::soap_default(NULL); }
	virtual ~xsd__hexBinary() { }
};
#endif

#ifndef SOAP_TYPE__xop__Include
#define SOAP_TYPE__xop__Include (559)
/* Base64 schema type: */
struct _xop__Include
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
};
#endif
typedef struct _xop__Include _xop__Include;

#ifndef SOAP_TYPE_tptz__Capabilities
#define SOAP_TYPE_tptz__Capabilities (27)
/* tptz:Capabilities */
class SOAP_CMAC tptz__Capabilities
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	bool *EFlip;	/* optional attribute */
	bool *Reverse;	/* optional attribute */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_tptz__Capabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tptz__Capabilities(): __any(NULL), EFlip(NULL), Reverse(NULL), soap(NULL) { tptz__Capabilities::soap_default(NULL); }
	virtual ~tptz__Capabilities() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetServiceCapabilities
#define SOAP_TYPE__tptz__GetServiceCapabilities (28)
/* tptz:GetServiceCapabilities */
class SOAP_CMAC _tptz__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE__tptz__GetServiceCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetServiceCapabilities(): soap(NULL) { _tptz__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_tptz__GetServiceCapabilities() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tptz__GetServiceCapabilitiesResponse (29)
/* tptz:GetServiceCapabilitiesResponse */
class SOAP_CMAC _tptz__GetServiceCapabilitiesResponse
{
public:
	tptz__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tptz:Capabilities */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE__tptz__GetServiceCapabilitiesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetServiceCapabilitiesResponse(): Capabilities(NULL), soap(NULL) { _tptz__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_tptz__GetServiceCapabilitiesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetNodes
#define SOAP_TYPE__tptz__GetNodes (30)
/* tptz:GetNodes */
class SOAP_CMAC _tptz__GetNodes
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE__tptz__GetNodes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetNodes(): soap(NULL) { _tptz__GetNodes::soap_default(NULL); }
	virtual ~_tptz__GetNodes() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetNodesResponse
#define SOAP_TYPE__tptz__GetNodesResponse (31)
/* tptz:GetNodesResponse */
class SOAP_CMAC _tptz__GetNodesResponse
{
public:
	int __sizePTZNode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <PTZNode> */
	class tt__PTZNode **PTZNode;	/* optional element of type tt:PTZNode */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE__tptz__GetNodesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetNodesResponse(): PTZNode(NULL), soap(NULL) { _tptz__GetNodesResponse::soap_default(NULL); }
	virtual ~_tptz__GetNodesResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetNode
#define SOAP_TYPE__tptz__GetNode (32)
/* tptz:GetNode */
class SOAP_CMAC _tptz__GetNode
{
public:
	char *NodeToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE__tptz__GetNode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetNode(): NodeToken(NULL), soap(NULL) { _tptz__GetNode::soap_default(NULL); }
	virtual ~_tptz__GetNode() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetNodeResponse
#define SOAP_TYPE__tptz__GetNodeResponse (33)
/* tptz:GetNodeResponse */
class SOAP_CMAC _tptz__GetNodeResponse
{
public:
	tt__PTZNode *PTZNode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:PTZNode */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE__tptz__GetNodeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetNodeResponse(): PTZNode(NULL), soap(NULL) { _tptz__GetNodeResponse::soap_default(NULL); }
	virtual ~_tptz__GetNodeResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetConfigurations
#define SOAP_TYPE__tptz__GetConfigurations (34)
/* tptz:GetConfigurations */
class SOAP_CMAC _tptz__GetConfigurations
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE__tptz__GetConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetConfigurations(): soap(NULL) { _tptz__GetConfigurations::soap_default(NULL); }
	virtual ~_tptz__GetConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetConfigurationsResponse
#define SOAP_TYPE__tptz__GetConfigurationsResponse (35)
/* tptz:GetConfigurationsResponse */
class SOAP_CMAC _tptz__GetConfigurationsResponse
{
public:
	int __sizePTZConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <PTZConfiguration> */
	class tt__PTZConfiguration **PTZConfiguration;	/* optional element of type tt:PTZConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE__tptz__GetConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetConfigurationsResponse(): PTZConfiguration(NULL), soap(NULL) { _tptz__GetConfigurationsResponse::soap_default(NULL); }
	virtual ~_tptz__GetConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetConfiguration
#define SOAP_TYPE__tptz__GetConfiguration (36)
/* tptz:GetConfiguration */
class SOAP_CMAC _tptz__GetConfiguration
{
public:
	char *PTZConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE__tptz__GetConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetConfiguration(): PTZConfigurationToken(NULL), soap(NULL) { _tptz__GetConfiguration::soap_default(NULL); }
	virtual ~_tptz__GetConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetConfigurationResponse
#define SOAP_TYPE__tptz__GetConfigurationResponse (37)
/* tptz:GetConfigurationResponse */
class SOAP_CMAC _tptz__GetConfigurationResponse
{
public:
	tt__PTZConfiguration *PTZConfiguration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:PTZConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE__tptz__GetConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetConfigurationResponse(): PTZConfiguration(NULL), soap(NULL) { _tptz__GetConfigurationResponse::soap_default(NULL); }
	virtual ~_tptz__GetConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__SetConfiguration
#define SOAP_TYPE__tptz__SetConfiguration (38)
/* tptz:SetConfiguration */
class SOAP_CMAC _tptz__SetConfiguration
{
public:
	tt__PTZConfiguration *PTZConfiguration;	/* required element of type tt:PTZConfiguration */
	bool ForcePersistence;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE__tptz__SetConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__SetConfiguration(): PTZConfiguration(NULL), soap(NULL) { _tptz__SetConfiguration::soap_default(NULL); }
	virtual ~_tptz__SetConfiguration() { }
};
#endif

#ifndef SOAP_TYPE___tptz__SetConfigurationResponse_sequence
#define SOAP_TYPE___tptz__SetConfigurationResponse_sequence (671)
/* Operation wrapper: */
class SOAP_CMAC __tptz__SetConfigurationResponse_sequence
{
public:
	virtual int soap_type() const { return 671; } /* = unique id SOAP_TYPE___tptz__SetConfigurationResponse_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __tptz__SetConfigurationResponse_sequence() { __tptz__SetConfigurationResponse_sequence::soap_default(NULL); }
	virtual ~__tptz__SetConfigurationResponse_sequence() { }
};
#endif

#ifndef SOAP_TYPE__tptz__SetConfigurationResponse
#define SOAP_TYPE__tptz__SetConfigurationResponse (39)
/* tptz:SetConfigurationResponse */
class SOAP_CMAC _tptz__SetConfigurationResponse
{
public:
	int __size_SetConfigurationResponse_sequence;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <-SetConfigurationResponse-sequence> */
	__tptz__SetConfigurationResponse_sequence *__SetConfigurationResponse_sequence;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE__tptz__SetConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__SetConfigurationResponse(): __SetConfigurationResponse_sequence(NULL), soap(NULL) { _tptz__SetConfigurationResponse::soap_default(NULL); }
	virtual ~_tptz__SetConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetConfigurationOptions
#define SOAP_TYPE__tptz__GetConfigurationOptions (40)
/* tptz:GetConfigurationOptions */
class SOAP_CMAC _tptz__GetConfigurationOptions
{
public:
	char *ConfigurationToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE__tptz__GetConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetConfigurationOptions(): ConfigurationToken(NULL), soap(NULL) { _tptz__GetConfigurationOptions::soap_default(NULL); }
	virtual ~_tptz__GetConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetConfigurationOptionsResponse
#define SOAP_TYPE__tptz__GetConfigurationOptionsResponse (41)
/* tptz:GetConfigurationOptionsResponse */
class SOAP_CMAC _tptz__GetConfigurationOptionsResponse
{
public:
	class tt__PTZConfigurationOptions *PTZConfigurationOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:PTZConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE__tptz__GetConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetConfigurationOptionsResponse(): PTZConfigurationOptions(NULL), soap(NULL) { _tptz__GetConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_tptz__GetConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__SendAuxiliaryCommand
#define SOAP_TYPE__tptz__SendAuxiliaryCommand (42)
/* tptz:SendAuxiliaryCommand */
class SOAP_CMAC _tptz__SendAuxiliaryCommand
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	char *AuxiliaryData;	/* required element of type tt:AuxiliaryData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE__tptz__SendAuxiliaryCommand */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__SendAuxiliaryCommand(): ProfileToken(NULL), AuxiliaryData(NULL), soap(NULL) { _tptz__SendAuxiliaryCommand::soap_default(NULL); }
	virtual ~_tptz__SendAuxiliaryCommand() { }
};
#endif

#ifndef SOAP_TYPE__tptz__SendAuxiliaryCommandResponse
#define SOAP_TYPE__tptz__SendAuxiliaryCommandResponse (43)
/* tptz:SendAuxiliaryCommandResponse */
class SOAP_CMAC _tptz__SendAuxiliaryCommandResponse
{
public:
	char *AuxiliaryResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:AuxiliaryData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE__tptz__SendAuxiliaryCommandResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__SendAuxiliaryCommandResponse(): AuxiliaryResponse(NULL), soap(NULL) { _tptz__SendAuxiliaryCommandResponse::soap_default(NULL); }
	virtual ~_tptz__SendAuxiliaryCommandResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetPresets
#define SOAP_TYPE__tptz__GetPresets (44)
/* tptz:GetPresets */
class SOAP_CMAC _tptz__GetPresets
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE__tptz__GetPresets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetPresets(): ProfileToken(NULL), soap(NULL) { _tptz__GetPresets::soap_default(NULL); }
	virtual ~_tptz__GetPresets() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetPresetsResponse
#define SOAP_TYPE__tptz__GetPresetsResponse (45)
/* tptz:GetPresetsResponse */
class SOAP_CMAC _tptz__GetPresetsResponse
{
public:
	int __sizePreset;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <Preset> */
	class tt__PTZPreset **Preset;	/* optional element of type tt:PTZPreset */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE__tptz__GetPresetsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetPresetsResponse(): Preset(NULL), soap(NULL) { _tptz__GetPresetsResponse::soap_default(NULL); }
	virtual ~_tptz__GetPresetsResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__SetPreset
#define SOAP_TYPE__tptz__SetPreset (46)
/* tptz:SetPreset */
class SOAP_CMAC _tptz__SetPreset
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	char *PresetName;	/* optional element of type xsd:string */
	char *PresetToken;	/* optional element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE__tptz__SetPreset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__SetPreset(): ProfileToken(NULL), PresetName(NULL), PresetToken(NULL), soap(NULL) { _tptz__SetPreset::soap_default(NULL); }
	virtual ~_tptz__SetPreset() { }
};
#endif

#ifndef SOAP_TYPE__tptz__SetPresetResponse
#define SOAP_TYPE__tptz__SetPresetResponse (47)
/* tptz:SetPresetResponse */
class SOAP_CMAC _tptz__SetPresetResponse
{
public:
	char *PresetToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE__tptz__SetPresetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__SetPresetResponse(): PresetToken(NULL), soap(NULL) { _tptz__SetPresetResponse::soap_default(NULL); }
	virtual ~_tptz__SetPresetResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__RemovePreset
#define SOAP_TYPE__tptz__RemovePreset (48)
/* tptz:RemovePreset */
class SOAP_CMAC _tptz__RemovePreset
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	char *PresetToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE__tptz__RemovePreset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__RemovePreset(): ProfileToken(NULL), PresetToken(NULL), soap(NULL) { _tptz__RemovePreset::soap_default(NULL); }
	virtual ~_tptz__RemovePreset() { }
};
#endif

#ifndef SOAP_TYPE__tptz__RemovePresetResponse
#define SOAP_TYPE__tptz__RemovePresetResponse (49)
/* tptz:RemovePresetResponse */
class SOAP_CMAC _tptz__RemovePresetResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE__tptz__RemovePresetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__RemovePresetResponse(): soap(NULL) { _tptz__RemovePresetResponse::soap_default(NULL); }
	virtual ~_tptz__RemovePresetResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GotoPreset
#define SOAP_TYPE__tptz__GotoPreset (50)
/* tptz:GotoPreset */
class SOAP_CMAC _tptz__GotoPreset
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	char *PresetToken;	/* required element of type tt:ReferenceToken */
	class tt__PTZSpeed *Speed;	/* optional element of type tt:PTZSpeed */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE__tptz__GotoPreset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GotoPreset(): ProfileToken(NULL), PresetToken(NULL), Speed(NULL), soap(NULL) { _tptz__GotoPreset::soap_default(NULL); }
	virtual ~_tptz__GotoPreset() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GotoPresetResponse
#define SOAP_TYPE__tptz__GotoPresetResponse (51)
/* tptz:GotoPresetResponse */
class SOAP_CMAC _tptz__GotoPresetResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE__tptz__GotoPresetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GotoPresetResponse(): soap(NULL) { _tptz__GotoPresetResponse::soap_default(NULL); }
	virtual ~_tptz__GotoPresetResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetStatus
#define SOAP_TYPE__tptz__GetStatus (52)
/* tptz:GetStatus */
class SOAP_CMAC _tptz__GetStatus
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE__tptz__GetStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetStatus(): ProfileToken(NULL), soap(NULL) { _tptz__GetStatus::soap_default(NULL); }
	virtual ~_tptz__GetStatus() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetStatusResponse
#define SOAP_TYPE__tptz__GetStatusResponse (53)
/* tptz:GetStatusResponse */
class SOAP_CMAC _tptz__GetStatusResponse
{
public:
	class tt__PTZStatus *PTZStatus;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:PTZStatus */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE__tptz__GetStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetStatusResponse(): PTZStatus(NULL), soap(NULL) { _tptz__GetStatusResponse::soap_default(NULL); }
	virtual ~_tptz__GetStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GotoHomePosition
#define SOAP_TYPE__tptz__GotoHomePosition (54)
/* tptz:GotoHomePosition */
class SOAP_CMAC _tptz__GotoHomePosition
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	tt__PTZSpeed *Speed;	/* optional element of type tt:PTZSpeed */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE__tptz__GotoHomePosition */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GotoHomePosition(): ProfileToken(NULL), Speed(NULL), soap(NULL) { _tptz__GotoHomePosition::soap_default(NULL); }
	virtual ~_tptz__GotoHomePosition() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GotoHomePositionResponse
#define SOAP_TYPE__tptz__GotoHomePositionResponse (55)
/* tptz:GotoHomePositionResponse */
class SOAP_CMAC _tptz__GotoHomePositionResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE__tptz__GotoHomePositionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GotoHomePositionResponse(): soap(NULL) { _tptz__GotoHomePositionResponse::soap_default(NULL); }
	virtual ~_tptz__GotoHomePositionResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__SetHomePosition
#define SOAP_TYPE__tptz__SetHomePosition (56)
/* tptz:SetHomePosition */
class SOAP_CMAC _tptz__SetHomePosition
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE__tptz__SetHomePosition */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__SetHomePosition(): ProfileToken(NULL), soap(NULL) { _tptz__SetHomePosition::soap_default(NULL); }
	virtual ~_tptz__SetHomePosition() { }
};
#endif

#ifndef SOAP_TYPE__tptz__SetHomePositionResponse
#define SOAP_TYPE__tptz__SetHomePositionResponse (57)
/* tptz:SetHomePositionResponse */
class SOAP_CMAC _tptz__SetHomePositionResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE__tptz__SetHomePositionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__SetHomePositionResponse(): soap(NULL) { _tptz__SetHomePositionResponse::soap_default(NULL); }
	virtual ~_tptz__SetHomePositionResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__ContinuousMove
#define SOAP_TYPE__tptz__ContinuousMove (58)
/* tptz:ContinuousMove */
class SOAP_CMAC _tptz__ContinuousMove
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	tt__PTZSpeed *Velocity;	/* required element of type tt:PTZSpeed */
	char *Timeout;	/* optional element of type xsd:duration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE__tptz__ContinuousMove */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__ContinuousMove(): ProfileToken(NULL), Velocity(NULL), Timeout(NULL), soap(NULL) { _tptz__ContinuousMove::soap_default(NULL); }
	virtual ~_tptz__ContinuousMove() { }
};
#endif

#ifndef SOAP_TYPE__tptz__ContinuousMoveResponse
#define SOAP_TYPE__tptz__ContinuousMoveResponse (59)
/* tptz:ContinuousMoveResponse */
class SOAP_CMAC _tptz__ContinuousMoveResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE__tptz__ContinuousMoveResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__ContinuousMoveResponse(): soap(NULL) { _tptz__ContinuousMoveResponse::soap_default(NULL); }
	virtual ~_tptz__ContinuousMoveResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__RelativeMove
#define SOAP_TYPE__tptz__RelativeMove (60)
/* tptz:RelativeMove */
class SOAP_CMAC _tptz__RelativeMove
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	class tt__PTZVector *Translation;	/* required element of type tt:PTZVector */
	tt__PTZSpeed *Speed;	/* optional element of type tt:PTZSpeed */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE__tptz__RelativeMove */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__RelativeMove(): ProfileToken(NULL), Translation(NULL), Speed(NULL), soap(NULL) { _tptz__RelativeMove::soap_default(NULL); }
	virtual ~_tptz__RelativeMove() { }
};
#endif

#ifndef SOAP_TYPE__tptz__RelativeMoveResponse
#define SOAP_TYPE__tptz__RelativeMoveResponse (61)
/* tptz:RelativeMoveResponse */
class SOAP_CMAC _tptz__RelativeMoveResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE__tptz__RelativeMoveResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__RelativeMoveResponse(): soap(NULL) { _tptz__RelativeMoveResponse::soap_default(NULL); }
	virtual ~_tptz__RelativeMoveResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__AbsoluteMove
#define SOAP_TYPE__tptz__AbsoluteMove (62)
/* tptz:AbsoluteMove */
class SOAP_CMAC _tptz__AbsoluteMove
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	tt__PTZVector *Position;	/* required element of type tt:PTZVector */
	tt__PTZSpeed *Speed;	/* optional element of type tt:PTZSpeed */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE__tptz__AbsoluteMove */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__AbsoluteMove(): ProfileToken(NULL), Position(NULL), Speed(NULL), soap(NULL) { _tptz__AbsoluteMove::soap_default(NULL); }
	virtual ~_tptz__AbsoluteMove() { }
};
#endif

#ifndef SOAP_TYPE__tptz__AbsoluteMoveResponse
#define SOAP_TYPE__tptz__AbsoluteMoveResponse (63)
/* tptz:AbsoluteMoveResponse */
class SOAP_CMAC _tptz__AbsoluteMoveResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE__tptz__AbsoluteMoveResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__AbsoluteMoveResponse(): soap(NULL) { _tptz__AbsoluteMoveResponse::soap_default(NULL); }
	virtual ~_tptz__AbsoluteMoveResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__Stop
#define SOAP_TYPE__tptz__Stop (64)
/* tptz:Stop */
class SOAP_CMAC _tptz__Stop
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	bool *PanTilt;	/* optional element of type xsd:boolean */
	bool *Zoom;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE__tptz__Stop */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__Stop(): ProfileToken(NULL), PanTilt(NULL), Zoom(NULL), soap(NULL) { _tptz__Stop::soap_default(NULL); }
	virtual ~_tptz__Stop() { }
};
#endif

#ifndef SOAP_TYPE__tptz__StopResponse
#define SOAP_TYPE__tptz__StopResponse (65)
/* tptz:StopResponse */
class SOAP_CMAC _tptz__StopResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE__tptz__StopResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__StopResponse(): soap(NULL) { _tptz__StopResponse::soap_default(NULL); }
	virtual ~_tptz__StopResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetPresetTours
#define SOAP_TYPE__tptz__GetPresetTours (66)
/* tptz:GetPresetTours */
class SOAP_CMAC _tptz__GetPresetTours
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE__tptz__GetPresetTours */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetPresetTours(): ProfileToken(NULL), soap(NULL) { _tptz__GetPresetTours::soap_default(NULL); }
	virtual ~_tptz__GetPresetTours() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetPresetToursResponse
#define SOAP_TYPE__tptz__GetPresetToursResponse (67)
/* tptz:GetPresetToursResponse */
class SOAP_CMAC _tptz__GetPresetToursResponse
{
public:
	int __sizePresetTour;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <PresetTour> */
	class tt__PresetTour **PresetTour;	/* optional element of type tt:PresetTour */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE__tptz__GetPresetToursResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetPresetToursResponse(): PresetTour(NULL), soap(NULL) { _tptz__GetPresetToursResponse::soap_default(NULL); }
	virtual ~_tptz__GetPresetToursResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetPresetTour
#define SOAP_TYPE__tptz__GetPresetTour (68)
/* tptz:GetPresetTour */
class SOAP_CMAC _tptz__GetPresetTour
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	char *PresetTourToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE__tptz__GetPresetTour */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetPresetTour(): ProfileToken(NULL), PresetTourToken(NULL), soap(NULL) { _tptz__GetPresetTour::soap_default(NULL); }
	virtual ~_tptz__GetPresetTour() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetPresetTourResponse
#define SOAP_TYPE__tptz__GetPresetTourResponse (69)
/* tptz:GetPresetTourResponse */
class SOAP_CMAC _tptz__GetPresetTourResponse
{
public:
	tt__PresetTour *PresetTour;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:PresetTour */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE__tptz__GetPresetTourResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetPresetTourResponse(): PresetTour(NULL), soap(NULL) { _tptz__GetPresetTourResponse::soap_default(NULL); }
	virtual ~_tptz__GetPresetTourResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetPresetTourOptions
#define SOAP_TYPE__tptz__GetPresetTourOptions (70)
/* tptz:GetPresetTourOptions */
class SOAP_CMAC _tptz__GetPresetTourOptions
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	char *PresetTourToken;	/* optional element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE__tptz__GetPresetTourOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetPresetTourOptions(): ProfileToken(NULL), PresetTourToken(NULL), soap(NULL) { _tptz__GetPresetTourOptions::soap_default(NULL); }
	virtual ~_tptz__GetPresetTourOptions() { }
};
#endif

#ifndef SOAP_TYPE__tptz__GetPresetTourOptionsResponse
#define SOAP_TYPE__tptz__GetPresetTourOptionsResponse (71)
/* tptz:GetPresetTourOptionsResponse */
class SOAP_CMAC _tptz__GetPresetTourOptionsResponse
{
public:
	class tt__PTZPresetTourOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:PTZPresetTourOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE__tptz__GetPresetTourOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__GetPresetTourOptionsResponse(): Options(NULL), soap(NULL) { _tptz__GetPresetTourOptionsResponse::soap_default(NULL); }
	virtual ~_tptz__GetPresetTourOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__CreatePresetTour
#define SOAP_TYPE__tptz__CreatePresetTour (72)
/* tptz:CreatePresetTour */
class SOAP_CMAC _tptz__CreatePresetTour
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE__tptz__CreatePresetTour */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__CreatePresetTour(): ProfileToken(NULL), soap(NULL) { _tptz__CreatePresetTour::soap_default(NULL); }
	virtual ~_tptz__CreatePresetTour() { }
};
#endif

#ifndef SOAP_TYPE__tptz__CreatePresetTourResponse
#define SOAP_TYPE__tptz__CreatePresetTourResponse (73)
/* tptz:CreatePresetTourResponse */
class SOAP_CMAC _tptz__CreatePresetTourResponse
{
public:
	char *PresetTourToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique id SOAP_TYPE__tptz__CreatePresetTourResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__CreatePresetTourResponse(): PresetTourToken(NULL), soap(NULL) { _tptz__CreatePresetTourResponse::soap_default(NULL); }
	virtual ~_tptz__CreatePresetTourResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__ModifyPresetTour
#define SOAP_TYPE__tptz__ModifyPresetTour (74)
/* tptz:ModifyPresetTour */
class SOAP_CMAC _tptz__ModifyPresetTour
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	tt__PresetTour *PresetTour;	/* required element of type tt:PresetTour */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 74; } /* = unique id SOAP_TYPE__tptz__ModifyPresetTour */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__ModifyPresetTour(): ProfileToken(NULL), PresetTour(NULL), soap(NULL) { _tptz__ModifyPresetTour::soap_default(NULL); }
	virtual ~_tptz__ModifyPresetTour() { }
};
#endif

#ifndef SOAP_TYPE__tptz__ModifyPresetTourResponse
#define SOAP_TYPE__tptz__ModifyPresetTourResponse (75)
/* tptz:ModifyPresetTourResponse */
class SOAP_CMAC _tptz__ModifyPresetTourResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 75; } /* = unique id SOAP_TYPE__tptz__ModifyPresetTourResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__ModifyPresetTourResponse(): soap(NULL) { _tptz__ModifyPresetTourResponse::soap_default(NULL); }
	virtual ~_tptz__ModifyPresetTourResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__OperatePresetTour
#define SOAP_TYPE__tptz__OperatePresetTour (76)
/* tptz:OperatePresetTour */
class SOAP_CMAC _tptz__OperatePresetTour
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	char *PresetTourToken;	/* required element of type tt:ReferenceToken */
	enum tt__PTZPresetTourOperation Operation;	/* required element of type tt:PTZPresetTourOperation */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 76; } /* = unique id SOAP_TYPE__tptz__OperatePresetTour */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__OperatePresetTour(): ProfileToken(NULL), PresetTourToken(NULL), soap(NULL) { _tptz__OperatePresetTour::soap_default(NULL); }
	virtual ~_tptz__OperatePresetTour() { }
};
#endif

#ifndef SOAP_TYPE__tptz__OperatePresetTourResponse
#define SOAP_TYPE__tptz__OperatePresetTourResponse (77)
/* tptz:OperatePresetTourResponse */
class SOAP_CMAC _tptz__OperatePresetTourResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 77; } /* = unique id SOAP_TYPE__tptz__OperatePresetTourResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__OperatePresetTourResponse(): soap(NULL) { _tptz__OperatePresetTourResponse::soap_default(NULL); }
	virtual ~_tptz__OperatePresetTourResponse() { }
};
#endif

#ifndef SOAP_TYPE__tptz__RemovePresetTour
#define SOAP_TYPE__tptz__RemovePresetTour (78)
/* tptz:RemovePresetTour */
class SOAP_CMAC _tptz__RemovePresetTour
{
public:
	char *ProfileToken;	/* required element of type tt:ReferenceToken */
	char *PresetTourToken;	/* required element of type tt:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique id SOAP_TYPE__tptz__RemovePresetTour */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__RemovePresetTour(): ProfileToken(NULL), PresetTourToken(NULL), soap(NULL) { _tptz__RemovePresetTour::soap_default(NULL); }
	virtual ~_tptz__RemovePresetTour() { }
};
#endif

#ifndef SOAP_TYPE__tptz__RemovePresetTourResponse
#define SOAP_TYPE__tptz__RemovePresetTourResponse (79)
/* tptz:RemovePresetTourResponse */
class SOAP_CMAC _tptz__RemovePresetTourResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 79; } /* = unique id SOAP_TYPE__tptz__RemovePresetTourResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tptz__RemovePresetTourResponse(): soap(NULL) { _tptz__RemovePresetTourResponse::soap_default(NULL); }
	virtual ~_tptz__RemovePresetTourResponse() { }
};
#endif

#ifndef SOAP_TYPE_tt__DeviceEntity
#define SOAP_TYPE_tt__DeviceEntity (80)
/* tt:DeviceEntity */
class SOAP_CMAC tt__DeviceEntity
{
public:
	char *token;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE_tt__DeviceEntity */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DeviceEntity(): token(NULL), soap(NULL) { tt__DeviceEntity::soap_default(NULL); }
	virtual ~tt__DeviceEntity() { }
};
#endif

#ifndef SOAP_TYPE_tt__IntRectangle
#define SOAP_TYPE_tt__IntRectangle (81)
/* tt:IntRectangle */
class SOAP_CMAC tt__IntRectangle
{
public:
	int x;	/* required attribute */
	int y;	/* required attribute */
	int width;	/* required attribute */
	int height;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 81; } /* = unique id SOAP_TYPE_tt__IntRectangle */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IntRectangle(): soap(NULL) { tt__IntRectangle::soap_default(NULL); }
	virtual ~tt__IntRectangle() { }
};
#endif

#ifndef SOAP_TYPE_tt__IntRectangleRange
#define SOAP_TYPE_tt__IntRectangleRange (82)
/* tt:IntRectangleRange */
class SOAP_CMAC tt__IntRectangleRange
{
public:
	class tt__IntRange *XRange;	/* required element of type tt:IntRange */
	tt__IntRange *YRange;	/* required element of type tt:IntRange */
	tt__IntRange *WidthRange;	/* required element of type tt:IntRange */
	tt__IntRange *HeightRange;	/* required element of type tt:IntRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 82; } /* = unique id SOAP_TYPE_tt__IntRectangleRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IntRectangleRange(): XRange(NULL), YRange(NULL), WidthRange(NULL), HeightRange(NULL), soap(NULL) { tt__IntRectangleRange::soap_default(NULL); }
	virtual ~tt__IntRectangleRange() { }
};
#endif

#ifndef SOAP_TYPE_tt__IntRange
#define SOAP_TYPE_tt__IntRange (83)
/* tt:IntRange */
class SOAP_CMAC tt__IntRange
{
public:
	int Min;	/* required element of type xsd:int */
	int Max;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 83; } /* = unique id SOAP_TYPE_tt__IntRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IntRange(): soap(NULL) { tt__IntRange::soap_default(NULL); }
	virtual ~tt__IntRange() { }
};
#endif

#ifndef SOAP_TYPE_tt__FloatRange
#define SOAP_TYPE_tt__FloatRange (84)
/* tt:FloatRange */
class SOAP_CMAC tt__FloatRange
{
public:
	float Min;	/* required element of type xsd:float */
	float Max;	/* required element of type xsd:float */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 84; } /* = unique id SOAP_TYPE_tt__FloatRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FloatRange(): soap(NULL) { tt__FloatRange::soap_default(NULL); }
	virtual ~tt__FloatRange() { }
};
#endif

#ifndef SOAP_TYPE_tt__DurationRange
#define SOAP_TYPE_tt__DurationRange (85)
/* tt:DurationRange */
class SOAP_CMAC tt__DurationRange
{
public:
	char *Min;	/* required element of type xsd:duration */
	char *Max;	/* required element of type xsd:duration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 85; } /* = unique id SOAP_TYPE_tt__DurationRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DurationRange(): Min(NULL), Max(NULL), soap(NULL) { tt__DurationRange::soap_default(NULL); }
	virtual ~tt__DurationRange() { }
};
#endif

#ifndef SOAP_TYPE_tt__IntList
#define SOAP_TYPE_tt__IntList (86)
/* tt:IntList */
class SOAP_CMAC tt__IntList
{
public:
	int __sizeItems;	/* sequence of elements <Items> */
	int *Items;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE_tt__IntList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IntList(): Items(NULL), soap(NULL) { tt__IntList::soap_default(NULL); }
	virtual ~tt__IntList() { }
};
#endif

#ifndef SOAP_TYPE_tt__FloatList
#define SOAP_TYPE_tt__FloatList (87)
/* tt:FloatList */
class SOAP_CMAC tt__FloatList
{
public:
	int __sizeItems;	/* sequence of elements <Items> */
	float *Items;	/* optional element of type xsd:float */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 87; } /* = unique id SOAP_TYPE_tt__FloatList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FloatList(): Items(NULL), soap(NULL) { tt__FloatList::soap_default(NULL); }
	virtual ~tt__FloatList() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnyHolder
#define SOAP_TYPE_tt__AnyHolder (88)
/* tt:AnyHolder */
class SOAP_CMAC tt__AnyHolder
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE_tt__AnyHolder */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnyHolder(): __any(NULL), soap(NULL) { tt__AnyHolder::soap_default(NULL); }
	virtual ~tt__AnyHolder() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceExtension
#define SOAP_TYPE_tt__VideoSourceExtension (90)
/* tt:VideoSourceExtension */
class SOAP_CMAC tt__VideoSourceExtension
{
public:
	class tt__ImagingSettings20 *Imaging;	/* optional element of type tt:ImagingSettings20 */
	class tt__VideoSourceExtension2 *Extension;	/* optional element of type tt:VideoSourceExtension2 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 90; } /* = unique id SOAP_TYPE_tt__VideoSourceExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceExtension(): Imaging(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__VideoSourceExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceExtension2
#define SOAP_TYPE_tt__VideoSourceExtension2 (91)
/* tt:VideoSourceExtension2 */
class SOAP_CMAC tt__VideoSourceExtension2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 91; } /* = unique id SOAP_TYPE_tt__VideoSourceExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceExtension2(): __any(NULL), soap(NULL) { tt__VideoSourceExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__Profile
#define SOAP_TYPE_tt__Profile (93)
/* tt:Profile */
class SOAP_CMAC tt__Profile
{
public:
	char *Name;	/* required element of type tt:Name */
	class tt__VideoSourceConfiguration *VideoSourceConfiguration;	/* optional element of type tt:VideoSourceConfiguration */
	class tt__AudioSourceConfiguration *AudioSourceConfiguration;	/* optional element of type tt:AudioSourceConfiguration */
	class tt__VideoEncoderConfiguration *VideoEncoderConfiguration;	/* optional element of type tt:VideoEncoderConfiguration */
	class tt__AudioEncoderConfiguration *AudioEncoderConfiguration;	/* optional element of type tt:AudioEncoderConfiguration */
	class tt__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;	/* optional element of type tt:VideoAnalyticsConfiguration */
	tt__PTZConfiguration *PTZConfiguration;	/* optional element of type tt:PTZConfiguration */
	class tt__MetadataConfiguration *MetadataConfiguration;	/* optional element of type tt:MetadataConfiguration */
	class tt__ProfileExtension *Extension;	/* optional element of type tt:ProfileExtension */
	char *token;	/* required attribute */
	bool *fixed;	/* optional attribute */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 93; } /* = unique id SOAP_TYPE_tt__Profile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Profile(): Name(NULL), VideoSourceConfiguration(NULL), AudioSourceConfiguration(NULL), VideoEncoderConfiguration(NULL), AudioEncoderConfiguration(NULL), VideoAnalyticsConfiguration(NULL), PTZConfiguration(NULL), MetadataConfiguration(NULL), Extension(NULL), token(NULL), fixed(NULL), soap(NULL) { tt__Profile::soap_default(NULL); }
	virtual ~tt__Profile() { }
};
#endif

#ifndef SOAP_TYPE_tt__ProfileExtension
#define SOAP_TYPE_tt__ProfileExtension (94)
/* tt:ProfileExtension */
class SOAP_CMAC tt__ProfileExtension
{
public:
	class tt__AudioOutputConfiguration *AudioOutputConfiguration;	/* optional element of type tt:AudioOutputConfiguration */
	class tt__AudioDecoderConfiguration *AudioDecoderConfiguration;	/* optional element of type tt:AudioDecoderConfiguration */
	class tt__ProfileExtension2 *Extension;	/* optional element of type tt:ProfileExtension2 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 94; } /* = unique id SOAP_TYPE_tt__ProfileExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ProfileExtension(): AudioOutputConfiguration(NULL), AudioDecoderConfiguration(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__ProfileExtension::soap_default(NULL); }
	virtual ~tt__ProfileExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ProfileExtension2
#define SOAP_TYPE_tt__ProfileExtension2 (95)
/* tt:ProfileExtension2 */
class SOAP_CMAC tt__ProfileExtension2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 95; } /* = unique id SOAP_TYPE_tt__ProfileExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ProfileExtension2(): __any(NULL), soap(NULL) { tt__ProfileExtension2::soap_default(NULL); }
	virtual ~tt__ProfileExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__ConfigurationEntity
#define SOAP_TYPE_tt__ConfigurationEntity (96)
/* tt:ConfigurationEntity */
class SOAP_CMAC tt__ConfigurationEntity
{
public:
	char *Name;	/* required element of type tt:Name */
	int UseCount;	/* required element of type xsd:int */
	char *token;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 96; } /* = unique id SOAP_TYPE_tt__ConfigurationEntity */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ConfigurationEntity(): Name(NULL), token(NULL), soap(NULL) { tt__ConfigurationEntity::soap_default(NULL); }
	virtual ~tt__ConfigurationEntity() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension (98)
/* tt:VideoSourceConfigurationExtension */
class SOAP_CMAC tt__VideoSourceConfigurationExtension
{
public:
	class tt__Rotate *Rotate;	/* optional element of type tt:Rotate */
	class tt__VideoSourceConfigurationExtension2 *Extension;	/* optional element of type tt:VideoSourceConfigurationExtension2 */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 98; } /* = unique id SOAP_TYPE_tt__VideoSourceConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceConfigurationExtension(): Rotate(NULL), Extension(NULL), soap(NULL) { tt__VideoSourceConfigurationExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension2 (99)
/* tt:VideoSourceConfigurationExtension2 */
class SOAP_CMAC tt__VideoSourceConfigurationExtension2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 99; } /* = unique id SOAP_TYPE_tt__VideoSourceConfigurationExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceConfigurationExtension2(): __any(NULL), soap(NULL) { tt__VideoSourceConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__Rotate
#define SOAP_TYPE_tt__Rotate (100)
/* tt:Rotate */
class SOAP_CMAC tt__Rotate
{
public:
	enum tt__RotateMode Mode;	/* required element of type tt:RotateMode */
	int *Degree;	/* optional element of type xsd:int */
	class tt__RotateExtension *Extension;	/* optional element of type tt:RotateExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 100; } /* = unique id SOAP_TYPE_tt__Rotate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Rotate(): Degree(NULL), Extension(NULL), soap(NULL) { tt__Rotate::soap_default(NULL); }
	virtual ~tt__Rotate() { }
};
#endif

#ifndef SOAP_TYPE_tt__RotateExtension
#define SOAP_TYPE_tt__RotateExtension (101)
/* tt:RotateExtension */
class SOAP_CMAC tt__RotateExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 101; } /* = unique id SOAP_TYPE_tt__RotateExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RotateExtension(): __any(NULL), soap(NULL) { tt__RotateExtension::soap_default(NULL); }
	virtual ~tt__RotateExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptions
#define SOAP_TYPE_tt__VideoSourceConfigurationOptions (102)
/* tt:VideoSourceConfigurationOptions */
class SOAP_CMAC tt__VideoSourceConfigurationOptions
{
public:
	tt__IntRectangleRange *BoundsRange;	/* required element of type tt:IntRectangleRange */
	int __sizeVideoSourceTokensAvailable;	/* sequence of elements <VideoSourceTokensAvailable> */
	char **VideoSourceTokensAvailable;	/* required element of type tt:ReferenceToken */
	class tt__VideoSourceConfigurationOptionsExtension *Extension;	/* optional element of type tt:VideoSourceConfigurationOptionsExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 102; } /* = unique id SOAP_TYPE_tt__VideoSourceConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceConfigurationOptions(): BoundsRange(NULL), VideoSourceTokensAvailable(NULL), Extension(NULL), soap(NULL) { tt__VideoSourceConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension (103)
/* tt:VideoSourceConfigurationOptionsExtension */
class SOAP_CMAC tt__VideoSourceConfigurationOptionsExtension
{
public:
	class tt__RotateOptions *Rotate;	/* optional element of type tt:RotateOptions */
	class tt__VideoSourceConfigurationOptionsExtension2 *Extension;	/* optional element of type tt:VideoSourceConfigurationOptionsExtension2 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 103; } /* = unique id SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceConfigurationOptionsExtension(): Rotate(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__VideoSourceConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2 (104)
/* tt:VideoSourceConfigurationOptionsExtension2 */
class SOAP_CMAC tt__VideoSourceConfigurationOptionsExtension2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 104; } /* = unique id SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceConfigurationOptionsExtension2(): __any(NULL), soap(NULL) { tt__VideoSourceConfigurationOptionsExtension2::soap_default(NULL); }
	virtual ~tt__VideoSourceConfigurationOptionsExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__RotateOptions
#define SOAP_TYPE_tt__RotateOptions (105)
/* tt:RotateOptions */
class SOAP_CMAC tt__RotateOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> */
	enum tt__RotateMode *Mode;	/* required element of type tt:RotateMode */
	tt__IntList *DegreeList;	/* optional element of type tt:IntList */
	class tt__RotateOptionsExtension *Extension;	/* optional element of type tt:RotateOptionsExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 105; } /* = unique id SOAP_TYPE_tt__RotateOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RotateOptions(): Mode(NULL), DegreeList(NULL), Extension(NULL), soap(NULL) { tt__RotateOptions::soap_default(NULL); }
	virtual ~tt__RotateOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__RotateOptionsExtension
#define SOAP_TYPE_tt__RotateOptionsExtension (106)
/* tt:RotateOptionsExtension */
class SOAP_CMAC tt__RotateOptionsExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 106; } /* = unique id SOAP_TYPE_tt__RotateOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RotateOptionsExtension(): __any(NULL), soap(NULL) { tt__RotateOptionsExtension::soap_default(NULL); }
	virtual ~tt__RotateOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoResolution
#define SOAP_TYPE_tt__VideoResolution (108)
/* tt:VideoResolution */
class SOAP_CMAC tt__VideoResolution
{
public:
	int Width;	/* required element of type xsd:int */
	int Height;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 108; } /* = unique id SOAP_TYPE_tt__VideoResolution */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoResolution(): soap(NULL) { tt__VideoResolution::soap_default(NULL); }
	virtual ~tt__VideoResolution() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoRateControl
#define SOAP_TYPE_tt__VideoRateControl (109)
/* tt:VideoRateControl */
class SOAP_CMAC tt__VideoRateControl
{
public:
	int FrameRateLimit;	/* required element of type xsd:int */
	int EncodingInterval;	/* required element of type xsd:int */
	int BitrateLimit;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 109; } /* = unique id SOAP_TYPE_tt__VideoRateControl */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoRateControl(): soap(NULL) { tt__VideoRateControl::soap_default(NULL); }
	virtual ~tt__VideoRateControl() { }
};
#endif

#ifndef SOAP_TYPE_tt__Mpeg4Configuration
#define SOAP_TYPE_tt__Mpeg4Configuration (110)
/* tt:Mpeg4Configuration */
class SOAP_CMAC tt__Mpeg4Configuration
{
public:
	int GovLength;	/* required element of type xsd:int */
	enum tt__Mpeg4Profile Mpeg4Profile;	/* required element of type tt:Mpeg4Profile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 110; } /* = unique id SOAP_TYPE_tt__Mpeg4Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Mpeg4Configuration(): soap(NULL) { tt__Mpeg4Configuration::soap_default(NULL); }
	virtual ~tt__Mpeg4Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__H264Configuration
#define SOAP_TYPE_tt__H264Configuration (111)
/* tt:H264Configuration */
class SOAP_CMAC tt__H264Configuration
{
public:
	int GovLength;	/* required element of type xsd:int */
	enum tt__H264Profile H264Profile;	/* required element of type tt:H264Profile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 111; } /* = unique id SOAP_TYPE_tt__H264Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__H264Configuration(): soap(NULL) { tt__H264Configuration::soap_default(NULL); }
	virtual ~tt__H264Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoEncoderConfigurationOptions
#define SOAP_TYPE_tt__VideoEncoderConfigurationOptions (112)
/* tt:VideoEncoderConfigurationOptions */
class SOAP_CMAC tt__VideoEncoderConfigurationOptions
{
public:
	tt__IntRange *QualityRange;	/* required element of type tt:IntRange */
	class tt__JpegOptions *JPEG;	/* optional element of type tt:JpegOptions */
	class tt__Mpeg4Options *MPEG4;	/* optional element of type tt:Mpeg4Options */
	class tt__H264Options *H264;	/* optional element of type tt:H264Options */
	class tt__VideoEncoderOptionsExtension *Extension;	/* optional element of type tt:VideoEncoderOptionsExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 112; } /* = unique id SOAP_TYPE_tt__VideoEncoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoEncoderConfigurationOptions(): QualityRange(NULL), JPEG(NULL), MPEG4(NULL), H264(NULL), Extension(NULL), soap(NULL) { tt__VideoEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoEncoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension (113)
/* tt:VideoEncoderOptionsExtension */
class SOAP_CMAC tt__VideoEncoderOptionsExtension
{
public:
	class tt__JpegOptions2 *JPEG;	/* optional element of type tt:JpegOptions2 */
	class tt__Mpeg4Options2 *MPEG4;	/* optional element of type tt:Mpeg4Options2 */
	class tt__H264Options2 *H264;	/* optional element of type tt:H264Options2 */
	class tt__VideoEncoderOptionsExtension2 *Extension;	/* optional element of type tt:VideoEncoderOptionsExtension2 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 113; } /* = unique id SOAP_TYPE_tt__VideoEncoderOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoEncoderOptionsExtension(): JPEG(NULL), MPEG4(NULL), H264(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__VideoEncoderOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoEncoderOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension2
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension2 (114)
/* tt:VideoEncoderOptionsExtension2 */
class SOAP_CMAC tt__VideoEncoderOptionsExtension2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 114; } /* = unique id SOAP_TYPE_tt__VideoEncoderOptionsExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoEncoderOptionsExtension2(): __any(NULL), soap(NULL) { tt__VideoEncoderOptionsExtension2::soap_default(NULL); }
	virtual ~tt__VideoEncoderOptionsExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__JpegOptions
#define SOAP_TYPE_tt__JpegOptions (115)
/* tt:JpegOptions */
class SOAP_CMAC tt__JpegOptions
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> */
	tt__VideoResolution **ResolutionsAvailable;	/* required element of type tt:VideoResolution */
	tt__IntRange *FrameRateRange;	/* required element of type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of type tt:IntRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 115; } /* = unique id SOAP_TYPE_tt__JpegOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__JpegOptions(): ResolutionsAvailable(NULL), FrameRateRange(NULL), EncodingIntervalRange(NULL), soap(NULL) { tt__JpegOptions::soap_default(NULL); }
	virtual ~tt__JpegOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__Mpeg4Options
#define SOAP_TYPE_tt__Mpeg4Options (117)
/* tt:Mpeg4Options */
class SOAP_CMAC tt__Mpeg4Options
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> */
	tt__VideoResolution **ResolutionsAvailable;	/* required element of type tt:VideoResolution */
	tt__IntRange *GovLengthRange;	/* required element of type tt:IntRange */
	tt__IntRange *FrameRateRange;	/* required element of type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of type tt:IntRange */
	int __sizeMpeg4ProfilesSupported;	/* sequence of elements <Mpeg4ProfilesSupported> */
	enum tt__Mpeg4Profile *Mpeg4ProfilesSupported;	/* required element of type tt:Mpeg4Profile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 117; } /* = unique id SOAP_TYPE_tt__Mpeg4Options */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Mpeg4Options(): ResolutionsAvailable(NULL), GovLengthRange(NULL), FrameRateRange(NULL), EncodingIntervalRange(NULL), Mpeg4ProfilesSupported(NULL), soap(NULL) { tt__Mpeg4Options::soap_default(NULL); }
	virtual ~tt__Mpeg4Options() { }
};
#endif

#ifndef SOAP_TYPE_tt__H264Options
#define SOAP_TYPE_tt__H264Options (119)
/* tt:H264Options */
class SOAP_CMAC tt__H264Options
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> */
	tt__VideoResolution **ResolutionsAvailable;	/* required element of type tt:VideoResolution */
	tt__IntRange *GovLengthRange;	/* required element of type tt:IntRange */
	tt__IntRange *FrameRateRange;	/* required element of type tt:IntRange */
	tt__IntRange *EncodingIntervalRange;	/* required element of type tt:IntRange */
	int __sizeH264ProfilesSupported;	/* sequence of elements <H264ProfilesSupported> */
	enum tt__H264Profile *H264ProfilesSupported;	/* required element of type tt:H264Profile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 119; } /* = unique id SOAP_TYPE_tt__H264Options */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__H264Options(): ResolutionsAvailable(NULL), GovLengthRange(NULL), FrameRateRange(NULL), EncodingIntervalRange(NULL), H264ProfilesSupported(NULL), soap(NULL) { tt__H264Options::soap_default(NULL); }
	virtual ~tt__H264Options() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioSourceConfigurationOptions
#define SOAP_TYPE_tt__AudioSourceConfigurationOptions (122)
/* tt:AudioSourceConfigurationOptions */
class SOAP_CMAC tt__AudioSourceConfigurationOptions
{
public:
	int __sizeInputTokensAvailable;	/* sequence of elements <InputTokensAvailable> */
	char **InputTokensAvailable;	/* required element of type tt:ReferenceToken */
	class tt__AudioSourceOptionsExtension *Extension;	/* optional element of type tt:AudioSourceOptionsExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 122; } /* = unique id SOAP_TYPE_tt__AudioSourceConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioSourceConfigurationOptions(): InputTokensAvailable(NULL), Extension(NULL), soap(NULL) { tt__AudioSourceConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioSourceConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioSourceOptionsExtension
#define SOAP_TYPE_tt__AudioSourceOptionsExtension (123)
/* tt:AudioSourceOptionsExtension */
class SOAP_CMAC tt__AudioSourceOptionsExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 123; } /* = unique id SOAP_TYPE_tt__AudioSourceOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioSourceOptionsExtension(): __any(NULL), soap(NULL) { tt__AudioSourceOptionsExtension::soap_default(NULL); }
	virtual ~tt__AudioSourceOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOptions
#define SOAP_TYPE_tt__AudioEncoderConfigurationOptions (125)
/* tt:AudioEncoderConfigurationOptions */
class SOAP_CMAC tt__AudioEncoderConfigurationOptions
{
public:
	int __sizeOptions;	/* sequence of elements <Options> */
	class tt__AudioEncoderConfigurationOption **Options;	/* optional element of type tt:AudioEncoderConfigurationOption */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 125; } /* = unique id SOAP_TYPE_tt__AudioEncoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioEncoderConfigurationOptions(): Options(NULL), soap(NULL) { tt__AudioEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOption
#define SOAP_TYPE_tt__AudioEncoderConfigurationOption (126)
/* tt:AudioEncoderConfigurationOption */
class SOAP_CMAC tt__AudioEncoderConfigurationOption
{
public:
	enum tt__AudioEncoding Encoding;	/* required element of type tt:AudioEncoding */
	tt__IntList *BitrateList;	/* required element of type tt:IntList */
	tt__IntList *SampleRateList;	/* required element of type tt:IntList */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 126; } /* = unique id SOAP_TYPE_tt__AudioEncoderConfigurationOption */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioEncoderConfigurationOption(): BitrateList(NULL), SampleRateList(NULL), __any(NULL), soap(NULL) { tt__AudioEncoderConfigurationOption::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfigurationOption() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataConfigurationExtension
#define SOAP_TYPE_tt__MetadataConfigurationExtension (129)
/* tt:MetadataConfigurationExtension */
class SOAP_CMAC tt__MetadataConfigurationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 129; } /* = unique id SOAP_TYPE_tt__MetadataConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataConfigurationExtension(): __any(NULL), soap(NULL) { tt__MetadataConfigurationExtension::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZFilter
#define SOAP_TYPE_tt__PTZFilter (130)
/* tt:PTZFilter */
class SOAP_CMAC tt__PTZFilter
{
public:
	bool Status;	/* required element of type xsd:boolean */
	bool Position;	/* required element of type xsd:boolean */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 130; } /* = unique id SOAP_TYPE_tt__PTZFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZFilter(): soap(NULL) { tt__PTZFilter::soap_default(NULL); }
	virtual ~tt__PTZFilter() { }
};
#endif

#ifndef SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy (725)
/* tt:EventSubscription-SubscriptionPolicy */
class SOAP_CMAC _tt__EventSubscription_SubscriptionPolicy
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
public:
	virtual int soap_type() const { return 725; } /* = unique id SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__EventSubscription_SubscriptionPolicy(): __any(NULL) { _tt__EventSubscription_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_tt__EventSubscription_SubscriptionPolicy() { }
};
#endif

#ifndef SOAP_TYPE_tt__EventSubscription
#define SOAP_TYPE_tt__EventSubscription (131)
/* tt:EventSubscription */
class SOAP_CMAC tt__EventSubscription
{
public:
	class wsnt__FilterType *Filter;	/* optional element of type wsnt:FilterType */
	_tt__EventSubscription_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of type tt:EventSubscription-SubscriptionPolicy */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 131; } /* = unique id SOAP_TYPE_tt__EventSubscription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EventSubscription(): Filter(NULL), SubscriptionPolicy(NULL), __any(NULL), soap(NULL) { tt__EventSubscription::soap_default(NULL); }
	virtual ~tt__EventSubscription() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataConfigurationOptions
#define SOAP_TYPE_tt__MetadataConfigurationOptions (132)
/* tt:MetadataConfigurationOptions */
class SOAP_CMAC tt__MetadataConfigurationOptions
{
public:
	class tt__PTZStatusFilterOptions *PTZStatusFilterOptions;	/* required element of type tt:PTZStatusFilterOptions */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 132; } /* = unique id SOAP_TYPE_tt__MetadataConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataConfigurationOptions(): PTZStatusFilterOptions(NULL), __any(NULL), soap(NULL) { tt__MetadataConfigurationOptions::soap_default(NULL); }
	virtual ~tt__MetadataConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZStatusFilterOptions
#define SOAP_TYPE_tt__PTZStatusFilterOptions (133)
/* tt:PTZStatusFilterOptions */
class SOAP_CMAC tt__PTZStatusFilterOptions
{
public:
	bool PanTiltStatusSupported;	/* required element of type xsd:boolean */
	bool ZoomStatusSupported;	/* required element of type xsd:boolean */
	bool *PanTiltPositionSupported;	/* optional element of type xsd:boolean */
	bool *ZoomPositionSupported;	/* optional element of type xsd:boolean */
	class tt__PTZStatusFilterOptionsExtension *Extension;	/* optional element of type tt:PTZStatusFilterOptionsExtension */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 133; } /* = unique id SOAP_TYPE_tt__PTZStatusFilterOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZStatusFilterOptions(): PanTiltPositionSupported(NULL), ZoomPositionSupported(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__PTZStatusFilterOptions::soap_default(NULL); }
	virtual ~tt__PTZStatusFilterOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZStatusFilterOptionsExtension
#define SOAP_TYPE_tt__PTZStatusFilterOptionsExtension (134)
/* tt:PTZStatusFilterOptionsExtension */
class SOAP_CMAC tt__PTZStatusFilterOptionsExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 134; } /* = unique id SOAP_TYPE_tt__PTZStatusFilterOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZStatusFilterOptionsExtension(): __any(NULL), soap(NULL) { tt__PTZStatusFilterOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZStatusFilterOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoOutputExtension
#define SOAP_TYPE_tt__VideoOutputExtension (136)
/* tt:VideoOutputExtension */
class SOAP_CMAC tt__VideoOutputExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 136; } /* = unique id SOAP_TYPE_tt__VideoOutputExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoOutputExtension(): __any(NULL), soap(NULL) { tt__VideoOutputExtension::soap_default(NULL); }
	virtual ~tt__VideoOutputExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoOutputConfigurationOptions
#define SOAP_TYPE_tt__VideoOutputConfigurationOptions (138)
/* tt:VideoOutputConfigurationOptions */
class SOAP_CMAC tt__VideoOutputConfigurationOptions
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 138; } /* = unique id SOAP_TYPE_tt__VideoOutputConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoOutputConfigurationOptions(): __any(NULL), soap(NULL) { tt__VideoOutputConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoOutputConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoDecoderConfigurationOptions
#define SOAP_TYPE_tt__VideoDecoderConfigurationOptions (139)
/* tt:VideoDecoderConfigurationOptions */
class SOAP_CMAC tt__VideoDecoderConfigurationOptions
{
public:
	class tt__JpegDecOptions *JpegDecOptions;	/* optional element of type tt:JpegDecOptions */
	class tt__H264DecOptions *H264DecOptions;	/* optional element of type tt:H264DecOptions */
	class tt__Mpeg4DecOptions *Mpeg4DecOptions;	/* optional element of type tt:Mpeg4DecOptions */
	class tt__VideoDecoderConfigurationOptionsExtension *Extension;	/* optional element of type tt:VideoDecoderConfigurationOptionsExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 139; } /* = unique id SOAP_TYPE_tt__VideoDecoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoDecoderConfigurationOptions(): JpegDecOptions(NULL), H264DecOptions(NULL), Mpeg4DecOptions(NULL), Extension(NULL), soap(NULL) { tt__VideoDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__VideoDecoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__H264DecOptions
#define SOAP_TYPE_tt__H264DecOptions (140)
/* tt:H264DecOptions */
class SOAP_CMAC tt__H264DecOptions
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> */
	tt__VideoResolution **ResolutionsAvailable;	/* required element of type tt:VideoResolution */
	int __sizeSupportedH264Profiles;	/* sequence of elements <SupportedH264Profiles> */
	enum tt__H264Profile *SupportedH264Profiles;	/* required element of type tt:H264Profile */
	tt__IntRange *SupportedInputBitrate;	/* required element of type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of type tt:IntRange */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 140; } /* = unique id SOAP_TYPE_tt__H264DecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__H264DecOptions(): ResolutionsAvailable(NULL), SupportedH264Profiles(NULL), SupportedInputBitrate(NULL), SupportedFrameRate(NULL), __any(NULL), soap(NULL) { tt__H264DecOptions::soap_default(NULL); }
	virtual ~tt__H264DecOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__JpegDecOptions
#define SOAP_TYPE_tt__JpegDecOptions (141)
/* tt:JpegDecOptions */
class SOAP_CMAC tt__JpegDecOptions
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> */
	tt__VideoResolution **ResolutionsAvailable;	/* required element of type tt:VideoResolution */
	tt__IntRange *SupportedInputBitrate;	/* required element of type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of type tt:IntRange */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 141; } /* = unique id SOAP_TYPE_tt__JpegDecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__JpegDecOptions(): ResolutionsAvailable(NULL), SupportedInputBitrate(NULL), SupportedFrameRate(NULL), __any(NULL), soap(NULL) { tt__JpegDecOptions::soap_default(NULL); }
	virtual ~tt__JpegDecOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__Mpeg4DecOptions
#define SOAP_TYPE_tt__Mpeg4DecOptions (142)
/* tt:Mpeg4DecOptions */
class SOAP_CMAC tt__Mpeg4DecOptions
{
public:
	int __sizeResolutionsAvailable;	/* sequence of elements <ResolutionsAvailable> */
	tt__VideoResolution **ResolutionsAvailable;	/* required element of type tt:VideoResolution */
	int __sizeSupportedMpeg4Profiles;	/* sequence of elements <SupportedMpeg4Profiles> */
	enum tt__Mpeg4Profile *SupportedMpeg4Profiles;	/* required element of type tt:Mpeg4Profile */
	tt__IntRange *SupportedInputBitrate;	/* required element of type tt:IntRange */
	tt__IntRange *SupportedFrameRate;	/* required element of type tt:IntRange */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 142; } /* = unique id SOAP_TYPE_tt__Mpeg4DecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Mpeg4DecOptions(): ResolutionsAvailable(NULL), SupportedMpeg4Profiles(NULL), SupportedInputBitrate(NULL), SupportedFrameRate(NULL), __any(NULL), soap(NULL) { tt__Mpeg4DecOptions::soap_default(NULL); }
	virtual ~tt__Mpeg4DecOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension (143)
/* tt:VideoDecoderConfigurationOptionsExtension */
class SOAP_CMAC tt__VideoDecoderConfigurationOptionsExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 143; } /* = unique id SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoDecoderConfigurationOptionsExtension(): __any(NULL), soap(NULL) { tt__VideoDecoderConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__VideoDecoderConfigurationOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioOutputConfigurationOptions
#define SOAP_TYPE_tt__AudioOutputConfigurationOptions (146)
/* tt:AudioOutputConfigurationOptions */
class SOAP_CMAC tt__AudioOutputConfigurationOptions
{
public:
	int __sizeOutputTokensAvailable;	/* sequence of elements <OutputTokensAvailable> */
	char **OutputTokensAvailable;	/* required element of type tt:ReferenceToken */
	int __sizeSendPrimacyOptions;	/* sequence of elements <SendPrimacyOptions> */
	char **SendPrimacyOptions;	/* optional element of type xsd:anyURI */
	tt__IntRange *OutputLevelRange;	/* required element of type tt:IntRange */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 146; } /* = unique id SOAP_TYPE_tt__AudioOutputConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioOutputConfigurationOptions(): OutputTokensAvailable(NULL), SendPrimacyOptions(NULL), OutputLevelRange(NULL), __any(NULL), soap(NULL) { tt__AudioOutputConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioOutputConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptions
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptions (148)
/* tt:AudioDecoderConfigurationOptions */
class SOAP_CMAC tt__AudioDecoderConfigurationOptions
{
public:
	class tt__AACDecOptions *AACDecOptions;	/* optional element of type tt:AACDecOptions */
	class tt__G711DecOptions *G711DecOptions;	/* optional element of type tt:G711DecOptions */
	class tt__G726DecOptions *G726DecOptions;	/* optional element of type tt:G726DecOptions */
	class tt__AudioDecoderConfigurationOptionsExtension *Extension;	/* optional element of type tt:AudioDecoderConfigurationOptionsExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 148; } /* = unique id SOAP_TYPE_tt__AudioDecoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioDecoderConfigurationOptions(): AACDecOptions(NULL), G711DecOptions(NULL), G726DecOptions(NULL), Extension(NULL), soap(NULL) { tt__AudioDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__G711DecOptions
#define SOAP_TYPE_tt__G711DecOptions (149)
/* tt:G711DecOptions */
class SOAP_CMAC tt__G711DecOptions
{
public:
	tt__IntList *Bitrate;	/* required element of type tt:IntList */
	tt__IntList *SampleRateRange;	/* required element of type tt:IntList */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 149; } /* = unique id SOAP_TYPE_tt__G711DecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__G711DecOptions(): Bitrate(NULL), SampleRateRange(NULL), __any(NULL), soap(NULL) { tt__G711DecOptions::soap_default(NULL); }
	virtual ~tt__G711DecOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__AACDecOptions
#define SOAP_TYPE_tt__AACDecOptions (150)
/* tt:AACDecOptions */
class SOAP_CMAC tt__AACDecOptions
{
public:
	tt__IntList *Bitrate;	/* required element of type tt:IntList */
	tt__IntList *SampleRateRange;	/* required element of type tt:IntList */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 150; } /* = unique id SOAP_TYPE_tt__AACDecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AACDecOptions(): Bitrate(NULL), SampleRateRange(NULL), __any(NULL), soap(NULL) { tt__AACDecOptions::soap_default(NULL); }
	virtual ~tt__AACDecOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__G726DecOptions
#define SOAP_TYPE_tt__G726DecOptions (151)
/* tt:G726DecOptions */
class SOAP_CMAC tt__G726DecOptions
{
public:
	tt__IntList *Bitrate;	/* required element of type tt:IntList */
	tt__IntList *SampleRateRange;	/* required element of type tt:IntList */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 151; } /* = unique id SOAP_TYPE_tt__G726DecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__G726DecOptions(): Bitrate(NULL), SampleRateRange(NULL), __any(NULL), soap(NULL) { tt__G726DecOptions::soap_default(NULL); }
	virtual ~tt__G726DecOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension (152)
/* tt:AudioDecoderConfigurationOptionsExtension */
class SOAP_CMAC tt__AudioDecoderConfigurationOptionsExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 152; } /* = unique id SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioDecoderConfigurationOptionsExtension(): __any(NULL), soap(NULL) { tt__AudioDecoderConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfigurationOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__MulticastConfiguration
#define SOAP_TYPE_tt__MulticastConfiguration (153)
/* tt:MulticastConfiguration */
class SOAP_CMAC tt__MulticastConfiguration
{
public:
	class tt__IPAddress *Address;	/* required element of type tt:IPAddress */
	int Port;	/* required element of type xsd:int */
	int TTL;	/* required element of type xsd:int */
	bool AutoStart;	/* required element of type xsd:boolean */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 153; } /* = unique id SOAP_TYPE_tt__MulticastConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MulticastConfiguration(): Address(NULL), __any(NULL), soap(NULL) { tt__MulticastConfiguration::soap_default(NULL); }
	virtual ~tt__MulticastConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__StreamSetup
#define SOAP_TYPE_tt__StreamSetup (154)
/* tt:StreamSetup */
class SOAP_CMAC tt__StreamSetup
{
public:
	enum tt__StreamType Stream;	/* required element of type tt:StreamType */
	class tt__Transport *Transport;	/* required element of type tt:Transport */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 154; } /* = unique id SOAP_TYPE_tt__StreamSetup */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__StreamSetup(): Transport(NULL), __any(NULL), soap(NULL) { tt__StreamSetup::soap_default(NULL); }
	virtual ~tt__StreamSetup() { }
};
#endif

#ifndef SOAP_TYPE_tt__Transport
#define SOAP_TYPE_tt__Transport (155)
/* tt:Transport */
class SOAP_CMAC tt__Transport
{
public:
	enum tt__TransportProtocol Protocol;	/* required element of type tt:TransportProtocol */
	tt__Transport *Tunnel;	/* optional element of type tt:Transport */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 155; } /* = unique id SOAP_TYPE_tt__Transport */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Transport(): Tunnel(NULL), soap(NULL) { tt__Transport::soap_default(NULL); }
	virtual ~tt__Transport() { }
};
#endif

#ifndef SOAP_TYPE_tt__MediaUri
#define SOAP_TYPE_tt__MediaUri (156)
/* tt:MediaUri */
class SOAP_CMAC tt__MediaUri
{
public:
	char *Uri;	/* required element of type xsd:anyURI */
	bool InvalidAfterConnect;	/* required element of type xsd:boolean */
	bool InvalidAfterReboot;	/* required element of type xsd:boolean */
	char *Timeout;	/* required element of type xsd:duration */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 156; } /* = unique id SOAP_TYPE_tt__MediaUri */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MediaUri(): Uri(NULL), Timeout(NULL), __any(NULL), soap(NULL) { tt__MediaUri::soap_default(NULL); }
	virtual ~tt__MediaUri() { }
};
#endif

#ifndef SOAP_TYPE_tt__Scope
#define SOAP_TYPE_tt__Scope (157)
/* tt:Scope */
class SOAP_CMAC tt__Scope
{
public:
	enum tt__ScopeDefinition ScopeDef;	/* required element of type tt:ScopeDefinition */
	char *ScopeItem;	/* required element of type xsd:anyURI */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 157; } /* = unique id SOAP_TYPE_tt__Scope */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Scope(): ScopeItem(NULL), soap(NULL) { tt__Scope::soap_default(NULL); }
	virtual ~tt__Scope() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension
#define SOAP_TYPE_tt__NetworkInterfaceExtension (159)
/* tt:NetworkInterfaceExtension */
class SOAP_CMAC tt__NetworkInterfaceExtension
{
public:
	int InterfaceType;	/* required element of type tt:IANA-IfTypes */
	int __sizeDot3;	/* sequence of elements <Dot3> */
	class tt__Dot3Configuration **Dot3;	/* optional element of type tt:Dot3Configuration */
	int __sizeDot11;	/* sequence of elements <Dot11> */
	class tt__Dot11Configuration **Dot11;	/* optional element of type tt:Dot11Configuration */
	class tt__NetworkInterfaceExtension2 *Extension;	/* optional element of type tt:NetworkInterfaceExtension2 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 159; } /* = unique id SOAP_TYPE_tt__NetworkInterfaceExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceExtension(): Dot3(NULL), Dot11(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__NetworkInterfaceExtension::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot3Configuration
#define SOAP_TYPE_tt__Dot3Configuration (160)
/* tt:Dot3Configuration */
class SOAP_CMAC tt__Dot3Configuration
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 160; } /* = unique id SOAP_TYPE_tt__Dot3Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot3Configuration(): __any(NULL), soap(NULL) { tt__Dot3Configuration::soap_default(NULL); }
	virtual ~tt__Dot3Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension2
#define SOAP_TYPE_tt__NetworkInterfaceExtension2 (161)
/* tt:NetworkInterfaceExtension2 */
class SOAP_CMAC tt__NetworkInterfaceExtension2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 161; } /* = unique id SOAP_TYPE_tt__NetworkInterfaceExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceExtension2(): __any(NULL), soap(NULL) { tt__NetworkInterfaceExtension2::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceLink
#define SOAP_TYPE_tt__NetworkInterfaceLink (162)
/* tt:NetworkInterfaceLink */
class SOAP_CMAC tt__NetworkInterfaceLink
{
public:
	class tt__NetworkInterfaceConnectionSetting *AdminSettings;	/* required element of type tt:NetworkInterfaceConnectionSetting */
	tt__NetworkInterfaceConnectionSetting *OperSettings;	/* required element of type tt:NetworkInterfaceConnectionSetting */
	int InterfaceType;	/* required element of type tt:IANA-IfTypes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 162; } /* = unique id SOAP_TYPE_tt__NetworkInterfaceLink */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceLink(): AdminSettings(NULL), OperSettings(NULL), soap(NULL) { tt__NetworkInterfaceLink::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceLink() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceConnectionSetting
#define SOAP_TYPE_tt__NetworkInterfaceConnectionSetting (163)
/* tt:NetworkInterfaceConnectionSetting */
class SOAP_CMAC tt__NetworkInterfaceConnectionSetting
{
public:
	bool AutoNegotiation;	/* required element of type xsd:boolean */
	int Speed;	/* required element of type xsd:int */
	enum tt__Duplex Duplex;	/* required element of type tt:Duplex */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 163; } /* = unique id SOAP_TYPE_tt__NetworkInterfaceConnectionSetting */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceConnectionSetting(): soap(NULL) { tt__NetworkInterfaceConnectionSetting::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceConnectionSetting() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceInfo
#define SOAP_TYPE_tt__NetworkInterfaceInfo (164)
/* tt:NetworkInterfaceInfo */
class SOAP_CMAC tt__NetworkInterfaceInfo
{
public:
	char *Name;	/* optional element of type xsd:string */
	char *HwAddress;	/* required element of type tt:HwAddress */
	int *MTU;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 164; } /* = unique id SOAP_TYPE_tt__NetworkInterfaceInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceInfo(): Name(NULL), HwAddress(NULL), MTU(NULL), soap(NULL) { tt__NetworkInterfaceInfo::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceInfo() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv6NetworkInterface
#define SOAP_TYPE_tt__IPv6NetworkInterface (165)
/* tt:IPv6NetworkInterface */
class SOAP_CMAC tt__IPv6NetworkInterface
{
public:
	bool Enabled;	/* required element of type xsd:boolean */
	class tt__IPv6Configuration *Config;	/* optional element of type tt:IPv6Configuration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 165; } /* = unique id SOAP_TYPE_tt__IPv6NetworkInterface */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv6NetworkInterface(): Config(NULL), soap(NULL) { tt__IPv6NetworkInterface::soap_default(NULL); }
	virtual ~tt__IPv6NetworkInterface() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv4NetworkInterface
#define SOAP_TYPE_tt__IPv4NetworkInterface (166)
/* tt:IPv4NetworkInterface */
class SOAP_CMAC tt__IPv4NetworkInterface
{
public:
	bool Enabled;	/* required element of type xsd:boolean */
	class tt__IPv4Configuration *Config;	/* required element of type tt:IPv4Configuration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 166; } /* = unique id SOAP_TYPE_tt__IPv4NetworkInterface */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv4NetworkInterface(): Config(NULL), soap(NULL) { tt__IPv4NetworkInterface::soap_default(NULL); }
	virtual ~tt__IPv4NetworkInterface() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv4Configuration
#define SOAP_TYPE_tt__IPv4Configuration (167)
/* tt:IPv4Configuration */
class SOAP_CMAC tt__IPv4Configuration
{
public:
	int __sizeManual;	/* sequence of elements <Manual> */
	class tt__PrefixedIPv4Address **Manual;	/* optional element of type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address *LinkLocal;	/* optional element of type tt:PrefixedIPv4Address */
	tt__PrefixedIPv4Address *FromDHCP;	/* optional element of type tt:PrefixedIPv4Address */
	bool DHCP;	/* required element of type xsd:boolean */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 167; } /* = unique id SOAP_TYPE_tt__IPv4Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv4Configuration(): Manual(NULL), LinkLocal(NULL), FromDHCP(NULL), __any(NULL), soap(NULL) { tt__IPv4Configuration::soap_default(NULL); }
	virtual ~tt__IPv4Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv6Configuration
#define SOAP_TYPE_tt__IPv6Configuration (168)
/* tt:IPv6Configuration */
class SOAP_CMAC tt__IPv6Configuration
{
public:
	bool *AcceptRouterAdvert;	/* optional element of type xsd:boolean */
	enum tt__IPv6DHCPConfiguration DHCP;	/* required element of type tt:IPv6DHCPConfiguration */
	int __sizeManual;	/* sequence of elements <Manual> */
	class tt__PrefixedIPv6Address **Manual;	/* optional element of type tt:PrefixedIPv6Address */
	int __sizeLinkLocal;	/* sequence of elements <LinkLocal> */
	tt__PrefixedIPv6Address **LinkLocal;	/* optional element of type tt:PrefixedIPv6Address */
	int __sizeFromDHCP;	/* sequence of elements <FromDHCP> */
	tt__PrefixedIPv6Address **FromDHCP;	/* optional element of type tt:PrefixedIPv6Address */
	int __sizeFromRA;	/* sequence of elements <FromRA> */
	tt__PrefixedIPv6Address **FromRA;	/* optional element of type tt:PrefixedIPv6Address */
	class tt__IPv6ConfigurationExtension *Extension;	/* optional element of type tt:IPv6ConfigurationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 168; } /* = unique id SOAP_TYPE_tt__IPv6Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv6Configuration(): AcceptRouterAdvert(NULL), Manual(NULL), LinkLocal(NULL), FromDHCP(NULL), FromRA(NULL), Extension(NULL), soap(NULL) { tt__IPv6Configuration::soap_default(NULL); }
	virtual ~tt__IPv6Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv6ConfigurationExtension
#define SOAP_TYPE_tt__IPv6ConfigurationExtension (169)
/* tt:IPv6ConfigurationExtension */
class SOAP_CMAC tt__IPv6ConfigurationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 169; } /* = unique id SOAP_TYPE_tt__IPv6ConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv6ConfigurationExtension(): __any(NULL), soap(NULL) { tt__IPv6ConfigurationExtension::soap_default(NULL); }
	virtual ~tt__IPv6ConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkProtocol
#define SOAP_TYPE_tt__NetworkProtocol (170)
/* tt:NetworkProtocol */
class SOAP_CMAC tt__NetworkProtocol
{
public:
	enum tt__NetworkProtocolType Name;	/* required element of type tt:NetworkProtocolType */
	bool Enabled;	/* required element of type xsd:boolean */
	int __sizePort;	/* sequence of elements <Port> */
	int *Port;	/* required element of type xsd:int */
	class tt__NetworkProtocolExtension *Extension;	/* optional element of type tt:NetworkProtocolExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 170; } /* = unique id SOAP_TYPE_tt__NetworkProtocol */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkProtocol(): Port(NULL), Extension(NULL), soap(NULL) { tt__NetworkProtocol::soap_default(NULL); }
	virtual ~tt__NetworkProtocol() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkProtocolExtension
#define SOAP_TYPE_tt__NetworkProtocolExtension (171)
/* tt:NetworkProtocolExtension */
class SOAP_CMAC tt__NetworkProtocolExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 171; } /* = unique id SOAP_TYPE_tt__NetworkProtocolExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkProtocolExtension(): __any(NULL), soap(NULL) { tt__NetworkProtocolExtension::soap_default(NULL); }
	virtual ~tt__NetworkProtocolExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkHost
#define SOAP_TYPE_tt__NetworkHost (172)
/* tt:NetworkHost */
class SOAP_CMAC tt__NetworkHost
{
public:
	enum tt__NetworkHostType Type;	/* required element of type tt:NetworkHostType */
	char **IPv4Address;	/* optional element of type tt:IPv4Address */
	char **IPv6Address;	/* optional element of type tt:IPv6Address */
	char **DNSname;	/* optional element of type tt:DNSName */
	class tt__NetworkHostExtension *Extension;	/* optional element of type tt:NetworkHostExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 172; } /* = unique id SOAP_TYPE_tt__NetworkHost */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkHost(): IPv4Address(NULL), IPv6Address(NULL), DNSname(NULL), Extension(NULL), soap(NULL) { tt__NetworkHost::soap_default(NULL); }
	virtual ~tt__NetworkHost() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkHostExtension
#define SOAP_TYPE_tt__NetworkHostExtension (173)
/* tt:NetworkHostExtension */
class SOAP_CMAC tt__NetworkHostExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 173; } /* = unique id SOAP_TYPE_tt__NetworkHostExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkHostExtension(): __any(NULL), soap(NULL) { tt__NetworkHostExtension::soap_default(NULL); }
	virtual ~tt__NetworkHostExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPAddress
#define SOAP_TYPE_tt__IPAddress (174)
/* tt:IPAddress */
class SOAP_CMAC tt__IPAddress
{
public:
	enum tt__IPType Type;	/* required element of type tt:IPType */
	char **IPv4Address;	/* optional element of type tt:IPv4Address */
	char **IPv6Address;	/* optional element of type tt:IPv6Address */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 174; } /* = unique id SOAP_TYPE_tt__IPAddress */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPAddress(): IPv4Address(NULL), IPv6Address(NULL), soap(NULL) { tt__IPAddress::soap_default(NULL); }
	virtual ~tt__IPAddress() { }
};
#endif

#ifndef SOAP_TYPE_tt__PrefixedIPv4Address
#define SOAP_TYPE_tt__PrefixedIPv4Address (175)
/* tt:PrefixedIPv4Address */
class SOAP_CMAC tt__PrefixedIPv4Address
{
public:
	char *Address;	/* required element of type tt:IPv4Address */
	int PrefixLength;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 175; } /* = unique id SOAP_TYPE_tt__PrefixedIPv4Address */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PrefixedIPv4Address(): Address(NULL), soap(NULL) { tt__PrefixedIPv4Address::soap_default(NULL); }
	virtual ~tt__PrefixedIPv4Address() { }
};
#endif

#ifndef SOAP_TYPE_tt__PrefixedIPv6Address
#define SOAP_TYPE_tt__PrefixedIPv6Address (176)
/* tt:PrefixedIPv6Address */
class SOAP_CMAC tt__PrefixedIPv6Address
{
public:
	char *Address;	/* required element of type tt:IPv6Address */
	int PrefixLength;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 176; } /* = unique id SOAP_TYPE_tt__PrefixedIPv6Address */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PrefixedIPv6Address(): Address(NULL), soap(NULL) { tt__PrefixedIPv6Address::soap_default(NULL); }
	virtual ~tt__PrefixedIPv6Address() { }
};
#endif

#ifndef SOAP_TYPE_tt__HostnameInformation
#define SOAP_TYPE_tt__HostnameInformation (177)
/* tt:HostnameInformation */
class SOAP_CMAC tt__HostnameInformation
{
public:
	bool FromDHCP;	/* required element of type xsd:boolean */
	char *Name;	/* optional element of type xsd:token */
	class tt__HostnameInformationExtension *Extension;	/* optional element of type tt:HostnameInformationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 177; } /* = unique id SOAP_TYPE_tt__HostnameInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__HostnameInformation(): Name(NULL), Extension(NULL), soap(NULL) { tt__HostnameInformation::soap_default(NULL); }
	virtual ~tt__HostnameInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__HostnameInformationExtension
#define SOAP_TYPE_tt__HostnameInformationExtension (178)
/* tt:HostnameInformationExtension */
class SOAP_CMAC tt__HostnameInformationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 178; } /* = unique id SOAP_TYPE_tt__HostnameInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__HostnameInformationExtension(): __any(NULL), soap(NULL) { tt__HostnameInformationExtension::soap_default(NULL); }
	virtual ~tt__HostnameInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__DNSInformation
#define SOAP_TYPE_tt__DNSInformation (179)
/* tt:DNSInformation */
class SOAP_CMAC tt__DNSInformation
{
public:
	bool FromDHCP;	/* required element of type xsd:boolean */
	int __sizeSearchDomain;	/* sequence of elements <SearchDomain> */
	char **SearchDomain;	/* optional element of type xsd:token */
	int __sizeDNSFromDHCP;	/* sequence of elements <DNSFromDHCP> */
	tt__IPAddress **DNSFromDHCP;	/* optional element of type tt:IPAddress */
	int __sizeDNSManual;	/* sequence of elements <DNSManual> */
	tt__IPAddress **DNSManual;	/* optional element of type tt:IPAddress */
	class tt__DNSInformationExtension *Extension;	/* optional element of type tt:DNSInformationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 179; } /* = unique id SOAP_TYPE_tt__DNSInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DNSInformation(): SearchDomain(NULL), DNSFromDHCP(NULL), DNSManual(NULL), Extension(NULL), soap(NULL) { tt__DNSInformation::soap_default(NULL); }
	virtual ~tt__DNSInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__DNSInformationExtension
#define SOAP_TYPE_tt__DNSInformationExtension (180)
/* tt:DNSInformationExtension */
class SOAP_CMAC tt__DNSInformationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 180; } /* = unique id SOAP_TYPE_tt__DNSInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DNSInformationExtension(): __any(NULL), soap(NULL) { tt__DNSInformationExtension::soap_default(NULL); }
	virtual ~tt__DNSInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NTPInformation
#define SOAP_TYPE_tt__NTPInformation (181)
/* tt:NTPInformation */
class SOAP_CMAC tt__NTPInformation
{
public:
	bool FromDHCP;	/* required element of type xsd:boolean */
	int __sizeNTPFromDHCP;	/* sequence of elements <NTPFromDHCP> */
	tt__NetworkHost **NTPFromDHCP;	/* optional element of type tt:NetworkHost */
	int __sizeNTPManual;	/* sequence of elements <NTPManual> */
	tt__NetworkHost **NTPManual;	/* optional element of type tt:NetworkHost */
	class tt__NTPInformationExtension *Extension;	/* optional element of type tt:NTPInformationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 181; } /* = unique id SOAP_TYPE_tt__NTPInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NTPInformation(): NTPFromDHCP(NULL), NTPManual(NULL), Extension(NULL), soap(NULL) { tt__NTPInformation::soap_default(NULL); }
	virtual ~tt__NTPInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__NTPInformationExtension
#define SOAP_TYPE_tt__NTPInformationExtension (182)
/* tt:NTPInformationExtension */
class SOAP_CMAC tt__NTPInformationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 182; } /* = unique id SOAP_TYPE_tt__NTPInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NTPInformationExtension(): __any(NULL), soap(NULL) { tt__NTPInformationExtension::soap_default(NULL); }
	virtual ~tt__NTPInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__DynamicDNSInformation
#define SOAP_TYPE_tt__DynamicDNSInformation (183)
/* tt:DynamicDNSInformation */
class SOAP_CMAC tt__DynamicDNSInformation
{
public:
	enum tt__DynamicDNSType Type;	/* required element of type tt:DynamicDNSType */
	char **Name;	/* optional element of type tt:DNSName */
	char *TTL;	/* optional element of type xsd:duration */
	class tt__DynamicDNSInformationExtension *Extension;	/* optional element of type tt:DynamicDNSInformationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 183; } /* = unique id SOAP_TYPE_tt__DynamicDNSInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DynamicDNSInformation(): Name(NULL), TTL(NULL), Extension(NULL), soap(NULL) { tt__DynamicDNSInformation::soap_default(NULL); }
	virtual ~tt__DynamicDNSInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__DynamicDNSInformationExtension
#define SOAP_TYPE_tt__DynamicDNSInformationExtension (184)
/* tt:DynamicDNSInformationExtension */
class SOAP_CMAC tt__DynamicDNSInformationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 184; } /* = unique id SOAP_TYPE_tt__DynamicDNSInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DynamicDNSInformationExtension(): __any(NULL), soap(NULL) { tt__DynamicDNSInformationExtension::soap_default(NULL); }
	virtual ~tt__DynamicDNSInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__NetworkInterfaceSetConfiguration (185)
/* tt:NetworkInterfaceSetConfiguration */
class SOAP_CMAC tt__NetworkInterfaceSetConfiguration
{
public:
	bool *Enabled;	/* optional element of type xsd:boolean */
	tt__NetworkInterfaceConnectionSetting *Link;	/* optional element of type tt:NetworkInterfaceConnectionSetting */
	int *MTU;	/* optional element of type xsd:int */
	class tt__IPv4NetworkInterfaceSetConfiguration *IPv4;	/* optional element of type tt:IPv4NetworkInterfaceSetConfiguration */
	class tt__IPv6NetworkInterfaceSetConfiguration *IPv6;	/* optional element of type tt:IPv6NetworkInterfaceSetConfiguration */
	class tt__NetworkInterfaceSetConfigurationExtension *Extension;	/* optional element of type tt:NetworkInterfaceSetConfigurationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 185; } /* = unique id SOAP_TYPE_tt__NetworkInterfaceSetConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceSetConfiguration(): Enabled(NULL), Link(NULL), MTU(NULL), IPv4(NULL), IPv6(NULL), Extension(NULL), soap(NULL) { tt__NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension (186)
/* tt:NetworkInterfaceSetConfigurationExtension */
class SOAP_CMAC tt__NetworkInterfaceSetConfigurationExtension
{
public:
	int __sizeDot3;	/* sequence of elements <Dot3> */
	tt__Dot3Configuration **Dot3;	/* optional element of type tt:Dot3Configuration */
	int __sizeDot11;	/* sequence of elements <Dot11> */
	tt__Dot11Configuration **Dot11;	/* optional element of type tt:Dot11Configuration */
	class tt__NetworkInterfaceSetConfigurationExtension2 *Extension;	/* optional element of type tt:NetworkInterfaceSetConfigurationExtension2 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 186; } /* = unique id SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceSetConfigurationExtension(): Dot3(NULL), Dot11(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__NetworkInterfaceSetConfigurationExtension::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration (187)
/* tt:IPv6NetworkInterfaceSetConfiguration */
class SOAP_CMAC tt__IPv6NetworkInterfaceSetConfiguration
{
public:
	bool *Enabled;	/* optional element of type xsd:boolean */
	bool *AcceptRouterAdvert;	/* optional element of type xsd:boolean */
	int __sizeManual;	/* sequence of elements <Manual> */
	tt__PrefixedIPv6Address **Manual;	/* optional element of type tt:PrefixedIPv6Address */
	enum tt__IPv6DHCPConfiguration *DHCP;	/* optional element of type tt:IPv6DHCPConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 187; } /* = unique id SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv6NetworkInterfaceSetConfiguration(): Enabled(NULL), AcceptRouterAdvert(NULL), Manual(NULL), DHCP(NULL), soap(NULL) { tt__IPv6NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__IPv6NetworkInterfaceSetConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration (188)
/* tt:IPv4NetworkInterfaceSetConfiguration */
class SOAP_CMAC tt__IPv4NetworkInterfaceSetConfiguration
{
public:
	bool *Enabled;	/* optional element of type xsd:boolean */
	int __sizeManual;	/* sequence of elements <Manual> */
	tt__PrefixedIPv4Address **Manual;	/* optional element of type tt:PrefixedIPv4Address */
	bool *DHCP;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 188; } /* = unique id SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPv4NetworkInterfaceSetConfiguration(): Enabled(NULL), Manual(NULL), DHCP(NULL), soap(NULL) { tt__IPv4NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~tt__IPv4NetworkInterfaceSetConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkGateway
#define SOAP_TYPE_tt__NetworkGateway (189)
/* tt:NetworkGateway */
class SOAP_CMAC tt__NetworkGateway
{
public:
	int __sizeIPv4Address;	/* sequence of elements <IPv4Address> */
	char **IPv4Address;	/* optional element of type tt:IPv4Address */
	int __sizeIPv6Address;	/* sequence of elements <IPv6Address> */
	char **IPv6Address;	/* optional element of type tt:IPv6Address */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 189; } /* = unique id SOAP_TYPE_tt__NetworkGateway */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkGateway(): IPv4Address(NULL), IPv6Address(NULL), soap(NULL) { tt__NetworkGateway::soap_default(NULL); }
	virtual ~tt__NetworkGateway() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkZeroConfiguration
#define SOAP_TYPE_tt__NetworkZeroConfiguration (190)
/* tt:NetworkZeroConfiguration */
class SOAP_CMAC tt__NetworkZeroConfiguration
{
public:
	char *InterfaceToken;	/* required element of type tt:ReferenceToken */
	bool Enabled;	/* required element of type xsd:boolean */
	int __sizeAddresses;	/* sequence of elements <Addresses> */
	char **Addresses;	/* optional element of type tt:IPv4Address */
	class tt__NetworkZeroConfigurationExtension *Extension;	/* optional element of type tt:NetworkZeroConfigurationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 190; } /* = unique id SOAP_TYPE_tt__NetworkZeroConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkZeroConfiguration(): InterfaceToken(NULL), Addresses(NULL), Extension(NULL), soap(NULL) { tt__NetworkZeroConfiguration::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension (191)
/* tt:NetworkZeroConfigurationExtension */
class SOAP_CMAC tt__NetworkZeroConfigurationExtension
{
public:
	int __sizeAdditional;	/* sequence of elements <Additional> */
	tt__NetworkZeroConfiguration **Additional;	/* optional element of type tt:NetworkZeroConfiguration */
	class tt__NetworkZeroConfigurationExtension2 *Extension;	/* optional element of type tt:NetworkZeroConfigurationExtension2 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 191; } /* = unique id SOAP_TYPE_tt__NetworkZeroConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkZeroConfigurationExtension(): Additional(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__NetworkZeroConfigurationExtension::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension2
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 (192)
/* tt:NetworkZeroConfigurationExtension2 */
class SOAP_CMAC tt__NetworkZeroConfigurationExtension2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 192; } /* = unique id SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkZeroConfigurationExtension2(): __any(NULL), soap(NULL) { tt__NetworkZeroConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__NetworkZeroConfigurationExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPAddressFilter
#define SOAP_TYPE_tt__IPAddressFilter (193)
/* tt:IPAddressFilter */
class SOAP_CMAC tt__IPAddressFilter
{
public:
	enum tt__IPAddressFilterType Type;	/* required element of type tt:IPAddressFilterType */
	int __sizeIPv4Address;	/* sequence of elements <IPv4Address> */
	tt__PrefixedIPv4Address **IPv4Address;	/* optional element of type tt:PrefixedIPv4Address */
	int __sizeIPv6Address;	/* sequence of elements <IPv6Address> */
	tt__PrefixedIPv6Address **IPv6Address;	/* optional element of type tt:PrefixedIPv6Address */
	class tt__IPAddressFilterExtension *Extension;	/* optional element of type tt:IPAddressFilterExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 193; } /* = unique id SOAP_TYPE_tt__IPAddressFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPAddressFilter(): IPv4Address(NULL), IPv6Address(NULL), Extension(NULL), soap(NULL) { tt__IPAddressFilter::soap_default(NULL); }
	virtual ~tt__IPAddressFilter() { }
};
#endif

#ifndef SOAP_TYPE_tt__IPAddressFilterExtension
#define SOAP_TYPE_tt__IPAddressFilterExtension (194)
/* tt:IPAddressFilterExtension */
class SOAP_CMAC tt__IPAddressFilterExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 194; } /* = unique id SOAP_TYPE_tt__IPAddressFilterExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IPAddressFilterExtension(): __any(NULL), soap(NULL) { tt__IPAddressFilterExtension::soap_default(NULL); }
	virtual ~tt__IPAddressFilterExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11Configuration
#define SOAP_TYPE_tt__Dot11Configuration (195)
/* tt:Dot11Configuration */
class SOAP_CMAC tt__Dot11Configuration
{
public:
	xsd__hexBinary SSID;	/* required element of type tt:Dot11SSIDType */
	enum tt__Dot11StationMode Mode;	/* required element of type tt:Dot11StationMode */
	char *Alias;	/* required element of type tt:Name */
	char *Priority;	/* required element of type tt:NetworkInterfaceConfigPriority */
	class tt__Dot11SecurityConfiguration *Security;	/* required element of type tt:Dot11SecurityConfiguration */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 195; } /* = unique id SOAP_TYPE_tt__Dot11Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11Configuration(): Alias(NULL), Priority(NULL), Security(NULL), __any(NULL), soap(NULL) { tt__Dot11Configuration::soap_default(NULL); }
	virtual ~tt__Dot11Configuration() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11SecurityConfiguration
#define SOAP_TYPE_tt__Dot11SecurityConfiguration (196)
/* tt:Dot11SecurityConfiguration */
class SOAP_CMAC tt__Dot11SecurityConfiguration
{
public:
	enum tt__Dot11SecurityMode Mode;	/* required element of type tt:Dot11SecurityMode */
	enum tt__Dot11Cipher *Algorithm;	/* optional element of type tt:Dot11Cipher */
	class tt__Dot11PSKSet *PSK;	/* optional element of type tt:Dot11PSKSet */
	char *Dot1X;	/* optional element of type tt:ReferenceToken */
	class tt__Dot11SecurityConfigurationExtension *Extension;	/* optional element of type tt:Dot11SecurityConfigurationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 196; } /* = unique id SOAP_TYPE_tt__Dot11SecurityConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11SecurityConfiguration(): Algorithm(NULL), PSK(NULL), Dot1X(NULL), Extension(NULL), soap(NULL) { tt__Dot11SecurityConfiguration::soap_default(NULL); }
	virtual ~tt__Dot11SecurityConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11SecurityConfigurationExtension
#define SOAP_TYPE_tt__Dot11SecurityConfigurationExtension (197)
/* tt:Dot11SecurityConfigurationExtension */
class SOAP_CMAC tt__Dot11SecurityConfigurationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 197; } /* = unique id SOAP_TYPE_tt__Dot11SecurityConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11SecurityConfigurationExtension(): __any(NULL), soap(NULL) { tt__Dot11SecurityConfigurationExtension::soap_default(NULL); }
	virtual ~tt__Dot11SecurityConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11PSKSet
#define SOAP_TYPE_tt__Dot11PSKSet (198)
/* tt:Dot11PSKSet */
class SOAP_CMAC tt__Dot11PSKSet
{
public:
	xsd__hexBinary *Key;	/* optional element of type tt:Dot11PSK */
	char *Passphrase;	/* optional element of type tt:Dot11PSKPassphrase */
	class tt__Dot11PSKSetExtension *Extension;	/* optional element of type tt:Dot11PSKSetExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 198; } /* = unique id SOAP_TYPE_tt__Dot11PSKSet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11PSKSet(): Key(NULL), Passphrase(NULL), Extension(NULL), soap(NULL) { tt__Dot11PSKSet::soap_default(NULL); }
	virtual ~tt__Dot11PSKSet() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11PSKSetExtension
#define SOAP_TYPE_tt__Dot11PSKSetExtension (199)
/* tt:Dot11PSKSetExtension */
class SOAP_CMAC tt__Dot11PSKSetExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 199; } /* = unique id SOAP_TYPE_tt__Dot11PSKSetExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11PSKSetExtension(): __any(NULL), soap(NULL) { tt__Dot11PSKSetExtension::soap_default(NULL); }
	virtual ~tt__Dot11PSKSetExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 (200)
/* tt:NetworkInterfaceSetConfigurationExtension2 */
class SOAP_CMAC tt__NetworkInterfaceSetConfigurationExtension2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 200; } /* = unique id SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterfaceSetConfigurationExtension2(): __any(NULL), soap(NULL) { tt__NetworkInterfaceSetConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__NetworkInterfaceSetConfigurationExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11Capabilities
#define SOAP_TYPE_tt__Dot11Capabilities (201)
/* tt:Dot11Capabilities */
class SOAP_CMAC tt__Dot11Capabilities
{
public:
	bool TKIP;	/* required element of type xsd:boolean */
	bool ScanAvailableNetworks;	/* required element of type xsd:boolean */
	bool MultipleConfiguration;	/* required element of type xsd:boolean */
	bool AdHocStationMode;	/* required element of type xsd:boolean */
	bool WEP;	/* required element of type xsd:boolean */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 201; } /* = unique id SOAP_TYPE_tt__Dot11Capabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11Capabilities(): __any(NULL), soap(NULL) { tt__Dot11Capabilities::soap_default(NULL); }
	virtual ~tt__Dot11Capabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11Status
#define SOAP_TYPE_tt__Dot11Status (202)
/* tt:Dot11Status */
class SOAP_CMAC tt__Dot11Status
{
public:
	xsd__hexBinary SSID;	/* required element of type tt:Dot11SSIDType */
	char *BSSID;	/* optional element of type xsd:string */
	enum tt__Dot11Cipher *PairCipher;	/* optional element of type tt:Dot11Cipher */
	enum tt__Dot11Cipher *GroupCipher;	/* optional element of type tt:Dot11Cipher */
	enum tt__Dot11SignalStrength *SignalStrength;	/* optional element of type tt:Dot11SignalStrength */
	char *ActiveConfigAlias;	/* required element of type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 202; } /* = unique id SOAP_TYPE_tt__Dot11Status */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11Status(): BSSID(NULL), PairCipher(NULL), GroupCipher(NULL), SignalStrength(NULL), ActiveConfigAlias(NULL), __any(NULL), soap(NULL) { tt__Dot11Status::soap_default(NULL); }
	virtual ~tt__Dot11Status() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11AvailableNetworks
#define SOAP_TYPE_tt__Dot11AvailableNetworks (203)
/* tt:Dot11AvailableNetworks */
class SOAP_CMAC tt__Dot11AvailableNetworks
{
public:
	xsd__hexBinary SSID;	/* required element of type tt:Dot11SSIDType */
	char *BSSID;	/* optional element of type xsd:string */
	int __sizeAuthAndMangementSuite;	/* sequence of elements <AuthAndMangementSuite> */
	enum tt__Dot11AuthAndMangementSuite *AuthAndMangementSuite;	/* optional element of type tt:Dot11AuthAndMangementSuite */
	int __sizePairCipher;	/* sequence of elements <PairCipher> */
	enum tt__Dot11Cipher *PairCipher;	/* optional element of type tt:Dot11Cipher */
	int __sizeGroupCipher;	/* sequence of elements <GroupCipher> */
	enum tt__Dot11Cipher *GroupCipher;	/* optional element of type tt:Dot11Cipher */
	enum tt__Dot11SignalStrength *SignalStrength;	/* optional element of type tt:Dot11SignalStrength */
	class tt__Dot11AvailableNetworksExtension *Extension;	/* optional element of type tt:Dot11AvailableNetworksExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 203; } /* = unique id SOAP_TYPE_tt__Dot11AvailableNetworks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11AvailableNetworks(): BSSID(NULL), AuthAndMangementSuite(NULL), PairCipher(NULL), GroupCipher(NULL), SignalStrength(NULL), Extension(NULL), soap(NULL) { tt__Dot11AvailableNetworks::soap_default(NULL); }
	virtual ~tt__Dot11AvailableNetworks() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot11AvailableNetworksExtension
#define SOAP_TYPE_tt__Dot11AvailableNetworksExtension (204)
/* tt:Dot11AvailableNetworksExtension */
class SOAP_CMAC tt__Dot11AvailableNetworksExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 204; } /* = unique id SOAP_TYPE_tt__Dot11AvailableNetworksExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot11AvailableNetworksExtension(): __any(NULL), soap(NULL) { tt__Dot11AvailableNetworksExtension::soap_default(NULL); }
	virtual ~tt__Dot11AvailableNetworksExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Capabilities
#define SOAP_TYPE_tt__Capabilities (205)
/* tt:Capabilities */
class SOAP_CMAC tt__Capabilities
{
public:
	class tt__AnalyticsCapabilities *Analytics;	/* optional element of type tt:AnalyticsCapabilities */
	class tt__DeviceCapabilities *Device;	/* optional element of type tt:DeviceCapabilities */
	class tt__EventCapabilities *Events;	/* optional element of type tt:EventCapabilities */
	class tt__ImagingCapabilities *Imaging;	/* optional element of type tt:ImagingCapabilities */
	class tt__MediaCapabilities *Media;	/* optional element of type tt:MediaCapabilities */
	class tt__PTZCapabilities *PTZ;	/* optional element of type tt:PTZCapabilities */
	class tt__CapabilitiesExtension *Extension;	/* optional element of type tt:CapabilitiesExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 205; } /* = unique id SOAP_TYPE_tt__Capabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Capabilities(): Analytics(NULL), Device(NULL), Events(NULL), Imaging(NULL), Media(NULL), PTZ(NULL), Extension(NULL), soap(NULL) { tt__Capabilities::soap_default(NULL); }
	virtual ~tt__Capabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__CapabilitiesExtension
#define SOAP_TYPE_tt__CapabilitiesExtension (206)
/* tt:CapabilitiesExtension */
class SOAP_CMAC tt__CapabilitiesExtension
{
public:
	class tt__DeviceIOCapabilities *DeviceIO;	/* optional element of type tt:DeviceIOCapabilities */
	class tt__DisplayCapabilities *Display;	/* optional element of type tt:DisplayCapabilities */
	class tt__RecordingCapabilities *Recording;	/* optional element of type tt:RecordingCapabilities */
	class tt__SearchCapabilities *Search;	/* optional element of type tt:SearchCapabilities */
	class tt__ReplayCapabilities *Replay;	/* optional element of type tt:ReplayCapabilities */
	class tt__ReceiverCapabilities *Receiver;	/* optional element of type tt:ReceiverCapabilities */
	class tt__AnalyticsDeviceCapabilities *AnalyticsDevice;	/* optional element of type tt:AnalyticsDeviceCapabilities */
	class tt__CapabilitiesExtension2 *Extensions;	/* optional element of type tt:CapabilitiesExtension2 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 206; } /* = unique id SOAP_TYPE_tt__CapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CapabilitiesExtension(): DeviceIO(NULL), Display(NULL), Recording(NULL), Search(NULL), Replay(NULL), Receiver(NULL), AnalyticsDevice(NULL), Extensions(NULL), __any(NULL), soap(NULL) { tt__CapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__CapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__CapabilitiesExtension2
#define SOAP_TYPE_tt__CapabilitiesExtension2 (207)
/* tt:CapabilitiesExtension2 */
class SOAP_CMAC tt__CapabilitiesExtension2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 207; } /* = unique id SOAP_TYPE_tt__CapabilitiesExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CapabilitiesExtension2(): __any(NULL), soap(NULL) { tt__CapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__CapabilitiesExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsCapabilities
#define SOAP_TYPE_tt__AnalyticsCapabilities (208)
/* tt:AnalyticsCapabilities */
class SOAP_CMAC tt__AnalyticsCapabilities
{
public:
	char *XAddr;	/* required element of type xsd:anyURI */
	bool RuleSupport;	/* required element of type xsd:boolean */
	bool AnalyticsModuleSupport;	/* required element of type xsd:boolean */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 208; } /* = unique id SOAP_TYPE_tt__AnalyticsCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsCapabilities(): XAddr(NULL), __any(NULL), soap(NULL) { tt__AnalyticsCapabilities::soap_default(NULL); }
	virtual ~tt__AnalyticsCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__DeviceCapabilities
#define SOAP_TYPE_tt__DeviceCapabilities (209)
/* tt:DeviceCapabilities */
class SOAP_CMAC tt__DeviceCapabilities
{
public:
	char *XAddr;	/* required element of type xsd:anyURI */
	class tt__NetworkCapabilities *Network;	/* optional element of type tt:NetworkCapabilities */
	class tt__SystemCapabilities *System;	/* optional element of type tt:SystemCapabilities */
	class tt__IOCapabilities *IO;	/* optional element of type tt:IOCapabilities */
	class tt__SecurityCapabilities *Security;	/* optional element of type tt:SecurityCapabilities */
	class tt__DeviceCapabilitiesExtension *Extension;	/* optional element of type tt:DeviceCapabilitiesExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 209; } /* = unique id SOAP_TYPE_tt__DeviceCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DeviceCapabilities(): XAddr(NULL), Network(NULL), System(NULL), IO(NULL), Security(NULL), Extension(NULL), soap(NULL) { tt__DeviceCapabilities::soap_default(NULL); }
	virtual ~tt__DeviceCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__DeviceCapabilitiesExtension
#define SOAP_TYPE_tt__DeviceCapabilitiesExtension (210)
/* tt:DeviceCapabilitiesExtension */
class SOAP_CMAC tt__DeviceCapabilitiesExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 210; } /* = unique id SOAP_TYPE_tt__DeviceCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DeviceCapabilitiesExtension(): __any(NULL), soap(NULL) { tt__DeviceCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__DeviceCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__EventCapabilities
#define SOAP_TYPE_tt__EventCapabilities (211)
/* tt:EventCapabilities */
class SOAP_CMAC tt__EventCapabilities
{
public:
	char *XAddr;	/* required element of type xsd:anyURI */
	bool WSSubscriptionPolicySupport;	/* required element of type xsd:boolean */
	bool WSPullPointSupport;	/* required element of type xsd:boolean */
	bool WSPausableSubscriptionManagerInterfaceSupport;	/* required element of type xsd:boolean */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 211; } /* = unique id SOAP_TYPE_tt__EventCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EventCapabilities(): XAddr(NULL), __any(NULL), soap(NULL) { tt__EventCapabilities::soap_default(NULL); }
	virtual ~tt__EventCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__IOCapabilities
#define SOAP_TYPE_tt__IOCapabilities (212)
/* tt:IOCapabilities */
class SOAP_CMAC tt__IOCapabilities
{
public:
	int *InputConnectors;	/* optional element of type xsd:int */
	int *RelayOutputs;	/* optional element of type xsd:int */
	class tt__IOCapabilitiesExtension *Extension;	/* optional element of type tt:IOCapabilitiesExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 212; } /* = unique id SOAP_TYPE_tt__IOCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IOCapabilities(): InputConnectors(NULL), RelayOutputs(NULL), Extension(NULL), soap(NULL) { tt__IOCapabilities::soap_default(NULL); }
	virtual ~tt__IOCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension
#define SOAP_TYPE_tt__IOCapabilitiesExtension (213)
/* tt:IOCapabilitiesExtension */
class SOAP_CMAC tt__IOCapabilitiesExtension
{
public:
	bool *Auxiliary;	/* optional element of type xsd:boolean */
	int __sizeAuxiliaryCommands;	/* sequence of elements <AuxiliaryCommands> */
	char **AuxiliaryCommands;	/* optional element of type tt:AuxiliaryData */
	class tt__IOCapabilitiesExtension2 *Extension;	/* required element of type tt:IOCapabilitiesExtension2 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 213; } /* = unique id SOAP_TYPE_tt__IOCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IOCapabilitiesExtension(): Auxiliary(NULL), AuxiliaryCommands(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__IOCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__IOCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension2
#define SOAP_TYPE_tt__IOCapabilitiesExtension2 (214)
/* tt:IOCapabilitiesExtension2 */
class SOAP_CMAC tt__IOCapabilitiesExtension2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 214; } /* = unique id SOAP_TYPE_tt__IOCapabilitiesExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__IOCapabilitiesExtension2(): __any(NULL), soap(NULL) { tt__IOCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__IOCapabilitiesExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__MediaCapabilities
#define SOAP_TYPE_tt__MediaCapabilities (215)
/* tt:MediaCapabilities */
class SOAP_CMAC tt__MediaCapabilities
{
public:
	char *XAddr;	/* required element of type xsd:anyURI */
	class tt__RealTimeStreamingCapabilities *StreamingCapabilities;	/* required element of type tt:RealTimeStreamingCapabilities */
	class tt__MediaCapabilitiesExtension *Extension;	/* optional element of type tt:MediaCapabilitiesExtension */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 215; } /* = unique id SOAP_TYPE_tt__MediaCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MediaCapabilities(): XAddr(NULL), StreamingCapabilities(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__MediaCapabilities::soap_default(NULL); }
	virtual ~tt__MediaCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__MediaCapabilitiesExtension
#define SOAP_TYPE_tt__MediaCapabilitiesExtension (216)
/* tt:MediaCapabilitiesExtension */
class SOAP_CMAC tt__MediaCapabilitiesExtension
{
public:
	class tt__ProfileCapabilities *ProfileCapabilities;	/* required element of type tt:ProfileCapabilities */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 216; } /* = unique id SOAP_TYPE_tt__MediaCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MediaCapabilitiesExtension(): ProfileCapabilities(NULL), __any(NULL), soap(NULL) { tt__MediaCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__MediaCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilities
#define SOAP_TYPE_tt__RealTimeStreamingCapabilities (217)
/* tt:RealTimeStreamingCapabilities */
class SOAP_CMAC tt__RealTimeStreamingCapabilities
{
public:
	bool *RTPMulticast;	/* optional element of type xsd:boolean */
	bool *RTP_USCORETCP;	/* optional element of type xsd:boolean */
	bool *RTP_USCORERTSP_USCORETCP;	/* optional element of type xsd:boolean */
	class tt__RealTimeStreamingCapabilitiesExtension *Extension;	/* optional element of type tt:RealTimeStreamingCapabilitiesExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 217; } /* = unique id SOAP_TYPE_tt__RealTimeStreamingCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RealTimeStreamingCapabilities(): RTPMulticast(NULL), RTP_USCORETCP(NULL), RTP_USCORERTSP_USCORETCP(NULL), Extension(NULL), soap(NULL) { tt__RealTimeStreamingCapabilities::soap_default(NULL); }
	virtual ~tt__RealTimeStreamingCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension
#define SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension (218)
/* tt:RealTimeStreamingCapabilitiesExtension */
class SOAP_CMAC tt__RealTimeStreamingCapabilitiesExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 218; } /* = unique id SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RealTimeStreamingCapabilitiesExtension(): __any(NULL), soap(NULL) { tt__RealTimeStreamingCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__RealTimeStreamingCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ProfileCapabilities
#define SOAP_TYPE_tt__ProfileCapabilities (219)
/* tt:ProfileCapabilities */
class SOAP_CMAC tt__ProfileCapabilities
{
public:
	int MaximumNumberOfProfiles;	/* required element of type xsd:int */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 219; } /* = unique id SOAP_TYPE_tt__ProfileCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ProfileCapabilities(): __any(NULL), soap(NULL) { tt__ProfileCapabilities::soap_default(NULL); }
	virtual ~tt__ProfileCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkCapabilities
#define SOAP_TYPE_tt__NetworkCapabilities (220)
/* tt:NetworkCapabilities */
class SOAP_CMAC tt__NetworkCapabilities
{
public:
	bool *IPFilter;	/* optional element of type xsd:boolean */
	bool *ZeroConfiguration;	/* optional element of type xsd:boolean */
	bool *IPVersion6;	/* optional element of type xsd:boolean */
	bool *DynDNS;	/* optional element of type xsd:boolean */
	class tt__NetworkCapabilitiesExtension *Extension;	/* optional element of type tt:NetworkCapabilitiesExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 220; } /* = unique id SOAP_TYPE_tt__NetworkCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkCapabilities(): IPFilter(NULL), ZeroConfiguration(NULL), IPVersion6(NULL), DynDNS(NULL), Extension(NULL), soap(NULL) { tt__NetworkCapabilities::soap_default(NULL); }
	virtual ~tt__NetworkCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension (221)
/* tt:NetworkCapabilitiesExtension */
class SOAP_CMAC tt__NetworkCapabilitiesExtension
{
public:
	bool *Dot11Configuration;	/* optional element of type xsd:boolean */
	class tt__NetworkCapabilitiesExtension2 *Extension;	/* optional element of type tt:NetworkCapabilitiesExtension2 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 221; } /* = unique id SOAP_TYPE_tt__NetworkCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkCapabilitiesExtension(): Dot11Configuration(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__NetworkCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__NetworkCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension2
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension2 (222)
/* tt:NetworkCapabilitiesExtension2 */
class SOAP_CMAC tt__NetworkCapabilitiesExtension2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 222; } /* = unique id SOAP_TYPE_tt__NetworkCapabilitiesExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkCapabilitiesExtension2(): __any(NULL), soap(NULL) { tt__NetworkCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__NetworkCapabilitiesExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__SecurityCapabilities
#define SOAP_TYPE_tt__SecurityCapabilities (223)
/* tt:SecurityCapabilities */
class SOAP_CMAC tt__SecurityCapabilities
{
public:
	bool TLS1_x002e1;	/* required element of type xsd:boolean */
	bool TLS1_x002e2;	/* required element of type xsd:boolean */
	bool OnboardKeyGeneration;	/* required element of type xsd:boolean */
	bool AccessPolicyConfig;	/* required element of type xsd:boolean */
	bool X_x002e509Token;	/* required element of type xsd:boolean */
	bool SAMLToken;	/* required element of type xsd:boolean */
	bool KerberosToken;	/* required element of type xsd:boolean */
	bool RELToken;	/* required element of type xsd:boolean */
	class tt__SecurityCapabilitiesExtension *Extension;	/* optional element of type tt:SecurityCapabilitiesExtension */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 223; } /* = unique id SOAP_TYPE_tt__SecurityCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SecurityCapabilities(): Extension(NULL), __any(NULL), soap(NULL) { tt__SecurityCapabilities::soap_default(NULL); }
	virtual ~tt__SecurityCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension (224)
/* tt:SecurityCapabilitiesExtension */
class SOAP_CMAC tt__SecurityCapabilitiesExtension
{
public:
	bool TLS1_x002e0;	/* required element of type xsd:boolean */
	class tt__SecurityCapabilitiesExtension2 *Extension;	/* optional element of type tt:SecurityCapabilitiesExtension2 */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 224; } /* = unique id SOAP_TYPE_tt__SecurityCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SecurityCapabilitiesExtension(): Extension(NULL), soap(NULL) { tt__SecurityCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__SecurityCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension2
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension2 (225)
/* tt:SecurityCapabilitiesExtension2 */
class SOAP_CMAC tt__SecurityCapabilitiesExtension2
{
public:
	bool Dot1X;	/* required element of type xsd:boolean */
	int __sizeSupportedEAPMethod;	/* sequence of elements <SupportedEAPMethod> */
	int *SupportedEAPMethod;	/* optional element of type xsd:int */
	bool RemoteUserHandling;	/* required element of type xsd:boolean */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 225; } /* = unique id SOAP_TYPE_tt__SecurityCapabilitiesExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SecurityCapabilitiesExtension2(): SupportedEAPMethod(NULL), __any(NULL), soap(NULL) { tt__SecurityCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__SecurityCapabilitiesExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemCapabilities
#define SOAP_TYPE_tt__SystemCapabilities (226)
/* tt:SystemCapabilities */
class SOAP_CMAC tt__SystemCapabilities
{
public:
	bool DiscoveryResolve;	/* required element of type xsd:boolean */
	bool DiscoveryBye;	/* required element of type xsd:boolean */
	bool RemoteDiscovery;	/* required element of type xsd:boolean */
	bool SystemBackup;	/* required element of type xsd:boolean */
	bool SystemLogging;	/* required element of type xsd:boolean */
	bool FirmwareUpgrade;	/* required element of type xsd:boolean */
	int __sizeSupportedVersions;	/* sequence of elements <SupportedVersions> */
	class tt__OnvifVersion **SupportedVersions;	/* required element of type tt:OnvifVersion */
	class tt__SystemCapabilitiesExtension *Extension;	/* optional element of type tt:SystemCapabilitiesExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 226; } /* = unique id SOAP_TYPE_tt__SystemCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemCapabilities(): SupportedVersions(NULL), Extension(NULL), soap(NULL) { tt__SystemCapabilities::soap_default(NULL); }
	virtual ~tt__SystemCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension
#define SOAP_TYPE_tt__SystemCapabilitiesExtension (227)
/* tt:SystemCapabilitiesExtension */
class SOAP_CMAC tt__SystemCapabilitiesExtension
{
public:
	bool *HttpFirmwareUpgrade;	/* optional element of type xsd:boolean */
	bool *HttpSystemBackup;	/* optional element of type xsd:boolean */
	bool *HttpSystemLogging;	/* optional element of type xsd:boolean */
	bool *HttpSupportInformation;	/* optional element of type xsd:boolean */
	class tt__SystemCapabilitiesExtension2 *Extension;	/* optional element of type tt:SystemCapabilitiesExtension2 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 227; } /* = unique id SOAP_TYPE_tt__SystemCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemCapabilitiesExtension(): HttpFirmwareUpgrade(NULL), HttpSystemBackup(NULL), HttpSystemLogging(NULL), HttpSupportInformation(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__SystemCapabilitiesExtension::soap_default(NULL); }
	virtual ~tt__SystemCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension2
#define SOAP_TYPE_tt__SystemCapabilitiesExtension2 (228)
/* tt:SystemCapabilitiesExtension2 */
class SOAP_CMAC tt__SystemCapabilitiesExtension2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 228; } /* = unique id SOAP_TYPE_tt__SystemCapabilitiesExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemCapabilitiesExtension2(): __any(NULL), soap(NULL) { tt__SystemCapabilitiesExtension2::soap_default(NULL); }
	virtual ~tt__SystemCapabilitiesExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__OnvifVersion
#define SOAP_TYPE_tt__OnvifVersion (229)
/* tt:OnvifVersion */
class SOAP_CMAC tt__OnvifVersion
{
public:
	int Major;	/* required element of type xsd:int */
	int Minor;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 229; } /* = unique id SOAP_TYPE_tt__OnvifVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OnvifVersion(): soap(NULL) { tt__OnvifVersion::soap_default(NULL); }
	virtual ~tt__OnvifVersion() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingCapabilities
#define SOAP_TYPE_tt__ImagingCapabilities (230)
/* tt:ImagingCapabilities */
class SOAP_CMAC tt__ImagingCapabilities
{
public:
	char *XAddr;	/* required element of type xsd:anyURI */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 230; } /* = unique id SOAP_TYPE_tt__ImagingCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingCapabilities(): XAddr(NULL), soap(NULL) { tt__ImagingCapabilities::soap_default(NULL); }
	virtual ~tt__ImagingCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZCapabilities
#define SOAP_TYPE_tt__PTZCapabilities (231)
/* tt:PTZCapabilities */
class SOAP_CMAC tt__PTZCapabilities
{
public:
	char *XAddr;	/* required element of type xsd:anyURI */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 231; } /* = unique id SOAP_TYPE_tt__PTZCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZCapabilities(): XAddr(NULL), __any(NULL), soap(NULL) { tt__PTZCapabilities::soap_default(NULL); }
	virtual ~tt__PTZCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__DeviceIOCapabilities
#define SOAP_TYPE_tt__DeviceIOCapabilities (232)
/* tt:DeviceIOCapabilities */
class SOAP_CMAC tt__DeviceIOCapabilities
{
public:
	char *XAddr;	/* required element of type xsd:anyURI */
	int VideoSources;	/* required element of type xsd:int */
	int VideoOutputs;	/* required element of type xsd:int */
	int AudioSources;	/* required element of type xsd:int */
	int AudioOutputs;	/* required element of type xsd:int */
	int RelayOutputs;	/* required element of type xsd:int */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 232; } /* = unique id SOAP_TYPE_tt__DeviceIOCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DeviceIOCapabilities(): XAddr(NULL), __any(NULL), soap(NULL) { tt__DeviceIOCapabilities::soap_default(NULL); }
	virtual ~tt__DeviceIOCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__DisplayCapabilities
#define SOAP_TYPE_tt__DisplayCapabilities (233)
/* tt:DisplayCapabilities */
class SOAP_CMAC tt__DisplayCapabilities
{
public:
	char *XAddr;	/* required element of type xsd:anyURI */
	bool FixedLayout;	/* required element of type xsd:boolean */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 233; } /* = unique id SOAP_TYPE_tt__DisplayCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DisplayCapabilities(): XAddr(NULL), __any(NULL), soap(NULL) { tt__DisplayCapabilities::soap_default(NULL); }
	virtual ~tt__DisplayCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingCapabilities
#define SOAP_TYPE_tt__RecordingCapabilities (234)
/* tt:RecordingCapabilities */
class SOAP_CMAC tt__RecordingCapabilities
{
public:
	char *XAddr;	/* required element of type xsd:anyURI */
	bool ReceiverSource;	/* required element of type xsd:boolean */
	bool MediaProfileSource;	/* required element of type xsd:boolean */
	bool DynamicRecordings;	/* required element of type xsd:boolean */
	bool DynamicTracks;	/* required element of type xsd:boolean */
	int MaxStringLength;	/* required element of type xsd:int */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 234; } /* = unique id SOAP_TYPE_tt__RecordingCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingCapabilities(): XAddr(NULL), __any(NULL), soap(NULL) { tt__RecordingCapabilities::soap_default(NULL); }
	virtual ~tt__RecordingCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__SearchCapabilities
#define SOAP_TYPE_tt__SearchCapabilities (235)
/* tt:SearchCapabilities */
class SOAP_CMAC tt__SearchCapabilities
{
public:
	char *XAddr;	/* required element of type xsd:anyURI */
	bool MetadataSearch;	/* required element of type xsd:boolean */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 235; } /* = unique id SOAP_TYPE_tt__SearchCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SearchCapabilities(): XAddr(NULL), __any(NULL), soap(NULL) { tt__SearchCapabilities::soap_default(NULL); }
	virtual ~tt__SearchCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReplayCapabilities
#define SOAP_TYPE_tt__ReplayCapabilities (236)
/* tt:ReplayCapabilities */
class SOAP_CMAC tt__ReplayCapabilities
{
public:
	char *XAddr;	/* required element of type xsd:anyURI */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 236; } /* = unique id SOAP_TYPE_tt__ReplayCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReplayCapabilities(): XAddr(NULL), __any(NULL), soap(NULL) { tt__ReplayCapabilities::soap_default(NULL); }
	virtual ~tt__ReplayCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReceiverCapabilities
#define SOAP_TYPE_tt__ReceiverCapabilities (237)
/* tt:ReceiverCapabilities */
class SOAP_CMAC tt__ReceiverCapabilities
{
public:
	char *XAddr;	/* required element of type xsd:anyURI */
	bool RTP_USCOREMulticast;	/* required element of type xsd:boolean */
	bool RTP_USCORETCP;	/* required element of type xsd:boolean */
	bool RTP_USCORERTSP_USCORETCP;	/* required element of type xsd:boolean */
	int SupportedReceivers;	/* required element of type xsd:int */
	int MaximumRTSPURILength;	/* required element of type xsd:int */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 237; } /* = unique id SOAP_TYPE_tt__ReceiverCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReceiverCapabilities(): XAddr(NULL), __any(NULL), soap(NULL) { tt__ReceiverCapabilities::soap_default(NULL); }
	virtual ~tt__ReceiverCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsDeviceCapabilities
#define SOAP_TYPE_tt__AnalyticsDeviceCapabilities (238)
/* tt:AnalyticsDeviceCapabilities */
class SOAP_CMAC tt__AnalyticsDeviceCapabilities
{
public:
	char *XAddr;	/* required element of type xsd:anyURI */
	bool *RuleSupport;	/* optional element of type xsd:boolean */
	class tt__AnalyticsDeviceExtension *Extension;	/* optional element of type tt:AnalyticsDeviceExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 238; } /* = unique id SOAP_TYPE_tt__AnalyticsDeviceCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsDeviceCapabilities(): XAddr(NULL), RuleSupport(NULL), Extension(NULL), soap(NULL) { tt__AnalyticsDeviceCapabilities::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsDeviceExtension
#define SOAP_TYPE_tt__AnalyticsDeviceExtension (239)
/* tt:AnalyticsDeviceExtension */
class SOAP_CMAC tt__AnalyticsDeviceExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 239; } /* = unique id SOAP_TYPE_tt__AnalyticsDeviceExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsDeviceExtension(): __any(NULL), soap(NULL) { tt__AnalyticsDeviceExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemLog
#define SOAP_TYPE_tt__SystemLog (240)
/* tt:SystemLog */
class SOAP_CMAC tt__SystemLog
{
public:
	class tt__AttachmentData *Binary;	/* optional element of type tt:AttachmentData */
	char *String;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 240; } /* = unique id SOAP_TYPE_tt__SystemLog */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemLog(): Binary(NULL), String(NULL), soap(NULL) { tt__SystemLog::soap_default(NULL); }
	virtual ~tt__SystemLog() { }
};
#endif

#ifndef SOAP_TYPE_tt__SupportInformation
#define SOAP_TYPE_tt__SupportInformation (241)
/* tt:SupportInformation */
class SOAP_CMAC tt__SupportInformation
{
public:
	tt__AttachmentData *Binary;	/* optional element of type tt:AttachmentData */
	char *String;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 241; } /* = unique id SOAP_TYPE_tt__SupportInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SupportInformation(): Binary(NULL), String(NULL), soap(NULL) { tt__SupportInformation::soap_default(NULL); }
	virtual ~tt__SupportInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__BinaryData
#define SOAP_TYPE_tt__BinaryData (242)
/* tt:BinaryData */
class SOAP_CMAC tt__BinaryData
{
public:
	xsd__base64Binary Data;	/* required element of type xsd:base64Binary */
	char *xmime5__contentType;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 242; } /* = unique id SOAP_TYPE_tt__BinaryData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BinaryData(): xmime5__contentType(NULL), soap(NULL) { tt__BinaryData::soap_default(NULL); }
	virtual ~tt__BinaryData() { }
};
#endif

#ifndef SOAP_TYPE_tt__AttachmentData
#define SOAP_TYPE_tt__AttachmentData (243)
/* tt:AttachmentData */
class SOAP_CMAC tt__AttachmentData
{
public:
	struct _xop__Include xop__Include;	/* required element of type xop:Include */
	char *xmime5__contentType;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 243; } /* = unique id SOAP_TYPE_tt__AttachmentData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AttachmentData(): xmime5__contentType(NULL), soap(NULL) { tt__AttachmentData::soap_default(NULL); }
	virtual ~tt__AttachmentData() { }
};
#endif

#ifndef SOAP_TYPE_tt__BackupFile
#define SOAP_TYPE_tt__BackupFile (244)
/* tt:BackupFile */
class SOAP_CMAC tt__BackupFile
{
public:
	char *Name;	/* required element of type xsd:string */
	tt__AttachmentData *Data;	/* required element of type tt:AttachmentData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 244; } /* = unique id SOAP_TYPE_tt__BackupFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BackupFile(): Name(NULL), Data(NULL), soap(NULL) { tt__BackupFile::soap_default(NULL); }
	virtual ~tt__BackupFile() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemLogUriList
#define SOAP_TYPE_tt__SystemLogUriList (245)
/* tt:SystemLogUriList */
class SOAP_CMAC tt__SystemLogUriList
{
public:
	int __sizeSystemLog;	/* sequence of elements <SystemLog> */
	class tt__SystemLogUri **SystemLog;	/* optional element of type tt:SystemLogUri */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 245; } /* = unique id SOAP_TYPE_tt__SystemLogUriList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemLogUriList(): SystemLog(NULL), soap(NULL) { tt__SystemLogUriList::soap_default(NULL); }
	virtual ~tt__SystemLogUriList() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemLogUri
#define SOAP_TYPE_tt__SystemLogUri (246)
/* tt:SystemLogUri */
class SOAP_CMAC tt__SystemLogUri
{
public:
	enum tt__SystemLogType Type;	/* required element of type tt:SystemLogType */
	char *Uri;	/* required element of type xsd:anyURI */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 246; } /* = unique id SOAP_TYPE_tt__SystemLogUri */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemLogUri(): Uri(NULL), __any(NULL), soap(NULL) { tt__SystemLogUri::soap_default(NULL); }
	virtual ~tt__SystemLogUri() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemDateTime
#define SOAP_TYPE_tt__SystemDateTime (247)
/* tt:SystemDateTime */
class SOAP_CMAC tt__SystemDateTime
{
public:
	enum tt__SetDateTimeType DateTimeType;	/* required element of type tt:SetDateTimeType */
	bool DaylightSavings;	/* required element of type xsd:boolean */
	class tt__TimeZone *TimeZone;	/* optional element of type tt:TimeZone */
	class tt__DateTime *UTCDateTime;	/* optional element of type tt:DateTime */
	tt__DateTime *LocalDateTime;	/* optional element of type tt:DateTime */
	class tt__SystemDateTimeExtension *Extension;	/* optional element of type tt:SystemDateTimeExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 247; } /* = unique id SOAP_TYPE_tt__SystemDateTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemDateTime(): TimeZone(NULL), UTCDateTime(NULL), LocalDateTime(NULL), Extension(NULL), soap(NULL) { tt__SystemDateTime::soap_default(NULL); }
	virtual ~tt__SystemDateTime() { }
};
#endif

#ifndef SOAP_TYPE_tt__SystemDateTimeExtension
#define SOAP_TYPE_tt__SystemDateTimeExtension (248)
/* tt:SystemDateTimeExtension */
class SOAP_CMAC tt__SystemDateTimeExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 248; } /* = unique id SOAP_TYPE_tt__SystemDateTimeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SystemDateTimeExtension(): __any(NULL), soap(NULL) { tt__SystemDateTimeExtension::soap_default(NULL); }
	virtual ~tt__SystemDateTimeExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__DateTime
#define SOAP_TYPE_tt__DateTime (249)
/* tt:DateTime */
class SOAP_CMAC tt__DateTime
{
public:
	class tt__Time *Time;	/* required element of type tt:Time */
	class tt__Date *Date;	/* required element of type tt:Date */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 249; } /* = unique id SOAP_TYPE_tt__DateTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DateTime(): Time(NULL), Date(NULL), soap(NULL) { tt__DateTime::soap_default(NULL); }
	virtual ~tt__DateTime() { }
};
#endif

#ifndef SOAP_TYPE_tt__Date
#define SOAP_TYPE_tt__Date (250)
/* tt:Date */
class SOAP_CMAC tt__Date
{
public:
	int Year;	/* required element of type xsd:int */
	int Month;	/* required element of type xsd:int */
	int Day;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 250; } /* = unique id SOAP_TYPE_tt__Date */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Date(): soap(NULL) { tt__Date::soap_default(NULL); }
	virtual ~tt__Date() { }
};
#endif

#ifndef SOAP_TYPE_tt__Time
#define SOAP_TYPE_tt__Time (251)
/* tt:Time */
class SOAP_CMAC tt__Time
{
public:
	int Hour;	/* required element of type xsd:int */
	int Minute;	/* required element of type xsd:int */
	int Second;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 251; } /* = unique id SOAP_TYPE_tt__Time */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Time(): soap(NULL) { tt__Time::soap_default(NULL); }
	virtual ~tt__Time() { }
};
#endif

#ifndef SOAP_TYPE_tt__TimeZone
#define SOAP_TYPE_tt__TimeZone (252)
/* tt:TimeZone */
class SOAP_CMAC tt__TimeZone
{
public:
	char *TZ;	/* required element of type xsd:token */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 252; } /* = unique id SOAP_TYPE_tt__TimeZone */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TimeZone(): TZ(NULL), soap(NULL) { tt__TimeZone::soap_default(NULL); }
	virtual ~tt__TimeZone() { }
};
#endif

#ifndef SOAP_TYPE_tt__RemoteUser
#define SOAP_TYPE_tt__RemoteUser (253)
/* tt:RemoteUser */
class SOAP_CMAC tt__RemoteUser
{
public:
	char *Username;	/* required element of type xsd:string */
	char *Password;	/* optional element of type xsd:string */
	bool UseDerivedPassword;	/* required element of type xsd:boolean */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 253; } /* = unique id SOAP_TYPE_tt__RemoteUser */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RemoteUser(): Username(NULL), Password(NULL), __any(NULL), soap(NULL) { tt__RemoteUser::soap_default(NULL); }
	virtual ~tt__RemoteUser() { }
};
#endif

#ifndef SOAP_TYPE_tt__User
#define SOAP_TYPE_tt__User (254)
/* tt:User */
class SOAP_CMAC tt__User
{
public:
	char *Username;	/* required element of type xsd:string */
	char *Password;	/* optional element of type xsd:string */
	enum tt__UserLevel UserLevel;	/* required element of type tt:UserLevel */
	class tt__UserExtension *Extension;	/* optional element of type tt:UserExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 254; } /* = unique id SOAP_TYPE_tt__User */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__User(): Username(NULL), Password(NULL), Extension(NULL), soap(NULL) { tt__User::soap_default(NULL); }
	virtual ~tt__User() { }
};
#endif

#ifndef SOAP_TYPE_tt__UserExtension
#define SOAP_TYPE_tt__UserExtension (255)
/* tt:UserExtension */
class SOAP_CMAC tt__UserExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 255; } /* = unique id SOAP_TYPE_tt__UserExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__UserExtension(): __any(NULL), soap(NULL) { tt__UserExtension::soap_default(NULL); }
	virtual ~tt__UserExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__CertificateGenerationParameters
#define SOAP_TYPE_tt__CertificateGenerationParameters (256)
/* tt:CertificateGenerationParameters */
class SOAP_CMAC tt__CertificateGenerationParameters
{
public:
	char *CertificateID;	/* optional element of type xsd:token */
	char *Subject;	/* optional element of type xsd:string */
	char *ValidNotBefore;	/* optional element of type xsd:token */
	char *ValidNotAfter;	/* optional element of type xsd:token */
	class tt__CertificateGenerationParametersExtension *Extension;	/* optional element of type tt:CertificateGenerationParametersExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 256; } /* = unique id SOAP_TYPE_tt__CertificateGenerationParameters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CertificateGenerationParameters(): CertificateID(NULL), Subject(NULL), ValidNotBefore(NULL), ValidNotAfter(NULL), Extension(NULL), soap(NULL) { tt__CertificateGenerationParameters::soap_default(NULL); }
	virtual ~tt__CertificateGenerationParameters() { }
};
#endif

#ifndef SOAP_TYPE_tt__CertificateGenerationParametersExtension
#define SOAP_TYPE_tt__CertificateGenerationParametersExtension (257)
/* tt:CertificateGenerationParametersExtension */
class SOAP_CMAC tt__CertificateGenerationParametersExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 257; } /* = unique id SOAP_TYPE_tt__CertificateGenerationParametersExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CertificateGenerationParametersExtension(): __any(NULL), soap(NULL) { tt__CertificateGenerationParametersExtension::soap_default(NULL); }
	virtual ~tt__CertificateGenerationParametersExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Certificate
#define SOAP_TYPE_tt__Certificate (258)
/* tt:Certificate */
class SOAP_CMAC tt__Certificate
{
public:
	char *CertificateID;	/* required element of type xsd:token */
	tt__BinaryData *Certificate;	/* required element of type tt:BinaryData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 258; } /* = unique id SOAP_TYPE_tt__Certificate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Certificate(): CertificateID(NULL), Certificate(NULL), soap(NULL) { tt__Certificate::soap_default(NULL); }
	virtual ~tt__Certificate() { }
};
#endif

#ifndef SOAP_TYPE_tt__CertificateStatus
#define SOAP_TYPE_tt__CertificateStatus (259)
/* tt:CertificateStatus */
class SOAP_CMAC tt__CertificateStatus
{
public:
	char *CertificateID;	/* required element of type xsd:token */
	bool Status;	/* required element of type xsd:boolean */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 259; } /* = unique id SOAP_TYPE_tt__CertificateStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CertificateStatus(): CertificateID(NULL), __any(NULL), soap(NULL) { tt__CertificateStatus::soap_default(NULL); }
	virtual ~tt__CertificateStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__CertificateWithPrivateKey
#define SOAP_TYPE_tt__CertificateWithPrivateKey (260)
/* tt:CertificateWithPrivateKey */
class SOAP_CMAC tt__CertificateWithPrivateKey
{
public:
	char *CertificateID;	/* optional element of type xsd:token */
	tt__BinaryData *Certificate;	/* required element of type tt:BinaryData */
	tt__BinaryData *PrivateKey;	/* required element of type tt:BinaryData */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 260; } /* = unique id SOAP_TYPE_tt__CertificateWithPrivateKey */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CertificateWithPrivateKey(): CertificateID(NULL), Certificate(NULL), PrivateKey(NULL), __any(NULL), soap(NULL) { tt__CertificateWithPrivateKey::soap_default(NULL); }
	virtual ~tt__CertificateWithPrivateKey() { }
};
#endif

#ifndef SOAP_TYPE_tt__CertificateInformation
#define SOAP_TYPE_tt__CertificateInformation (261)
/* tt:CertificateInformation */
class SOAP_CMAC tt__CertificateInformation
{
public:
	char *CertificateID;	/* required element of type xsd:token */
	char *IssuerDN;	/* optional element of type xsd:string */
	char *SubjectDN;	/* optional element of type xsd:string */
	class tt__CertificateUsage *KeyUsage;	/* optional element of type tt:CertificateUsage */
	tt__CertificateUsage *ExtendedKeyUsage;	/* optional element of type tt:CertificateUsage */
	int *KeyLength;	/* optional element of type xsd:int */
	char *Version;	/* optional element of type xsd:string */
	char *SerialNum;	/* optional element of type xsd:string */
	char *SignatureAlgorithm;	/* optional element of type xsd:string */
	class tt__DateTimeRange *Validity;	/* optional element of type tt:DateTimeRange */
	class tt__CertificateInformationExtension *Extension;	/* optional element of type tt:CertificateInformationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 261; } /* = unique id SOAP_TYPE_tt__CertificateInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CertificateInformation(): CertificateID(NULL), IssuerDN(NULL), SubjectDN(NULL), KeyUsage(NULL), ExtendedKeyUsage(NULL), KeyLength(NULL), Version(NULL), SerialNum(NULL), SignatureAlgorithm(NULL), Validity(NULL), Extension(NULL), soap(NULL) { tt__CertificateInformation::soap_default(NULL); }
	virtual ~tt__CertificateInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__CertificateInformationExtension
#define SOAP_TYPE_tt__CertificateInformationExtension (263)
/* tt:CertificateInformationExtension */
class SOAP_CMAC tt__CertificateInformationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 263; } /* = unique id SOAP_TYPE_tt__CertificateInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CertificateInformationExtension(): __any(NULL), soap(NULL) { tt__CertificateInformationExtension::soap_default(NULL); }
	virtual ~tt__CertificateInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot1XConfiguration
#define SOAP_TYPE_tt__Dot1XConfiguration (264)
/* tt:Dot1XConfiguration */
class SOAP_CMAC tt__Dot1XConfiguration
{
public:
	char *Dot1XConfigurationToken;	/* required element of type tt:ReferenceToken */
	char *Identity;	/* required element of type xsd:string */
	char *AnonymousID;	/* optional element of type xsd:string */
	int EAPMethod;	/* required element of type xsd:int */
	int __sizeCACertificateID;	/* sequence of elements <CACertificateID> */
	char **CACertificateID;	/* optional element of type xsd:token */
	class tt__EAPMethodConfiguration *EAPMethodConfiguration;	/* optional element of type tt:EAPMethodConfiguration */
	class tt__Dot1XConfigurationExtension *Extension;	/* optional element of type tt:Dot1XConfigurationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 264; } /* = unique id SOAP_TYPE_tt__Dot1XConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot1XConfiguration(): Dot1XConfigurationToken(NULL), Identity(NULL), AnonymousID(NULL), CACertificateID(NULL), EAPMethodConfiguration(NULL), Extension(NULL), soap(NULL) { tt__Dot1XConfiguration::soap_default(NULL); }
	virtual ~tt__Dot1XConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__Dot1XConfigurationExtension
#define SOAP_TYPE_tt__Dot1XConfigurationExtension (265)
/* tt:Dot1XConfigurationExtension */
class SOAP_CMAC tt__Dot1XConfigurationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 265; } /* = unique id SOAP_TYPE_tt__Dot1XConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Dot1XConfigurationExtension(): __any(NULL), soap(NULL) { tt__Dot1XConfigurationExtension::soap_default(NULL); }
	virtual ~tt__Dot1XConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__EAPMethodConfiguration
#define SOAP_TYPE_tt__EAPMethodConfiguration (266)
/* tt:EAPMethodConfiguration */
class SOAP_CMAC tt__EAPMethodConfiguration
{
public:
	class tt__TLSConfiguration *TLSConfiguration;	/* optional element of type tt:TLSConfiguration */
	char *Password;	/* optional element of type xsd:string */
	class tt__EapMethodExtension *Extension;	/* optional element of type tt:EapMethodExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 266; } /* = unique id SOAP_TYPE_tt__EAPMethodConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EAPMethodConfiguration(): TLSConfiguration(NULL), Password(NULL), Extension(NULL), soap(NULL) { tt__EAPMethodConfiguration::soap_default(NULL); }
	virtual ~tt__EAPMethodConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__EapMethodExtension
#define SOAP_TYPE_tt__EapMethodExtension (267)
/* tt:EapMethodExtension */
class SOAP_CMAC tt__EapMethodExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 267; } /* = unique id SOAP_TYPE_tt__EapMethodExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EapMethodExtension(): __any(NULL), soap(NULL) { tt__EapMethodExtension::soap_default(NULL); }
	virtual ~tt__EapMethodExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__TLSConfiguration
#define SOAP_TYPE_tt__TLSConfiguration (268)
/* tt:TLSConfiguration */
class SOAP_CMAC tt__TLSConfiguration
{
public:
	char *CertificateID;	/* required element of type xsd:token */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 268; } /* = unique id SOAP_TYPE_tt__TLSConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TLSConfiguration(): CertificateID(NULL), __any(NULL), soap(NULL) { tt__TLSConfiguration::soap_default(NULL); }
	virtual ~tt__TLSConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__GenericEapPwdConfigurationExtension
#define SOAP_TYPE_tt__GenericEapPwdConfigurationExtension (269)
/* tt:GenericEapPwdConfigurationExtension */
class SOAP_CMAC tt__GenericEapPwdConfigurationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 269; } /* = unique id SOAP_TYPE_tt__GenericEapPwdConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__GenericEapPwdConfigurationExtension(): __any(NULL), soap(NULL) { tt__GenericEapPwdConfigurationExtension::soap_default(NULL); }
	virtual ~tt__GenericEapPwdConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelayOutputSettings
#define SOAP_TYPE_tt__RelayOutputSettings (270)
/* tt:RelayOutputSettings */
class SOAP_CMAC tt__RelayOutputSettings
{
public:
	enum tt__RelayMode Mode;	/* required element of type tt:RelayMode */
	char *DelayTime;	/* required element of type xsd:duration */
	enum tt__RelayIdleState IdleState;	/* required element of type tt:RelayIdleState */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 270; } /* = unique id SOAP_TYPE_tt__RelayOutputSettings */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelayOutputSettings(): DelayTime(NULL), soap(NULL) { tt__RelayOutputSettings::soap_default(NULL); }
	virtual ~tt__RelayOutputSettings() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZNodeExtension
#define SOAP_TYPE_tt__PTZNodeExtension (274)
/* tt:PTZNodeExtension */
class SOAP_CMAC tt__PTZNodeExtension
{
public:
	class tt__PTZPresetTourSupported *SupportedPresetTour;	/* required element of type tt:PTZPresetTourSupported */
	class tt__PTZNodeExtension2 *Extension;	/* optional element of type tt:PTZNodeExtension2 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 274; } /* = unique id SOAP_TYPE_tt__PTZNodeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZNodeExtension(): SupportedPresetTour(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__PTZNodeExtension::soap_default(NULL); }
	virtual ~tt__PTZNodeExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZNodeExtension2
#define SOAP_TYPE_tt__PTZNodeExtension2 (275)
/* tt:PTZNodeExtension2 */
class SOAP_CMAC tt__PTZNodeExtension2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 275; } /* = unique id SOAP_TYPE_tt__PTZNodeExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZNodeExtension2(): __any(NULL), soap(NULL) { tt__PTZNodeExtension2::soap_default(NULL); }
	virtual ~tt__PTZNodeExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourSupported
#define SOAP_TYPE_tt__PTZPresetTourSupported (276)
/* tt:PTZPresetTourSupported */
class SOAP_CMAC tt__PTZPresetTourSupported
{
public:
	int MaximumNumberOfPresetTours;	/* required element of type xsd:int */
	int __sizePTZPresetTourOperation;	/* sequence of elements <PTZPresetTourOperation> */
	enum tt__PTZPresetTourOperation *PTZPresetTourOperation;	/* optional element of type tt:PTZPresetTourOperation */
	class tt__PTZPresetTourSupportedExtension *Extension;	/* optional element of type tt:PTZPresetTourSupportedExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 276; } /* = unique id SOAP_TYPE_tt__PTZPresetTourSupported */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourSupported(): PTZPresetTourOperation(NULL), Extension(NULL), soap(NULL) { tt__PTZPresetTourSupported::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSupported() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourSupportedExtension
#define SOAP_TYPE_tt__PTZPresetTourSupportedExtension (277)
/* tt:PTZPresetTourSupportedExtension */
class SOAP_CMAC tt__PTZPresetTourSupportedExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 277; } /* = unique id SOAP_TYPE_tt__PTZPresetTourSupportedExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourSupportedExtension(): __any(NULL), soap(NULL) { tt__PTZPresetTourSupportedExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSupportedExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZConfigurationExtension
#define SOAP_TYPE_tt__PTZConfigurationExtension (279)
/* tt:PTZConfigurationExtension */
class SOAP_CMAC tt__PTZConfigurationExtension
{
public:
	class tt__PTControlDirection *PTControlDirection;	/* optional element of type tt:PTControlDirection */
	class tt__PTZConfigurationExtension2 *Extension;	/* optional element of type tt:PTZConfigurationExtension2 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 279; } /* = unique id SOAP_TYPE_tt__PTZConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZConfigurationExtension(): PTControlDirection(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__PTZConfigurationExtension::soap_default(NULL); }
	virtual ~tt__PTZConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZConfigurationExtension2
#define SOAP_TYPE_tt__PTZConfigurationExtension2 (280)
/* tt:PTZConfigurationExtension2 */
class SOAP_CMAC tt__PTZConfigurationExtension2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 280; } /* = unique id SOAP_TYPE_tt__PTZConfigurationExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZConfigurationExtension2(): __any(NULL), soap(NULL) { tt__PTZConfigurationExtension2::soap_default(NULL); }
	virtual ~tt__PTZConfigurationExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTControlDirection
#define SOAP_TYPE_tt__PTControlDirection (281)
/* tt:PTControlDirection */
class SOAP_CMAC tt__PTControlDirection
{
public:
	class tt__EFlip *EFlip;	/* optional element of type tt:EFlip */
	class tt__Reverse *Reverse;	/* optional element of type tt:Reverse */
	class tt__PTControlDirectionExtension *Extension;	/* optional element of type tt:PTControlDirectionExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 281; } /* = unique id SOAP_TYPE_tt__PTControlDirection */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTControlDirection(): EFlip(NULL), Reverse(NULL), Extension(NULL), soap(NULL) { tt__PTControlDirection::soap_default(NULL); }
	virtual ~tt__PTControlDirection() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTControlDirectionExtension
#define SOAP_TYPE_tt__PTControlDirectionExtension (282)
/* tt:PTControlDirectionExtension */
class SOAP_CMAC tt__PTControlDirectionExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 282; } /* = unique id SOAP_TYPE_tt__PTControlDirectionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTControlDirectionExtension(): __any(NULL), soap(NULL) { tt__PTControlDirectionExtension::soap_default(NULL); }
	virtual ~tt__PTControlDirectionExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__EFlip
#define SOAP_TYPE_tt__EFlip (283)
/* tt:EFlip */
class SOAP_CMAC tt__EFlip
{
public:
	enum tt__EFlipMode Mode;	/* required element of type tt:EFlipMode */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 283; } /* = unique id SOAP_TYPE_tt__EFlip */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EFlip(): __any(NULL), soap(NULL) { tt__EFlip::soap_default(NULL); }
	virtual ~tt__EFlip() { }
};
#endif

#ifndef SOAP_TYPE_tt__Reverse
#define SOAP_TYPE_tt__Reverse (284)
/* tt:Reverse */
class SOAP_CMAC tt__Reverse
{
public:
	enum tt__ReverseMode Mode;	/* required element of type tt:ReverseMode */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 284; } /* = unique id SOAP_TYPE_tt__Reverse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Reverse(): __any(NULL), soap(NULL) { tt__Reverse::soap_default(NULL); }
	virtual ~tt__Reverse() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZConfigurationOptions
#define SOAP_TYPE_tt__PTZConfigurationOptions (285)
/* tt:PTZConfigurationOptions */
class SOAP_CMAC tt__PTZConfigurationOptions
{
public:
	class tt__PTZSpaces *Spaces;	/* required element of type tt:PTZSpaces */
	tt__DurationRange *PTZTimeout;	/* required element of type tt:DurationRange */
	class tt__PTControlDirectionOptions *PTControlDirection;	/* optional element of type tt:PTControlDirectionOptions */
	class tt__PTZConfigurationOptions2 *Extension;	/* optional element of type tt:PTZConfigurationOptions2 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 285; } /* = unique id SOAP_TYPE_tt__PTZConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZConfigurationOptions(): Spaces(NULL), PTZTimeout(NULL), PTControlDirection(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__PTZConfigurationOptions::soap_default(NULL); }
	virtual ~tt__PTZConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZConfigurationOptions2
#define SOAP_TYPE_tt__PTZConfigurationOptions2 (286)
/* tt:PTZConfigurationOptions2 */
class SOAP_CMAC tt__PTZConfigurationOptions2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 286; } /* = unique id SOAP_TYPE_tt__PTZConfigurationOptions2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZConfigurationOptions2(): __any(NULL), soap(NULL) { tt__PTZConfigurationOptions2::soap_default(NULL); }
	virtual ~tt__PTZConfigurationOptions2() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTControlDirectionOptions
#define SOAP_TYPE_tt__PTControlDirectionOptions (287)
/* tt:PTControlDirectionOptions */
class SOAP_CMAC tt__PTControlDirectionOptions
{
public:
	class tt__EFlipOptions *EFlip;	/* optional element of type tt:EFlipOptions */
	class tt__ReverseOptions *Reverse;	/* optional element of type tt:ReverseOptions */
	class tt__PTControlDirectionOptionsExtension *Extension;	/* optional element of type tt:PTControlDirectionOptionsExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 287; } /* = unique id SOAP_TYPE_tt__PTControlDirectionOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTControlDirectionOptions(): EFlip(NULL), Reverse(NULL), Extension(NULL), soap(NULL) { tt__PTControlDirectionOptions::soap_default(NULL); }
	virtual ~tt__PTControlDirectionOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTControlDirectionOptionsExtension
#define SOAP_TYPE_tt__PTControlDirectionOptionsExtension (288)
/* tt:PTControlDirectionOptionsExtension */
class SOAP_CMAC tt__PTControlDirectionOptionsExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 288; } /* = unique id SOAP_TYPE_tt__PTControlDirectionOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTControlDirectionOptionsExtension(): __any(NULL), soap(NULL) { tt__PTControlDirectionOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTControlDirectionOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__EFlipOptions
#define SOAP_TYPE_tt__EFlipOptions (289)
/* tt:EFlipOptions */
class SOAP_CMAC tt__EFlipOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> */
	enum tt__EFlipMode *Mode;	/* optional element of type tt:EFlipMode */
	class tt__EFlipOptionsExtension *Extension;	/* optional element of type tt:EFlipOptionsExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 289; } /* = unique id SOAP_TYPE_tt__EFlipOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EFlipOptions(): Mode(NULL), Extension(NULL), soap(NULL) { tt__EFlipOptions::soap_default(NULL); }
	virtual ~tt__EFlipOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__EFlipOptionsExtension
#define SOAP_TYPE_tt__EFlipOptionsExtension (290)
/* tt:EFlipOptionsExtension */
class SOAP_CMAC tt__EFlipOptionsExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 290; } /* = unique id SOAP_TYPE_tt__EFlipOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EFlipOptionsExtension(): __any(NULL), soap(NULL) { tt__EFlipOptionsExtension::soap_default(NULL); }
	virtual ~tt__EFlipOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReverseOptions
#define SOAP_TYPE_tt__ReverseOptions (291)
/* tt:ReverseOptions */
class SOAP_CMAC tt__ReverseOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> */
	enum tt__ReverseMode *Mode;	/* optional element of type tt:ReverseMode */
	class tt__ReverseOptionsExtension *Extension;	/* optional element of type tt:ReverseOptionsExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 291; } /* = unique id SOAP_TYPE_tt__ReverseOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReverseOptions(): Mode(NULL), Extension(NULL), soap(NULL) { tt__ReverseOptions::soap_default(NULL); }
	virtual ~tt__ReverseOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReverseOptionsExtension
#define SOAP_TYPE_tt__ReverseOptionsExtension (292)
/* tt:ReverseOptionsExtension */
class SOAP_CMAC tt__ReverseOptionsExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 292; } /* = unique id SOAP_TYPE_tt__ReverseOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReverseOptionsExtension(): __any(NULL), soap(NULL) { tt__ReverseOptionsExtension::soap_default(NULL); }
	virtual ~tt__ReverseOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PanTiltLimits
#define SOAP_TYPE_tt__PanTiltLimits (293)
/* tt:PanTiltLimits */
class SOAP_CMAC tt__PanTiltLimits
{
public:
	class tt__Space2DDescription *Range;	/* required element of type tt:Space2DDescription */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 293; } /* = unique id SOAP_TYPE_tt__PanTiltLimits */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PanTiltLimits(): Range(NULL), soap(NULL) { tt__PanTiltLimits::soap_default(NULL); }
	virtual ~tt__PanTiltLimits() { }
};
#endif

#ifndef SOAP_TYPE_tt__ZoomLimits
#define SOAP_TYPE_tt__ZoomLimits (294)
/* tt:ZoomLimits */
class SOAP_CMAC tt__ZoomLimits
{
public:
	class tt__Space1DDescription *Range;	/* required element of type tt:Space1DDescription */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 294; } /* = unique id SOAP_TYPE_tt__ZoomLimits */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ZoomLimits(): Range(NULL), soap(NULL) { tt__ZoomLimits::soap_default(NULL); }
	virtual ~tt__ZoomLimits() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZSpaces
#define SOAP_TYPE_tt__PTZSpaces (295)
/* tt:PTZSpaces */
class SOAP_CMAC tt__PTZSpaces
{
public:
	int __sizeAbsolutePanTiltPositionSpace;	/* sequence of elements <AbsolutePanTiltPositionSpace> */
	tt__Space2DDescription **AbsolutePanTiltPositionSpace;	/* optional element of type tt:Space2DDescription */
	int __sizeAbsoluteZoomPositionSpace;	/* sequence of elements <AbsoluteZoomPositionSpace> */
	tt__Space1DDescription **AbsoluteZoomPositionSpace;	/* optional element of type tt:Space1DDescription */
	int __sizeRelativePanTiltTranslationSpace;	/* sequence of elements <RelativePanTiltTranslationSpace> */
	tt__Space2DDescription **RelativePanTiltTranslationSpace;	/* optional element of type tt:Space2DDescription */
	int __sizeRelativeZoomTranslationSpace;	/* sequence of elements <RelativeZoomTranslationSpace> */
	tt__Space1DDescription **RelativeZoomTranslationSpace;	/* optional element of type tt:Space1DDescription */
	int __sizeContinuousPanTiltVelocitySpace;	/* sequence of elements <ContinuousPanTiltVelocitySpace> */
	tt__Space2DDescription **ContinuousPanTiltVelocitySpace;	/* optional element of type tt:Space2DDescription */
	int __sizeContinuousZoomVelocitySpace;	/* sequence of elements <ContinuousZoomVelocitySpace> */
	tt__Space1DDescription **ContinuousZoomVelocitySpace;	/* optional element of type tt:Space1DDescription */
	int __sizePanTiltSpeedSpace;	/* sequence of elements <PanTiltSpeedSpace> */
	tt__Space1DDescription **PanTiltSpeedSpace;	/* optional element of type tt:Space1DDescription */
	int __sizeZoomSpeedSpace;	/* sequence of elements <ZoomSpeedSpace> */
	tt__Space1DDescription **ZoomSpeedSpace;	/* optional element of type tt:Space1DDescription */
	class tt__PTZSpacesExtension *Extension;	/* optional element of type tt:PTZSpacesExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 295; } /* = unique id SOAP_TYPE_tt__PTZSpaces */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZSpaces(): AbsolutePanTiltPositionSpace(NULL), AbsoluteZoomPositionSpace(NULL), RelativePanTiltTranslationSpace(NULL), RelativeZoomTranslationSpace(NULL), ContinuousPanTiltVelocitySpace(NULL), ContinuousZoomVelocitySpace(NULL), PanTiltSpeedSpace(NULL), ZoomSpeedSpace(NULL), Extension(NULL), soap(NULL) { tt__PTZSpaces::soap_default(NULL); }
	virtual ~tt__PTZSpaces() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZSpacesExtension
#define SOAP_TYPE_tt__PTZSpacesExtension (296)
/* tt:PTZSpacesExtension */
class SOAP_CMAC tt__PTZSpacesExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 296; } /* = unique id SOAP_TYPE_tt__PTZSpacesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZSpacesExtension(): __any(NULL), soap(NULL) { tt__PTZSpacesExtension::soap_default(NULL); }
	virtual ~tt__PTZSpacesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Space2DDescription
#define SOAP_TYPE_tt__Space2DDescription (297)
/* tt:Space2DDescription */
class SOAP_CMAC tt__Space2DDescription
{
public:
	char *URI;	/* required element of type xsd:anyURI */
	tt__FloatRange *XRange;	/* required element of type tt:FloatRange */
	tt__FloatRange *YRange;	/* required element of type tt:FloatRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 297; } /* = unique id SOAP_TYPE_tt__Space2DDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Space2DDescription(): URI(NULL), XRange(NULL), YRange(NULL), soap(NULL) { tt__Space2DDescription::soap_default(NULL); }
	virtual ~tt__Space2DDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__Space1DDescription
#define SOAP_TYPE_tt__Space1DDescription (298)
/* tt:Space1DDescription */
class SOAP_CMAC tt__Space1DDescription
{
public:
	char *URI;	/* required element of type xsd:anyURI */
	tt__FloatRange *XRange;	/* required element of type tt:FloatRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 298; } /* = unique id SOAP_TYPE_tt__Space1DDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Space1DDescription(): URI(NULL), XRange(NULL), soap(NULL) { tt__Space1DDescription::soap_default(NULL); }
	virtual ~tt__Space1DDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__Vector2D
#define SOAP_TYPE_tt__Vector2D (299)
/* tt:Vector2D */
class SOAP_CMAC tt__Vector2D
{
public:
	float x;	/* required attribute */
	float y;	/* required attribute */
	char *space;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 299; } /* = unique id SOAP_TYPE_tt__Vector2D */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Vector2D(): space(NULL), soap(NULL) { tt__Vector2D::soap_default(NULL); }
	virtual ~tt__Vector2D() { }
};
#endif

#ifndef SOAP_TYPE_tt__Vector1D
#define SOAP_TYPE_tt__Vector1D (300)
/* tt:Vector1D */
class SOAP_CMAC tt__Vector1D
{
public:
	float x;	/* required attribute */
	char *space;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 300; } /* = unique id SOAP_TYPE_tt__Vector1D */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Vector1D(): space(NULL), soap(NULL) { tt__Vector1D::soap_default(NULL); }
	virtual ~tt__Vector1D() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZVector
#define SOAP_TYPE_tt__PTZVector (301)
/* tt:PTZVector */
class SOAP_CMAC tt__PTZVector
{
public:
	tt__Vector2D *PanTilt;	/* optional element of type tt:Vector2D */
	tt__Vector1D *Zoom;	/* optional element of type tt:Vector1D */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 301; } /* = unique id SOAP_TYPE_tt__PTZVector */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZVector(): PanTilt(NULL), Zoom(NULL), soap(NULL) { tt__PTZVector::soap_default(NULL); }
	virtual ~tt__PTZVector() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZSpeed
#define SOAP_TYPE_tt__PTZSpeed (302)
/* tt:PTZSpeed */
class SOAP_CMAC tt__PTZSpeed
{
public:
	tt__Vector2D *PanTilt;	/* optional element of type tt:Vector2D */
	tt__Vector1D *Zoom;	/* optional element of type tt:Vector1D */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 302; } /* = unique id SOAP_TYPE_tt__PTZSpeed */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZSpeed(): PanTilt(NULL), Zoom(NULL), soap(NULL) { tt__PTZSpeed::soap_default(NULL); }
	virtual ~tt__PTZSpeed() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZStatus
#define SOAP_TYPE_tt__PTZStatus (303)
/* tt:PTZStatus */
class SOAP_CMAC tt__PTZStatus
{
public:
	tt__PTZVector *Position;	/* optional element of type tt:PTZVector */
	class tt__PTZMoveStatus *MoveStatus;	/* optional element of type tt:PTZMoveStatus */
	char *Error;	/* optional element of type xsd:string */
	time_t UtcTime;	/* required element of type xsd:dateTime */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 303; } /* = unique id SOAP_TYPE_tt__PTZStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZStatus(): Position(NULL), MoveStatus(NULL), Error(NULL), __any(NULL), soap(NULL) { tt__PTZStatus::soap_default(NULL); }
	virtual ~tt__PTZStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPreset
#define SOAP_TYPE_tt__PTZPreset (304)
/* tt:PTZPreset */
class SOAP_CMAC tt__PTZPreset
{
public:
	char *Name;	/* optional element of type tt:Name */
	tt__PTZVector *PTZPosition;	/* optional element of type tt:PTZVector */
	char *token;	/* optional attribute */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 304; } /* = unique id SOAP_TYPE_tt__PTZPreset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPreset(): Name(NULL), PTZPosition(NULL), token(NULL), soap(NULL) { tt__PTZPreset::soap_default(NULL); }
	virtual ~tt__PTZPreset() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZMoveStatus
#define SOAP_TYPE_tt__PTZMoveStatus (305)
/* tt:PTZMoveStatus */
class SOAP_CMAC tt__PTZMoveStatus
{
public:
	enum tt__MoveStatus *PanTilt;	/* optional element of type tt:MoveStatus */
	enum tt__MoveStatus *Zoom;	/* optional element of type tt:MoveStatus */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 305; } /* = unique id SOAP_TYPE_tt__PTZMoveStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZMoveStatus(): PanTilt(NULL), Zoom(NULL), soap(NULL) { tt__PTZMoveStatus::soap_default(NULL); }
	virtual ~tt__PTZMoveStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__PresetTour
#define SOAP_TYPE_tt__PresetTour (306)
/* tt:PresetTour */
class SOAP_CMAC tt__PresetTour
{
public:
	char *Name;	/* optional element of type tt:Name */
	class tt__PTZPresetTourStatus *Status;	/* required element of type tt:PTZPresetTourStatus */
	bool AutoStart;	/* required element of type xsd:boolean */
	class tt__PTZPresetTourStartingCondition *StartingCondition;	/* required element of type tt:PTZPresetTourStartingCondition */
	int __sizeTourSpot;	/* sequence of elements <TourSpot> */
	class tt__PTZPresetTourSpot **TourSpot;	/* optional element of type tt:PTZPresetTourSpot */
	class tt__PTZPresetTourExtension *Extension;	/* optional element of type tt:PTZPresetTourExtension */
	char *token;	/* optional attribute */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 306; } /* = unique id SOAP_TYPE_tt__PresetTour */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PresetTour(): Name(NULL), Status(NULL), StartingCondition(NULL), TourSpot(NULL), Extension(NULL), token(NULL), soap(NULL) { tt__PresetTour::soap_default(NULL); }
	virtual ~tt__PresetTour() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourExtension
#define SOAP_TYPE_tt__PTZPresetTourExtension (307)
/* tt:PTZPresetTourExtension */
class SOAP_CMAC tt__PTZPresetTourExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 307; } /* = unique id SOAP_TYPE_tt__PTZPresetTourExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourExtension(): __any(NULL), soap(NULL) { tt__PTZPresetTourExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourSpot
#define SOAP_TYPE_tt__PTZPresetTourSpot (308)
/* tt:PTZPresetTourSpot */
class SOAP_CMAC tt__PTZPresetTourSpot
{
public:
	class tt__PTZPresetTourPresetDetail *PresetDetail;	/* required element of type tt:PTZPresetTourPresetDetail */
	tt__PTZSpeed *Speed;	/* optional element of type tt:PTZSpeed */
	char *StayTime;	/* optional element of type xsd:duration */
	class tt__PTZPresetTourSpotExtension *Extension;	/* optional element of type tt:PTZPresetTourSpotExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 308; } /* = unique id SOAP_TYPE_tt__PTZPresetTourSpot */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourSpot(): PresetDetail(NULL), Speed(NULL), StayTime(NULL), Extension(NULL), soap(NULL) { tt__PTZPresetTourSpot::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpot() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourSpotExtension
#define SOAP_TYPE_tt__PTZPresetTourSpotExtension (309)
/* tt:PTZPresetTourSpotExtension */
class SOAP_CMAC tt__PTZPresetTourSpotExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 309; } /* = unique id SOAP_TYPE_tt__PTZPresetTourSpotExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourSpotExtension(): __any(NULL), soap(NULL) { tt__PTZPresetTourSpotExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpotExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__union_PTZPresetTourPresetDetail
#define SOAP_TYPE__tt__union_PTZPresetTourPresetDetail (878)
/* xsd:choice */
union _tt__union_PTZPresetTourPresetDetail
{
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken	(1)
	char *PresetToken;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home	(2)
	bool Home;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition	(3)
	tt__PTZVector *PTZPosition;
#define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension	(4)
	class tt__PTZPresetTourTypeExtension *TypeExtension;
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetail
#define SOAP_TYPE_tt__PTZPresetTourPresetDetail (310)
/* tt:PTZPresetTourPresetDetail */
class SOAP_CMAC tt__PTZPresetTourPresetDetail
{
public:
	int __union_PTZPresetTourPresetDetail;	/* union discriminant (of union defined below) */
	union _tt__union_PTZPresetTourPresetDetail union_PTZPresetTourPresetDetail;	/* required element of type xsd:choice */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 310; } /* = unique id SOAP_TYPE_tt__PTZPresetTourPresetDetail */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourPresetDetail(): __any(NULL), soap(NULL) { tt__PTZPresetTourPresetDetail::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetail() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourTypeExtension
#define SOAP_TYPE_tt__PTZPresetTourTypeExtension (311)
/* tt:PTZPresetTourTypeExtension */
class SOAP_CMAC tt__PTZPresetTourTypeExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 311; } /* = unique id SOAP_TYPE_tt__PTZPresetTourTypeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourTypeExtension(): __any(NULL), soap(NULL) { tt__PTZPresetTourTypeExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourTypeExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourStatus
#define SOAP_TYPE_tt__PTZPresetTourStatus (312)
/* tt:PTZPresetTourStatus */
class SOAP_CMAC tt__PTZPresetTourStatus
{
public:
	enum tt__PTZPresetTourState State;	/* required element of type tt:PTZPresetTourState */
	tt__PTZPresetTourSpot *CurrentTourSpot;	/* optional element of type tt:PTZPresetTourSpot */
	class tt__PTZPresetTourStatusExtension *Extension;	/* optional element of type tt:PTZPresetTourStatusExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 312; } /* = unique id SOAP_TYPE_tt__PTZPresetTourStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourStatus(): CurrentTourSpot(NULL), Extension(NULL), soap(NULL) { tt__PTZPresetTourStatus::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourStatusExtension
#define SOAP_TYPE_tt__PTZPresetTourStatusExtension (313)
/* tt:PTZPresetTourStatusExtension */
class SOAP_CMAC tt__PTZPresetTourStatusExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 313; } /* = unique id SOAP_TYPE_tt__PTZPresetTourStatusExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourStatusExtension(): __any(NULL), soap(NULL) { tt__PTZPresetTourStatusExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStatusExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourStartingCondition
#define SOAP_TYPE_tt__PTZPresetTourStartingCondition (314)
/* tt:PTZPresetTourStartingCondition */
class SOAP_CMAC tt__PTZPresetTourStartingCondition
{
public:
	int *RecurringTime;	/* optional element of type xsd:int */
	char *RecurringDuration;	/* optional element of type xsd:duration */
	enum tt__PTZPresetTourDirection *Direction;	/* optional element of type tt:PTZPresetTourDirection */
	class tt__PTZPresetTourStartingConditionExtension *Extension;	/* optional element of type tt:PTZPresetTourStartingConditionExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 314; } /* = unique id SOAP_TYPE_tt__PTZPresetTourStartingCondition */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourStartingCondition(): RecurringTime(NULL), RecurringDuration(NULL), Direction(NULL), Extension(NULL), soap(NULL) { tt__PTZPresetTourStartingCondition::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingCondition() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension (315)
/* tt:PTZPresetTourStartingConditionExtension */
class SOAP_CMAC tt__PTZPresetTourStartingConditionExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 315; } /* = unique id SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourStartingConditionExtension(): __any(NULL), soap(NULL) { tt__PTZPresetTourStartingConditionExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourOptions
#define SOAP_TYPE_tt__PTZPresetTourOptions (316)
/* tt:PTZPresetTourOptions */
class SOAP_CMAC tt__PTZPresetTourOptions
{
public:
	bool AutoStart;	/* required element of type xsd:boolean */
	class tt__PTZPresetTourStartingConditionOptions *StartingCondition;	/* required element of type tt:PTZPresetTourStartingConditionOptions */
	class tt__PTZPresetTourSpotOptions *TourSpot;	/* required element of type tt:PTZPresetTourSpotOptions */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 316; } /* = unique id SOAP_TYPE_tt__PTZPresetTourOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourOptions(): StartingCondition(NULL), TourSpot(NULL), __any(NULL), soap(NULL) { tt__PTZPresetTourOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourSpotOptions
#define SOAP_TYPE_tt__PTZPresetTourSpotOptions (317)
/* tt:PTZPresetTourSpotOptions */
class SOAP_CMAC tt__PTZPresetTourSpotOptions
{
public:
	class tt__PTZPresetTourPresetDetailOptions *PresetDetail;	/* required element of type tt:PTZPresetTourPresetDetailOptions */
	tt__DurationRange *StayTime;	/* required element of type tt:DurationRange */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 317; } /* = unique id SOAP_TYPE_tt__PTZPresetTourSpotOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourSpotOptions(): PresetDetail(NULL), StayTime(NULL), __any(NULL), soap(NULL) { tt__PTZPresetTourSpotOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourSpotOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions (318)
/* tt:PTZPresetTourPresetDetailOptions */
class SOAP_CMAC tt__PTZPresetTourPresetDetailOptions
{
public:
	int __sizePresetToken;	/* sequence of elements <PresetToken> */
	char **PresetToken;	/* optional element of type tt:ReferenceToken */
	bool *Home;	/* optional element of type xsd:boolean */
	tt__Space2DDescription *PanTiltPositionSpace;	/* optional element of type tt:Space2DDescription */
	tt__Space1DDescription *ZoomPositionSpace;	/* optional element of type tt:Space1DDescription */
	class tt__PTZPresetTourPresetDetailOptionsExtension *Extension;	/* optional element of type tt:PTZPresetTourPresetDetailOptionsExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 318; } /* = unique id SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourPresetDetailOptions(): PresetToken(NULL), Home(NULL), PanTiltPositionSpace(NULL), ZoomPositionSpace(NULL), Extension(NULL), soap(NULL) { tt__PTZPresetTourPresetDetailOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetailOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension (319)
/* tt:PTZPresetTourPresetDetailOptionsExtension */
class SOAP_CMAC tt__PTZPresetTourPresetDetailOptionsExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 319; } /* = unique id SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourPresetDetailOptionsExtension(): __any(NULL), soap(NULL) { tt__PTZPresetTourPresetDetailOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourPresetDetailOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions (320)
/* tt:PTZPresetTourStartingConditionOptions */
class SOAP_CMAC tt__PTZPresetTourStartingConditionOptions
{
public:
	tt__IntRange *RecurringTime;	/* optional element of type tt:IntRange */
	tt__DurationRange *RecurringDuration;	/* optional element of type tt:DurationRange */
	int __sizeDirection;	/* sequence of elements <Direction> */
	enum tt__PTZPresetTourDirection *Direction;	/* optional element of type tt:PTZPresetTourDirection */
	class tt__PTZPresetTourStartingConditionOptionsExtension *Extension;	/* optional element of type tt:PTZPresetTourStartingConditionOptionsExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 320; } /* = unique id SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourStartingConditionOptions(): RecurringTime(NULL), RecurringDuration(NULL), Direction(NULL), Extension(NULL), soap(NULL) { tt__PTZPresetTourStartingConditionOptions::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension (321)
/* tt:PTZPresetTourStartingConditionOptionsExtension */
class SOAP_CMAC tt__PTZPresetTourStartingConditionOptionsExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 321; } /* = unique id SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPresetTourStartingConditionOptionsExtension(): __any(NULL), soap(NULL) { tt__PTZPresetTourStartingConditionOptionsExtension::soap_default(NULL); }
	virtual ~tt__PTZPresetTourStartingConditionOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingStatus
#define SOAP_TYPE_tt__ImagingStatus (322)
/* tt:ImagingStatus */
class SOAP_CMAC tt__ImagingStatus
{
public:
	class tt__FocusStatus *FocusStatus;	/* required element of type tt:FocusStatus */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 322; } /* = unique id SOAP_TYPE_tt__ImagingStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingStatus(): FocusStatus(NULL), __any(NULL), soap(NULL) { tt__ImagingStatus::soap_default(NULL); }
	virtual ~tt__ImagingStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusStatus
#define SOAP_TYPE_tt__FocusStatus (323)
/* tt:FocusStatus */
class SOAP_CMAC tt__FocusStatus
{
public:
	float Position;	/* required element of type xsd:float */
	enum tt__MoveStatus MoveStatus;	/* required element of type tt:MoveStatus */
	char *Error;	/* required element of type xsd:string */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 323; } /* = unique id SOAP_TYPE_tt__FocusStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusStatus(): Error(NULL), __any(NULL), soap(NULL) { tt__FocusStatus::soap_default(NULL); }
	virtual ~tt__FocusStatus() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusConfiguration
#define SOAP_TYPE_tt__FocusConfiguration (324)
/* tt:FocusConfiguration */
class SOAP_CMAC tt__FocusConfiguration
{
public:
	enum tt__AutoFocusMode AutoFocusMode;	/* required element of type tt:AutoFocusMode */
	float DefaultSpeed;	/* required element of type xsd:float */
	float NearLimit;	/* required element of type xsd:float */
	float FarLimit;	/* required element of type xsd:float */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 324; } /* = unique id SOAP_TYPE_tt__FocusConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusConfiguration(): __any(NULL), soap(NULL) { tt__FocusConfiguration::soap_default(NULL); }
	virtual ~tt__FocusConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingSettings
#define SOAP_TYPE_tt__ImagingSettings (325)
/* tt:ImagingSettings */
class SOAP_CMAC tt__ImagingSettings
{
public:
	class tt__BacklightCompensation *BacklightCompensation;	/* optional element of type tt:BacklightCompensation */
	float *Brightness;	/* optional element of type xsd:float */
	float *ColorSaturation;	/* optional element of type xsd:float */
	float *Contrast;	/* optional element of type xsd:float */
	class tt__Exposure *Exposure;	/* optional element of type tt:Exposure */
	tt__FocusConfiguration *Focus;	/* optional element of type tt:FocusConfiguration */
	enum tt__IrCutFilterMode *IrCutFilter;	/* optional element of type tt:IrCutFilterMode */
	float *Sharpness;	/* optional element of type xsd:float */
	class tt__WideDynamicRange *WideDynamicRange;	/* optional element of type tt:WideDynamicRange */
	class tt__WhiteBalance *WhiteBalance;	/* optional element of type tt:WhiteBalance */
	class tt__ImagingSettingsExtension *Extension;	/* optional element of type tt:ImagingSettingsExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 325; } /* = unique id SOAP_TYPE_tt__ImagingSettings */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingSettings(): BacklightCompensation(NULL), Brightness(NULL), ColorSaturation(NULL), Contrast(NULL), Exposure(NULL), Focus(NULL), IrCutFilter(NULL), Sharpness(NULL), WideDynamicRange(NULL), WhiteBalance(NULL), Extension(NULL), soap(NULL) { tt__ImagingSettings::soap_default(NULL); }
	virtual ~tt__ImagingSettings() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingSettingsExtension
#define SOAP_TYPE_tt__ImagingSettingsExtension (326)
/* tt:ImagingSettingsExtension */
class SOAP_CMAC tt__ImagingSettingsExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 326; } /* = unique id SOAP_TYPE_tt__ImagingSettingsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingSettingsExtension(): __any(NULL), soap(NULL) { tt__ImagingSettingsExtension::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Exposure
#define SOAP_TYPE_tt__Exposure (327)
/* tt:Exposure */
class SOAP_CMAC tt__Exposure
{
public:
	enum tt__ExposureMode Mode;	/* required element of type tt:ExposureMode */
	enum tt__ExposurePriority Priority;	/* required element of type tt:ExposurePriority */
	class tt__Rectangle *Window;	/* required element of type tt:Rectangle */
	float MinExposureTime;	/* required element of type xsd:float */
	float MaxExposureTime;	/* required element of type xsd:float */
	float MinGain;	/* required element of type xsd:float */
	float MaxGain;	/* required element of type xsd:float */
	float MinIris;	/* required element of type xsd:float */
	float MaxIris;	/* required element of type xsd:float */
	float ExposureTime;	/* required element of type xsd:float */
	float Gain;	/* required element of type xsd:float */
	float Iris;	/* required element of type xsd:float */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 327; } /* = unique id SOAP_TYPE_tt__Exposure */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Exposure(): Window(NULL), soap(NULL) { tt__Exposure::soap_default(NULL); }
	virtual ~tt__Exposure() { }
};
#endif

#ifndef SOAP_TYPE_tt__WideDynamicRange
#define SOAP_TYPE_tt__WideDynamicRange (328)
/* tt:WideDynamicRange */
class SOAP_CMAC tt__WideDynamicRange
{
public:
	enum tt__WideDynamicMode Mode;	/* required element of type tt:WideDynamicMode */
	float Level;	/* required element of type xsd:float */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 328; } /* = unique id SOAP_TYPE_tt__WideDynamicRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WideDynamicRange(): soap(NULL) { tt__WideDynamicRange::soap_default(NULL); }
	virtual ~tt__WideDynamicRange() { }
};
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensation
#define SOAP_TYPE_tt__BacklightCompensation (329)
/* tt:BacklightCompensation */
class SOAP_CMAC tt__BacklightCompensation
{
public:
	enum tt__BacklightCompensationMode Mode;	/* required element of type tt:BacklightCompensationMode */
	float Level;	/* required element of type xsd:float */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 329; } /* = unique id SOAP_TYPE_tt__BacklightCompensation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BacklightCompensation(): soap(NULL) { tt__BacklightCompensation::soap_default(NULL); }
	virtual ~tt__BacklightCompensation() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions
#define SOAP_TYPE_tt__ImagingOptions (330)
/* tt:ImagingOptions */
class SOAP_CMAC tt__ImagingOptions
{
public:
	class tt__BacklightCompensationOptions *BacklightCompensation;	/* required element of type tt:BacklightCompensationOptions */
	tt__FloatRange *Brightness;	/* required element of type tt:FloatRange */
	tt__FloatRange *ColorSaturation;	/* required element of type tt:FloatRange */
	tt__FloatRange *Contrast;	/* required element of type tt:FloatRange */
	class tt__ExposureOptions *Exposure;	/* required element of type tt:ExposureOptions */
	class tt__FocusOptions *Focus;	/* required element of type tt:FocusOptions */
	int __sizeIrCutFilterModes;	/* sequence of elements <IrCutFilterModes> */
	enum tt__IrCutFilterMode *IrCutFilterModes;	/* required element of type tt:IrCutFilterMode */
	tt__FloatRange *Sharpness;	/* required element of type tt:FloatRange */
	class tt__WideDynamicRangeOptions *WideDynamicRange;	/* required element of type tt:WideDynamicRangeOptions */
	class tt__WhiteBalanceOptions *WhiteBalance;	/* required element of type tt:WhiteBalanceOptions */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 330; } /* = unique id SOAP_TYPE_tt__ImagingOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingOptions(): BacklightCompensation(NULL), Brightness(NULL), ColorSaturation(NULL), Contrast(NULL), Exposure(NULL), Focus(NULL), IrCutFilterModes(NULL), Sharpness(NULL), WideDynamicRange(NULL), WhiteBalance(NULL), __any(NULL), soap(NULL) { tt__ImagingOptions::soap_default(NULL); }
	virtual ~tt__ImagingOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions
#define SOAP_TYPE_tt__WideDynamicRangeOptions (331)
/* tt:WideDynamicRangeOptions */
class SOAP_CMAC tt__WideDynamicRangeOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> */
	enum tt__WideDynamicMode *Mode;	/* required element of type tt:WideDynamicMode */
	tt__FloatRange *Level;	/* required element of type tt:FloatRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 331; } /* = unique id SOAP_TYPE_tt__WideDynamicRangeOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WideDynamicRangeOptions(): Mode(NULL), Level(NULL), soap(NULL) { tt__WideDynamicRangeOptions::soap_default(NULL); }
	virtual ~tt__WideDynamicRangeOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensationOptions
#define SOAP_TYPE_tt__BacklightCompensationOptions (332)
/* tt:BacklightCompensationOptions */
class SOAP_CMAC tt__BacklightCompensationOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> */
	enum tt__WideDynamicMode *Mode;	/* required element of type tt:WideDynamicMode */
	tt__FloatRange *Level;	/* required element of type tt:FloatRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 332; } /* = unique id SOAP_TYPE_tt__BacklightCompensationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BacklightCompensationOptions(): Mode(NULL), Level(NULL), soap(NULL) { tt__BacklightCompensationOptions::soap_default(NULL); }
	virtual ~tt__BacklightCompensationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusOptions
#define SOAP_TYPE_tt__FocusOptions (333)
/* tt:FocusOptions */
class SOAP_CMAC tt__FocusOptions
{
public:
	int __sizeAutoFocusModes;	/* sequence of elements <AutoFocusModes> */
	enum tt__AutoFocusMode *AutoFocusModes;	/* optional element of type tt:AutoFocusMode */
	tt__FloatRange *DefaultSpeed;	/* required element of type tt:FloatRange */
	tt__FloatRange *NearLimit;	/* required element of type tt:FloatRange */
	tt__FloatRange *FarLimit;	/* required element of type tt:FloatRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 333; } /* = unique id SOAP_TYPE_tt__FocusOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusOptions(): AutoFocusModes(NULL), DefaultSpeed(NULL), NearLimit(NULL), FarLimit(NULL), soap(NULL) { tt__FocusOptions::soap_default(NULL); }
	virtual ~tt__FocusOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__ExposureOptions
#define SOAP_TYPE_tt__ExposureOptions (334)
/* tt:ExposureOptions */
class SOAP_CMAC tt__ExposureOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> */
	enum tt__ExposureMode *Mode;	/* required element of type tt:ExposureMode */
	int __sizePriority;	/* sequence of elements <Priority> */
	enum tt__ExposurePriority *Priority;	/* required element of type tt:ExposurePriority */
	tt__FloatRange *MinExposureTime;	/* required element of type tt:FloatRange */
	tt__FloatRange *MaxExposureTime;	/* required element of type tt:FloatRange */
	tt__FloatRange *MinGain;	/* required element of type tt:FloatRange */
	tt__FloatRange *MaxGain;	/* required element of type tt:FloatRange */
	tt__FloatRange *MinIris;	/* required element of type tt:FloatRange */
	tt__FloatRange *MaxIris;	/* required element of type tt:FloatRange */
	tt__FloatRange *ExposureTime;	/* required element of type tt:FloatRange */
	tt__FloatRange *Gain;	/* required element of type tt:FloatRange */
	tt__FloatRange *Iris;	/* required element of type tt:FloatRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 334; } /* = unique id SOAP_TYPE_tt__ExposureOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ExposureOptions(): Mode(NULL), Priority(NULL), MinExposureTime(NULL), MaxExposureTime(NULL), MinGain(NULL), MaxGain(NULL), MinIris(NULL), MaxIris(NULL), ExposureTime(NULL), Gain(NULL), Iris(NULL), soap(NULL) { tt__ExposureOptions::soap_default(NULL); }
	virtual ~tt__ExposureOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceOptions
#define SOAP_TYPE_tt__WhiteBalanceOptions (335)
/* tt:WhiteBalanceOptions */
class SOAP_CMAC tt__WhiteBalanceOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> */
	enum tt__WhiteBalanceMode *Mode;	/* required element of type tt:WhiteBalanceMode */
	tt__FloatRange *YrGain;	/* required element of type tt:FloatRange */
	tt__FloatRange *YbGain;	/* required element of type tt:FloatRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 335; } /* = unique id SOAP_TYPE_tt__WhiteBalanceOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalanceOptions(): Mode(NULL), YrGain(NULL), YbGain(NULL), soap(NULL) { tt__WhiteBalanceOptions::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusMove
#define SOAP_TYPE_tt__FocusMove (336)
/* tt:FocusMove */
class SOAP_CMAC tt__FocusMove
{
public:
	class tt__AbsoluteFocus *Absolute;	/* optional element of type tt:AbsoluteFocus */
	class tt__RelativeFocus *Relative;	/* optional element of type tt:RelativeFocus */
	class tt__ContinuousFocus *Continuous;	/* optional element of type tt:ContinuousFocus */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 336; } /* = unique id SOAP_TYPE_tt__FocusMove */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusMove(): Absolute(NULL), Relative(NULL), Continuous(NULL), soap(NULL) { tt__FocusMove::soap_default(NULL); }
	virtual ~tt__FocusMove() { }
};
#endif

#ifndef SOAP_TYPE_tt__AbsoluteFocus
#define SOAP_TYPE_tt__AbsoluteFocus (337)
/* tt:AbsoluteFocus */
class SOAP_CMAC tt__AbsoluteFocus
{
public:
	float Position;	/* required element of type xsd:float */
	float *Speed;	/* optional element of type xsd:float */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 337; } /* = unique id SOAP_TYPE_tt__AbsoluteFocus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AbsoluteFocus(): Speed(NULL), soap(NULL) { tt__AbsoluteFocus::soap_default(NULL); }
	virtual ~tt__AbsoluteFocus() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelativeFocus
#define SOAP_TYPE_tt__RelativeFocus (338)
/* tt:RelativeFocus */
class SOAP_CMAC tt__RelativeFocus
{
public:
	float Distance;	/* required element of type xsd:float */
	float *Speed;	/* optional element of type xsd:float */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 338; } /* = unique id SOAP_TYPE_tt__RelativeFocus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelativeFocus(): Speed(NULL), soap(NULL) { tt__RelativeFocus::soap_default(NULL); }
	virtual ~tt__RelativeFocus() { }
};
#endif

#ifndef SOAP_TYPE_tt__ContinuousFocus
#define SOAP_TYPE_tt__ContinuousFocus (339)
/* tt:ContinuousFocus */
class SOAP_CMAC tt__ContinuousFocus
{
public:
	float Speed;	/* required element of type xsd:float */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 339; } /* = unique id SOAP_TYPE_tt__ContinuousFocus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ContinuousFocus(): soap(NULL) { tt__ContinuousFocus::soap_default(NULL); }
	virtual ~tt__ContinuousFocus() { }
};
#endif

#ifndef SOAP_TYPE_tt__MoveOptions
#define SOAP_TYPE_tt__MoveOptions (340)
/* tt:MoveOptions */
class SOAP_CMAC tt__MoveOptions
{
public:
	class tt__AbsoluteFocusOptions *Absolute;	/* optional element of type tt:AbsoluteFocusOptions */
	class tt__RelativeFocusOptions *Relative;	/* optional element of type tt:RelativeFocusOptions */
	class tt__ContinuousFocusOptions *Continuous;	/* optional element of type tt:ContinuousFocusOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 340; } /* = unique id SOAP_TYPE_tt__MoveOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MoveOptions(): Absolute(NULL), Relative(NULL), Continuous(NULL), soap(NULL) { tt__MoveOptions::soap_default(NULL); }
	virtual ~tt__MoveOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__AbsoluteFocusOptions
#define SOAP_TYPE_tt__AbsoluteFocusOptions (341)
/* tt:AbsoluteFocusOptions */
class SOAP_CMAC tt__AbsoluteFocusOptions
{
public:
	tt__FloatRange *Position;	/* required element of type tt:FloatRange */
	tt__FloatRange *Speed;	/* optional element of type tt:FloatRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 341; } /* = unique id SOAP_TYPE_tt__AbsoluteFocusOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AbsoluteFocusOptions(): Position(NULL), Speed(NULL), soap(NULL) { tt__AbsoluteFocusOptions::soap_default(NULL); }
	virtual ~tt__AbsoluteFocusOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelativeFocusOptions
#define SOAP_TYPE_tt__RelativeFocusOptions (342)
/* tt:RelativeFocusOptions */
class SOAP_CMAC tt__RelativeFocusOptions
{
public:
	tt__FloatRange *Distance;	/* required element of type tt:FloatRange */
	tt__FloatRange *Speed;	/* required element of type tt:FloatRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 342; } /* = unique id SOAP_TYPE_tt__RelativeFocusOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelativeFocusOptions(): Distance(NULL), Speed(NULL), soap(NULL) { tt__RelativeFocusOptions::soap_default(NULL); }
	virtual ~tt__RelativeFocusOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__ContinuousFocusOptions
#define SOAP_TYPE_tt__ContinuousFocusOptions (343)
/* tt:ContinuousFocusOptions */
class SOAP_CMAC tt__ContinuousFocusOptions
{
public:
	tt__FloatRange *Speed;	/* required element of type tt:FloatRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 343; } /* = unique id SOAP_TYPE_tt__ContinuousFocusOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ContinuousFocusOptions(): Speed(NULL), soap(NULL) { tt__ContinuousFocusOptions::soap_default(NULL); }
	virtual ~tt__ContinuousFocusOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalance
#define SOAP_TYPE_tt__WhiteBalance (344)
/* tt:WhiteBalance */
class SOAP_CMAC tt__WhiteBalance
{
public:
	enum tt__WhiteBalanceMode Mode;	/* required element of type tt:WhiteBalanceMode */
	float CrGain;	/* required element of type xsd:float */
	float CbGain;	/* required element of type xsd:float */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 344; } /* = unique id SOAP_TYPE_tt__WhiteBalance */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalance(): __any(NULL), soap(NULL) { tt__WhiteBalance::soap_default(NULL); }
	virtual ~tt__WhiteBalance() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingStatus20
#define SOAP_TYPE_tt__ImagingStatus20 (345)
/* tt:ImagingStatus20 */
class SOAP_CMAC tt__ImagingStatus20
{
public:
	class tt__FocusStatus20 *FocusStatus20;	/* optional element of type tt:FocusStatus20 */
	class tt__ImagingStatus20Extension *Extension;	/* optional element of type tt:ImagingStatus20Extension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 345; } /* = unique id SOAP_TYPE_tt__ImagingStatus20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingStatus20(): FocusStatus20(NULL), Extension(NULL), soap(NULL) { tt__ImagingStatus20::soap_default(NULL); }
	virtual ~tt__ImagingStatus20() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingStatus20Extension
#define SOAP_TYPE_tt__ImagingStatus20Extension (346)
/* tt:ImagingStatus20Extension */
class SOAP_CMAC tt__ImagingStatus20Extension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 346; } /* = unique id SOAP_TYPE_tt__ImagingStatus20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingStatus20Extension(): __any(NULL), soap(NULL) { tt__ImagingStatus20Extension::soap_default(NULL); }
	virtual ~tt__ImagingStatus20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusStatus20
#define SOAP_TYPE_tt__FocusStatus20 (347)
/* tt:FocusStatus20 */
class SOAP_CMAC tt__FocusStatus20
{
public:
	float Position;	/* required element of type xsd:float */
	enum tt__MoveStatus MoveStatus;	/* required element of type tt:MoveStatus */
	char *Error;	/* optional element of type xsd:string */
	class tt__FocusStatus20Extension *Extension;	/* optional element of type tt:FocusStatus20Extension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 347; } /* = unique id SOAP_TYPE_tt__FocusStatus20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusStatus20(): Error(NULL), Extension(NULL), soap(NULL) { tt__FocusStatus20::soap_default(NULL); }
	virtual ~tt__FocusStatus20() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusStatus20Extension
#define SOAP_TYPE_tt__FocusStatus20Extension (348)
/* tt:FocusStatus20Extension */
class SOAP_CMAC tt__FocusStatus20Extension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 348; } /* = unique id SOAP_TYPE_tt__FocusStatus20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusStatus20Extension(): __any(NULL), soap(NULL) { tt__FocusStatus20Extension::soap_default(NULL); }
	virtual ~tt__FocusStatus20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingSettings20
#define SOAP_TYPE_tt__ImagingSettings20 (349)
/* tt:ImagingSettings20 */
class SOAP_CMAC tt__ImagingSettings20
{
public:
	class tt__BacklightCompensation20 *BacklightCompensation;	/* optional element of type tt:BacklightCompensation20 */
	float *Brightness;	/* optional element of type xsd:float */
	float *ColorSaturation;	/* optional element of type xsd:float */
	float *Contrast;	/* optional element of type xsd:float */
	class tt__Exposure20 *Exposure;	/* optional element of type tt:Exposure20 */
	class tt__FocusConfiguration20 *Focus;	/* optional element of type tt:FocusConfiguration20 */
	enum tt__IrCutFilterMode *IrCutFilter;	/* optional element of type tt:IrCutFilterMode */
	float *Sharpness;	/* optional element of type xsd:float */
	class tt__WideDynamicRange20 *WideDynamicRange;	/* optional element of type tt:WideDynamicRange20 */
	class tt__WhiteBalance20 *WhiteBalance;	/* optional element of type tt:WhiteBalance20 */
	class tt__ImagingSettingsExtension20 *Extension;	/* optional element of type tt:ImagingSettingsExtension20 */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 349; } /* = unique id SOAP_TYPE_tt__ImagingSettings20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingSettings20(): BacklightCompensation(NULL), Brightness(NULL), ColorSaturation(NULL), Contrast(NULL), Exposure(NULL), Focus(NULL), IrCutFilter(NULL), Sharpness(NULL), WideDynamicRange(NULL), WhiteBalance(NULL), Extension(NULL), soap(NULL) { tt__ImagingSettings20::soap_default(NULL); }
	virtual ~tt__ImagingSettings20() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingSettingsExtension20
#define SOAP_TYPE_tt__ImagingSettingsExtension20 (350)
/* tt:ImagingSettingsExtension20 */
class SOAP_CMAC tt__ImagingSettingsExtension20
{
public:
	class tt__ImageStabilization *ImageStabilization;	/* optional element of type tt:ImageStabilization */
	class tt__ImagingSettingsExtension202 *Extension;	/* optional element of type tt:ImagingSettingsExtension202 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 350; } /* = unique id SOAP_TYPE_tt__ImagingSettingsExtension20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingSettingsExtension20(): ImageStabilization(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__ImagingSettingsExtension20::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension20() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingSettingsExtension202
#define SOAP_TYPE_tt__ImagingSettingsExtension202 (351)
/* tt:ImagingSettingsExtension202 */
class SOAP_CMAC tt__ImagingSettingsExtension202
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 351; } /* = unique id SOAP_TYPE_tt__ImagingSettingsExtension202 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingSettingsExtension202(): __any(NULL), soap(NULL) { tt__ImagingSettingsExtension202::soap_default(NULL); }
	virtual ~tt__ImagingSettingsExtension202() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImageStabilization
#define SOAP_TYPE_tt__ImageStabilization (352)
/* tt:ImageStabilization */
class SOAP_CMAC tt__ImageStabilization
{
public:
	enum tt__ImageStabilizationMode Mode;	/* required element of type tt:ImageStabilizationMode */
	float *Level;	/* optional element of type xsd:float */
	class tt__ImageStabilizationExtension *Extension;	/* optional element of type tt:ImageStabilizationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 352; } /* = unique id SOAP_TYPE_tt__ImageStabilization */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImageStabilization(): Level(NULL), Extension(NULL), soap(NULL) { tt__ImageStabilization::soap_default(NULL); }
	virtual ~tt__ImageStabilization() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImageStabilizationExtension
#define SOAP_TYPE_tt__ImageStabilizationExtension (353)
/* tt:ImageStabilizationExtension */
class SOAP_CMAC tt__ImageStabilizationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 353; } /* = unique id SOAP_TYPE_tt__ImageStabilizationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImageStabilizationExtension(): __any(NULL), soap(NULL) { tt__ImageStabilizationExtension::soap_default(NULL); }
	virtual ~tt__ImageStabilizationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__WideDynamicRange20
#define SOAP_TYPE_tt__WideDynamicRange20 (354)
/* tt:WideDynamicRange20 */
class SOAP_CMAC tt__WideDynamicRange20
{
public:
	enum tt__WideDynamicMode Mode;	/* required element of type tt:WideDynamicMode */
	float *Level;	/* optional element of type xsd:float */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 354; } /* = unique id SOAP_TYPE_tt__WideDynamicRange20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WideDynamicRange20(): Level(NULL), soap(NULL) { tt__WideDynamicRange20::soap_default(NULL); }
	virtual ~tt__WideDynamicRange20() { }
};
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensation20
#define SOAP_TYPE_tt__BacklightCompensation20 (355)
/* tt:BacklightCompensation20 */
class SOAP_CMAC tt__BacklightCompensation20
{
public:
	enum tt__BacklightCompensationMode Mode;	/* required element of type tt:BacklightCompensationMode */
	float *Level;	/* optional element of type xsd:float */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 355; } /* = unique id SOAP_TYPE_tt__BacklightCompensation20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BacklightCompensation20(): Level(NULL), soap(NULL) { tt__BacklightCompensation20::soap_default(NULL); }
	virtual ~tt__BacklightCompensation20() { }
};
#endif

#ifndef SOAP_TYPE_tt__Exposure20
#define SOAP_TYPE_tt__Exposure20 (356)
/* tt:Exposure20 */
class SOAP_CMAC tt__Exposure20
{
public:
	enum tt__ExposureMode Mode;	/* required element of type tt:ExposureMode */
	enum tt__ExposurePriority *Priority;	/* optional element of type tt:ExposurePriority */
	tt__Rectangle *Window;	/* optional element of type tt:Rectangle */
	float *MinExposureTime;	/* optional element of type xsd:float */
	float *MaxExposureTime;	/* optional element of type xsd:float */
	float *MinGain;	/* optional element of type xsd:float */
	float *MaxGain;	/* optional element of type xsd:float */
	float *MinIris;	/* optional element of type xsd:float */
	float *MaxIris;	/* optional element of type xsd:float */
	float *ExposureTime;	/* optional element of type xsd:float */
	float *Gain;	/* optional element of type xsd:float */
	float *Iris;	/* optional element of type xsd:float */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 356; } /* = unique id SOAP_TYPE_tt__Exposure20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Exposure20(): Priority(NULL), Window(NULL), MinExposureTime(NULL), MaxExposureTime(NULL), MinGain(NULL), MaxGain(NULL), MinIris(NULL), MaxIris(NULL), ExposureTime(NULL), Gain(NULL), Iris(NULL), soap(NULL) { tt__Exposure20::soap_default(NULL); }
	virtual ~tt__Exposure20() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions20
#define SOAP_TYPE_tt__ImagingOptions20 (357)
/* tt:ImagingOptions20 */
class SOAP_CMAC tt__ImagingOptions20
{
public:
	class tt__BacklightCompensationOptions20 *BacklightCompensation;	/* optional element of type tt:BacklightCompensationOptions20 */
	tt__FloatRange *Brightness;	/* optional element of type tt:FloatRange */
	tt__FloatRange *ColorSaturation;	/* optional element of type tt:FloatRange */
	tt__FloatRange *Contrast;	/* optional element of type tt:FloatRange */
	class tt__ExposureOptions20 *Exposure;	/* optional element of type tt:ExposureOptions20 */
	class tt__FocusOptions20 *Focus;	/* optional element of type tt:FocusOptions20 */
	int __sizeIrCutFilterModes;	/* sequence of elements <IrCutFilterModes> */
	enum tt__IrCutFilterMode *IrCutFilterModes;	/* optional element of type tt:IrCutFilterMode */
	tt__FloatRange *Sharpness;	/* optional element of type tt:FloatRange */
	class tt__WideDynamicRangeOptions20 *WideDynamicRange;	/* optional element of type tt:WideDynamicRangeOptions20 */
	class tt__WhiteBalanceOptions20 *WhiteBalance;	/* optional element of type tt:WhiteBalanceOptions20 */
	class tt__ImagingOptions20Extension *Extension;	/* optional element of type tt:ImagingOptions20Extension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 357; } /* = unique id SOAP_TYPE_tt__ImagingOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingOptions20(): BacklightCompensation(NULL), Brightness(NULL), ColorSaturation(NULL), Contrast(NULL), Exposure(NULL), Focus(NULL), IrCutFilterModes(NULL), Sharpness(NULL), WideDynamicRange(NULL), WhiteBalance(NULL), Extension(NULL), soap(NULL) { tt__ImagingOptions20::soap_default(NULL); }
	virtual ~tt__ImagingOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions20Extension
#define SOAP_TYPE_tt__ImagingOptions20Extension (358)
/* tt:ImagingOptions20Extension */
class SOAP_CMAC tt__ImagingOptions20Extension
{
public:
	class tt__ImageStabilizationOptions *ImageStabilization;	/* optional element of type tt:ImageStabilizationOptions */
	class tt__ImagingOptions20Extension2 *Extension;	/* optional element of type tt:ImagingOptions20Extension2 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 358; } /* = unique id SOAP_TYPE_tt__ImagingOptions20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingOptions20Extension(): ImageStabilization(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__ImagingOptions20Extension::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImagingOptions20Extension2
#define SOAP_TYPE_tt__ImagingOptions20Extension2 (359)
/* tt:ImagingOptions20Extension2 */
class SOAP_CMAC tt__ImagingOptions20Extension2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 359; } /* = unique id SOAP_TYPE_tt__ImagingOptions20Extension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImagingOptions20Extension2(): __any(NULL), soap(NULL) { tt__ImagingOptions20Extension2::soap_default(NULL); }
	virtual ~tt__ImagingOptions20Extension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImageStabilizationOptions
#define SOAP_TYPE_tt__ImageStabilizationOptions (360)
/* tt:ImageStabilizationOptions */
class SOAP_CMAC tt__ImageStabilizationOptions
{
public:
	int __sizeMode;	/* sequence of elements <Mode> */
	enum tt__ImageStabilizationMode *Mode;	/* required element of type tt:ImageStabilizationMode */
	tt__FloatRange *Level;	/* optional element of type tt:FloatRange */
	class tt__ImageStabilizationOptionsExtension *Extension;	/* optional element of type tt:ImageStabilizationOptionsExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 360; } /* = unique id SOAP_TYPE_tt__ImageStabilizationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImageStabilizationOptions(): Mode(NULL), Level(NULL), Extension(NULL), soap(NULL) { tt__ImageStabilizationOptions::soap_default(NULL); }
	virtual ~tt__ImageStabilizationOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__ImageStabilizationOptionsExtension
#define SOAP_TYPE_tt__ImageStabilizationOptionsExtension (361)
/* tt:ImageStabilizationOptionsExtension */
class SOAP_CMAC tt__ImageStabilizationOptionsExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 361; } /* = unique id SOAP_TYPE_tt__ImageStabilizationOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ImageStabilizationOptionsExtension(): __any(NULL), soap(NULL) { tt__ImageStabilizationOptionsExtension::soap_default(NULL); }
	virtual ~tt__ImageStabilizationOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions20
#define SOAP_TYPE_tt__WideDynamicRangeOptions20 (362)
/* tt:WideDynamicRangeOptions20 */
class SOAP_CMAC tt__WideDynamicRangeOptions20
{
public:
	int __sizeMode;	/* sequence of elements <Mode> */
	enum tt__WideDynamicMode *Mode;	/* required element of type tt:WideDynamicMode */
	tt__FloatRange *Level;	/* optional element of type tt:FloatRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 362; } /* = unique id SOAP_TYPE_tt__WideDynamicRangeOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WideDynamicRangeOptions20(): Mode(NULL), Level(NULL), soap(NULL) { tt__WideDynamicRangeOptions20::soap_default(NULL); }
	virtual ~tt__WideDynamicRangeOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__BacklightCompensationOptions20
#define SOAP_TYPE_tt__BacklightCompensationOptions20 (363)
/* tt:BacklightCompensationOptions20 */
class SOAP_CMAC tt__BacklightCompensationOptions20
{
public:
	int __sizeMode;	/* sequence of elements <Mode> */
	enum tt__BacklightCompensationMode *Mode;	/* required element of type tt:BacklightCompensationMode */
	tt__FloatRange *Level;	/* optional element of type tt:FloatRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 363; } /* = unique id SOAP_TYPE_tt__BacklightCompensationOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BacklightCompensationOptions20(): Mode(NULL), Level(NULL), soap(NULL) { tt__BacklightCompensationOptions20::soap_default(NULL); }
	virtual ~tt__BacklightCompensationOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__ExposureOptions20
#define SOAP_TYPE_tt__ExposureOptions20 (364)
/* tt:ExposureOptions20 */
class SOAP_CMAC tt__ExposureOptions20
{
public:
	int __sizeMode;	/* sequence of elements <Mode> */
	enum tt__ExposureMode *Mode;	/* required element of type tt:ExposureMode */
	int __sizePriority;	/* sequence of elements <Priority> */
	enum tt__ExposurePriority *Priority;	/* optional element of type tt:ExposurePriority */
	tt__FloatRange *MinExposureTime;	/* optional element of type tt:FloatRange */
	tt__FloatRange *MaxExposureTime;	/* optional element of type tt:FloatRange */
	tt__FloatRange *MinGain;	/* optional element of type tt:FloatRange */
	tt__FloatRange *MaxGain;	/* optional element of type tt:FloatRange */
	tt__FloatRange *MinIris;	/* optional element of type tt:FloatRange */
	tt__FloatRange *MaxIris;	/* optional element of type tt:FloatRange */
	tt__FloatRange *ExposureTime;	/* optional element of type tt:FloatRange */
	tt__FloatRange *Gain;	/* optional element of type tt:FloatRange */
	tt__FloatRange *Iris;	/* optional element of type tt:FloatRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 364; } /* = unique id SOAP_TYPE_tt__ExposureOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ExposureOptions20(): Mode(NULL), Priority(NULL), MinExposureTime(NULL), MaxExposureTime(NULL), MinGain(NULL), MaxGain(NULL), MinIris(NULL), MaxIris(NULL), ExposureTime(NULL), Gain(NULL), Iris(NULL), soap(NULL) { tt__ExposureOptions20::soap_default(NULL); }
	virtual ~tt__ExposureOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__MoveOptions20
#define SOAP_TYPE_tt__MoveOptions20 (365)
/* tt:MoveOptions20 */
class SOAP_CMAC tt__MoveOptions20
{
public:
	tt__AbsoluteFocusOptions *Absolute;	/* optional element of type tt:AbsoluteFocusOptions */
	class tt__RelativeFocusOptions20 *Relative;	/* optional element of type tt:RelativeFocusOptions20 */
	tt__ContinuousFocusOptions *Continuous;	/* optional element of type tt:ContinuousFocusOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 365; } /* = unique id SOAP_TYPE_tt__MoveOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MoveOptions20(): Absolute(NULL), Relative(NULL), Continuous(NULL), soap(NULL) { tt__MoveOptions20::soap_default(NULL); }
	virtual ~tt__MoveOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelativeFocusOptions20
#define SOAP_TYPE_tt__RelativeFocusOptions20 (366)
/* tt:RelativeFocusOptions20 */
class SOAP_CMAC tt__RelativeFocusOptions20
{
public:
	tt__FloatRange *Distance;	/* required element of type tt:FloatRange */
	tt__FloatRange *Speed;	/* optional element of type tt:FloatRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 366; } /* = unique id SOAP_TYPE_tt__RelativeFocusOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelativeFocusOptions20(): Distance(NULL), Speed(NULL), soap(NULL) { tt__RelativeFocusOptions20::soap_default(NULL); }
	virtual ~tt__RelativeFocusOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalance20
#define SOAP_TYPE_tt__WhiteBalance20 (367)
/* tt:WhiteBalance20 */
class SOAP_CMAC tt__WhiteBalance20
{
public:
	enum tt__WhiteBalanceMode Mode;	/* required element of type tt:WhiteBalanceMode */
	float *CrGain;	/* optional element of type xsd:float */
	float *CbGain;	/* optional element of type xsd:float */
	class tt__WhiteBalance20Extension *Extension;	/* optional element of type tt:WhiteBalance20Extension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 367; } /* = unique id SOAP_TYPE_tt__WhiteBalance20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalance20(): CrGain(NULL), CbGain(NULL), Extension(NULL), soap(NULL) { tt__WhiteBalance20::soap_default(NULL); }
	virtual ~tt__WhiteBalance20() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalance20Extension
#define SOAP_TYPE_tt__WhiteBalance20Extension (368)
/* tt:WhiteBalance20Extension */
class SOAP_CMAC tt__WhiteBalance20Extension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 368; } /* = unique id SOAP_TYPE_tt__WhiteBalance20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalance20Extension(): __any(NULL), soap(NULL) { tt__WhiteBalance20Extension::soap_default(NULL); }
	virtual ~tt__WhiteBalance20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusConfiguration20
#define SOAP_TYPE_tt__FocusConfiguration20 (369)
/* tt:FocusConfiguration20 */
class SOAP_CMAC tt__FocusConfiguration20
{
public:
	enum tt__AutoFocusMode AutoFocusMode;	/* required element of type tt:AutoFocusMode */
	float *DefaultSpeed;	/* optional element of type xsd:float */
	float *NearLimit;	/* optional element of type xsd:float */
	float *FarLimit;	/* optional element of type xsd:float */
	class tt__FocusConfiguration20Extension *Extension;	/* optional element of type tt:FocusConfiguration20Extension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 369; } /* = unique id SOAP_TYPE_tt__FocusConfiguration20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusConfiguration20(): DefaultSpeed(NULL), NearLimit(NULL), FarLimit(NULL), Extension(NULL), soap(NULL) { tt__FocusConfiguration20::soap_default(NULL); }
	virtual ~tt__FocusConfiguration20() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusConfiguration20Extension
#define SOAP_TYPE_tt__FocusConfiguration20Extension (370)
/* tt:FocusConfiguration20Extension */
class SOAP_CMAC tt__FocusConfiguration20Extension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 370; } /* = unique id SOAP_TYPE_tt__FocusConfiguration20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusConfiguration20Extension(): __any(NULL), soap(NULL) { tt__FocusConfiguration20Extension::soap_default(NULL); }
	virtual ~tt__FocusConfiguration20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20
#define SOAP_TYPE_tt__WhiteBalanceOptions20 (371)
/* tt:WhiteBalanceOptions20 */
class SOAP_CMAC tt__WhiteBalanceOptions20
{
public:
	int __sizeMode;	/* sequence of elements <Mode> */
	enum tt__WhiteBalanceMode *Mode;	/* required element of type tt:WhiteBalanceMode */
	tt__FloatRange *YrGain;	/* optional element of type tt:FloatRange */
	tt__FloatRange *YbGain;	/* optional element of type tt:FloatRange */
	class tt__WhiteBalanceOptions20Extension *Extension;	/* optional element of type tt:WhiteBalanceOptions20Extension */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 371; } /* = unique id SOAP_TYPE_tt__WhiteBalanceOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalanceOptions20(): Mode(NULL), YrGain(NULL), YbGain(NULL), Extension(NULL), soap(NULL) { tt__WhiteBalanceOptions20::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20Extension
#define SOAP_TYPE_tt__WhiteBalanceOptions20Extension (372)
/* tt:WhiteBalanceOptions20Extension */
class SOAP_CMAC tt__WhiteBalanceOptions20Extension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 372; } /* = unique id SOAP_TYPE_tt__WhiteBalanceOptions20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__WhiteBalanceOptions20Extension(): __any(NULL), soap(NULL) { tt__WhiteBalanceOptions20Extension::soap_default(NULL); }
	virtual ~tt__WhiteBalanceOptions20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusOptions20
#define SOAP_TYPE_tt__FocusOptions20 (373)
/* tt:FocusOptions20 */
class SOAP_CMAC tt__FocusOptions20
{
public:
	int __sizeAutoFocusModes;	/* sequence of elements <AutoFocusModes> */
	enum tt__AutoFocusMode *AutoFocusModes;	/* optional element of type tt:AutoFocusMode */
	tt__FloatRange *DefaultSpeed;	/* optional element of type tt:FloatRange */
	tt__FloatRange *NearLimit;	/* optional element of type tt:FloatRange */
	tt__FloatRange *FarLimit;	/* optional element of type tt:FloatRange */
	class tt__FocusOptions20Extension *Extension;	/* optional element of type tt:FocusOptions20Extension */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 373; } /* = unique id SOAP_TYPE_tt__FocusOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusOptions20(): AutoFocusModes(NULL), DefaultSpeed(NULL), NearLimit(NULL), FarLimit(NULL), Extension(NULL), soap(NULL) { tt__FocusOptions20::soap_default(NULL); }
	virtual ~tt__FocusOptions20() { }
};
#endif

#ifndef SOAP_TYPE_tt__FocusOptions20Extension
#define SOAP_TYPE_tt__FocusOptions20Extension (374)
/* tt:FocusOptions20Extension */
class SOAP_CMAC tt__FocusOptions20Extension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 374; } /* = unique id SOAP_TYPE_tt__FocusOptions20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FocusOptions20Extension(): __any(NULL), soap(NULL) { tt__FocusOptions20Extension::soap_default(NULL); }
	virtual ~tt__FocusOptions20Extension() { }
};
#endif

#ifndef SOAP_TYPE_tt__MessageExtension
#define SOAP_TYPE_tt__MessageExtension (375)
/* tt:MessageExtension */
class SOAP_CMAC tt__MessageExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 375; } /* = unique id SOAP_TYPE_tt__MessageExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MessageExtension(): __any(NULL), soap(NULL) { tt__MessageExtension::soap_default(NULL); }
	virtual ~tt__MessageExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__ItemList_SimpleItem
#define SOAP_TYPE__tt__ItemList_SimpleItem (940)
/* tt:ItemList-SimpleItem */
class SOAP_CMAC _tt__ItemList_SimpleItem
{
public:
	char *Name;	/* required attribute */
	char *Value;	/* required attribute */
public:
	virtual int soap_type() const { return 940; } /* = unique id SOAP_TYPE__tt__ItemList_SimpleItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ItemList_SimpleItem(): Name(NULL), Value(NULL) { _tt__ItemList_SimpleItem::soap_default(NULL); }
	virtual ~_tt__ItemList_SimpleItem() { }
};
#endif

#ifndef SOAP_TYPE__tt__ItemList_ElementItem
#define SOAP_TYPE__tt__ItemList_ElementItem (942)
/* tt:ItemList-ElementItem */
class SOAP_CMAC _tt__ItemList_ElementItem
{
public:
	struct soap_dom_element __any;	/* external */
	char *Name;	/* required attribute */
public:
	virtual int soap_type() const { return 942; } /* = unique id SOAP_TYPE__tt__ItemList_ElementItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ItemList_ElementItem(): Name(NULL) { _tt__ItemList_ElementItem::soap_default(NULL); }
	virtual ~_tt__ItemList_ElementItem() { }
};
#endif

#ifndef SOAP_TYPE_tt__ItemList
#define SOAP_TYPE_tt__ItemList (376)
/* tt:ItemList */
class SOAP_CMAC tt__ItemList
{
public:
	int __sizeSimpleItem;	/* sequence of elements <SimpleItem> */
	_tt__ItemList_SimpleItem *SimpleItem;	/* optional element of type tt:ItemList-SimpleItem */
	int __sizeElementItem;	/* sequence of elements <ElementItem> */
	_tt__ItemList_ElementItem *ElementItem;	/* optional element of type tt:ItemList-ElementItem */
	class tt__ItemListExtension *Extension;	/* optional element of type tt:ItemListExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 376; } /* = unique id SOAP_TYPE_tt__ItemList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ItemList(): SimpleItem(NULL), ElementItem(NULL), Extension(NULL), soap(NULL) { tt__ItemList::soap_default(NULL); }
	virtual ~tt__ItemList() { }
};
#endif

#ifndef SOAP_TYPE_tt__ItemListExtension
#define SOAP_TYPE_tt__ItemListExtension (377)
/* tt:ItemListExtension */
class SOAP_CMAC tt__ItemListExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 377; } /* = unique id SOAP_TYPE_tt__ItemListExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ItemListExtension(): __any(NULL), soap(NULL) { tt__ItemListExtension::soap_default(NULL); }
	virtual ~tt__ItemListExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__MessageDescription
#define SOAP_TYPE_tt__MessageDescription (378)
/* tt:MessageDescription */
class SOAP_CMAC tt__MessageDescription
{
public:
	class tt__ItemListDescription *Source;	/* optional element of type tt:ItemListDescription */
	tt__ItemListDescription *Key;	/* optional element of type tt:ItemListDescription */
	tt__ItemListDescription *Data;	/* optional element of type tt:ItemListDescription */
	class tt__MessageDescriptionExtension *Extension;	/* optional element of type tt:MessageDescriptionExtension */
	bool *IsProperty;	/* optional attribute */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 378; } /* = unique id SOAP_TYPE_tt__MessageDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MessageDescription(): Source(NULL), Key(NULL), Data(NULL), Extension(NULL), IsProperty(NULL), soap(NULL) { tt__MessageDescription::soap_default(NULL); }
	virtual ~tt__MessageDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__MessageDescriptionExtension
#define SOAP_TYPE_tt__MessageDescriptionExtension (379)
/* tt:MessageDescriptionExtension */
class SOAP_CMAC tt__MessageDescriptionExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 379; } /* = unique id SOAP_TYPE_tt__MessageDescriptionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MessageDescriptionExtension(): __any(NULL), soap(NULL) { tt__MessageDescriptionExtension::soap_default(NULL); }
	virtual ~tt__MessageDescriptionExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription
#define SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription (947)
/* tt:ItemListDescription-SimpleItemDescription */
class SOAP_CMAC _tt__ItemListDescription_SimpleItemDescription
{
public:
	char *Name;	/* required attribute */
	char *Type;	/* required attribute */
public:
	virtual int soap_type() const { return 947; } /* = unique id SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ItemListDescription_SimpleItemDescription(): Name(NULL), Type(NULL) { _tt__ItemListDescription_SimpleItemDescription::soap_default(NULL); }
	virtual ~_tt__ItemListDescription_SimpleItemDescription() { }
};
#endif

#ifndef SOAP_TYPE__tt__ItemListDescription_ElementItemDescription
#define SOAP_TYPE__tt__ItemListDescription_ElementItemDescription (949)
/* tt:ItemListDescription-ElementItemDescription */
class SOAP_CMAC _tt__ItemListDescription_ElementItemDescription
{
public:
	char *Name;	/* required attribute */
	char *Type;	/* required attribute */
public:
	virtual int soap_type() const { return 949; } /* = unique id SOAP_TYPE__tt__ItemListDescription_ElementItemDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ItemListDescription_ElementItemDescription(): Name(NULL), Type(NULL) { _tt__ItemListDescription_ElementItemDescription::soap_default(NULL); }
	virtual ~_tt__ItemListDescription_ElementItemDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__ItemListDescription
#define SOAP_TYPE_tt__ItemListDescription (380)
/* tt:ItemListDescription */
class SOAP_CMAC tt__ItemListDescription
{
public:
	int __sizeSimpleItemDescription;	/* sequence of elements <SimpleItemDescription> */
	_tt__ItemListDescription_SimpleItemDescription *SimpleItemDescription;	/* optional element of type tt:ItemListDescription-SimpleItemDescription */
	int __sizeElementItemDescription;	/* sequence of elements <ElementItemDescription> */
	_tt__ItemListDescription_ElementItemDescription *ElementItemDescription;	/* optional element of type tt:ItemListDescription-ElementItemDescription */
	class tt__ItemListDescriptionExtension *Extension;	/* optional element of type tt:ItemListDescriptionExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 380; } /* = unique id SOAP_TYPE_tt__ItemListDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ItemListDescription(): SimpleItemDescription(NULL), ElementItemDescription(NULL), Extension(NULL), soap(NULL) { tt__ItemListDescription::soap_default(NULL); }
	virtual ~tt__ItemListDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__ItemListDescriptionExtension
#define SOAP_TYPE_tt__ItemListDescriptionExtension (381)
/* tt:ItemListDescriptionExtension */
class SOAP_CMAC tt__ItemListDescriptionExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 381; } /* = unique id SOAP_TYPE_tt__ItemListDescriptionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ItemListDescriptionExtension(): __any(NULL), soap(NULL) { tt__ItemListDescriptionExtension::soap_default(NULL); }
	virtual ~tt__ItemListDescriptionExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Vector
#define SOAP_TYPE_tt__Vector (382)
/* tt:Vector */
class SOAP_CMAC tt__Vector
{
public:
	float *x;	/* optional attribute */
	float *y;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 382; } /* = unique id SOAP_TYPE_tt__Vector */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Vector(): x(NULL), y(NULL), soap(NULL) { tt__Vector::soap_default(NULL); }
	virtual ~tt__Vector() { }
};
#endif

#ifndef SOAP_TYPE_tt__Rectangle
#define SOAP_TYPE_tt__Rectangle (383)
/* tt:Rectangle */
class SOAP_CMAC tt__Rectangle
{
public:
	float *bottom;	/* optional attribute */
	float *top;	/* optional attribute */
	float *right;	/* optional attribute */
	float *left;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 383; } /* = unique id SOAP_TYPE_tt__Rectangle */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Rectangle(): bottom(NULL), top(NULL), right(NULL), left(NULL), soap(NULL) { tt__Rectangle::soap_default(NULL); }
	virtual ~tt__Rectangle() { }
};
#endif

#ifndef SOAP_TYPE_tt__Polygon
#define SOAP_TYPE_tt__Polygon (384)
/* tt:Polygon */
class SOAP_CMAC tt__Polygon
{
public:
	int __sizePoint;	/* sequence of elements <Point> */
	tt__Vector **Point;	/* required element of type tt:Vector */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 384; } /* = unique id SOAP_TYPE_tt__Polygon */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Polygon(): Point(NULL), soap(NULL) { tt__Polygon::soap_default(NULL); }
	virtual ~tt__Polygon() { }
};
#endif

#ifndef SOAP_TYPE_tt__Polyline
#define SOAP_TYPE_tt__Polyline (385)
/* tt:Polyline */
class SOAP_CMAC tt__Polyline
{
public:
	int __sizePoint;	/* sequence of elements <Point> */
	tt__Vector **Point;	/* required element of type tt:Vector */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 385; } /* = unique id SOAP_TYPE_tt__Polyline */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Polyline(): Point(NULL), soap(NULL) { tt__Polyline::soap_default(NULL); }
	virtual ~tt__Polyline() { }
};
#endif

#ifndef SOAP_TYPE_tt__Color
#define SOAP_TYPE_tt__Color (386)
/* tt:Color */
class SOAP_CMAC tt__Color
{
public:
	float X;	/* required attribute */
	float Y;	/* required attribute */
	float Z;	/* required attribute */
	char *Colorspace;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 386; } /* = unique id SOAP_TYPE_tt__Color */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Color(): Colorspace(NULL), soap(NULL) { tt__Color::soap_default(NULL); }
	virtual ~tt__Color() { }
};
#endif

#ifndef SOAP_TYPE_tt__ColorCovariance
#define SOAP_TYPE_tt__ColorCovariance (387)
/* tt:ColorCovariance */
class SOAP_CMAC tt__ColorCovariance
{
public:
	float XX;	/* required attribute */
	float YY;	/* required attribute */
	float ZZ;	/* required attribute */
	float *XY;	/* optional attribute */
	float *XZ;	/* optional attribute */
	float *YZ;	/* optional attribute */
	char *Colorspace;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 387; } /* = unique id SOAP_TYPE_tt__ColorCovariance */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ColorCovariance(): XY(NULL), XZ(NULL), YZ(NULL), Colorspace(NULL), soap(NULL) { tt__ColorCovariance::soap_default(NULL); }
	virtual ~tt__ColorCovariance() { }
};
#endif

#ifndef SOAP_TYPE_tt__Appearance
#define SOAP_TYPE_tt__Appearance (388)
/* tt:Appearance */
class SOAP_CMAC tt__Appearance
{
public:
	class tt__Transformation *Transformation;	/* optional element of type tt:Transformation */
	class tt__ShapeDescriptor *Shape;	/* optional element of type tt:ShapeDescriptor */
	class tt__ColorDescriptor *Color;	/* optional element of type tt:ColorDescriptor */
	class tt__ClassDescriptor *Class;	/* optional element of type tt:ClassDescriptor */
	class tt__AppearanceExtension *Extension;	/* optional element of type tt:AppearanceExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 388; } /* = unique id SOAP_TYPE_tt__Appearance */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Appearance(): Transformation(NULL), Shape(NULL), Color(NULL), Class(NULL), Extension(NULL), soap(NULL) { tt__Appearance::soap_default(NULL); }
	virtual ~tt__Appearance() { }
};
#endif

#ifndef SOAP_TYPE_tt__AppearanceExtension
#define SOAP_TYPE_tt__AppearanceExtension (389)
/* tt:AppearanceExtension */
class SOAP_CMAC tt__AppearanceExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 389; } /* = unique id SOAP_TYPE_tt__AppearanceExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AppearanceExtension(): __any(NULL), soap(NULL) { tt__AppearanceExtension::soap_default(NULL); }
	virtual ~tt__AppearanceExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ShapeDescriptor
#define SOAP_TYPE_tt__ShapeDescriptor (390)
/* tt:ShapeDescriptor */
class SOAP_CMAC tt__ShapeDescriptor
{
public:
	tt__Rectangle *BoundingBox;	/* required element of type tt:Rectangle */
	tt__Vector *CenterOfGravity;	/* required element of type tt:Vector */
	int __sizePolygon;	/* sequence of elements <Polygon> */
	tt__Polygon **Polygon;	/* optional element of type tt:Polygon */
	class tt__ShapeDescriptorExtension *Extension;	/* optional element of type tt:ShapeDescriptorExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 390; } /* = unique id SOAP_TYPE_tt__ShapeDescriptor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ShapeDescriptor(): BoundingBox(NULL), CenterOfGravity(NULL), Polygon(NULL), Extension(NULL), soap(NULL) { tt__ShapeDescriptor::soap_default(NULL); }
	virtual ~tt__ShapeDescriptor() { }
};
#endif

#ifndef SOAP_TYPE_tt__ShapeDescriptorExtension
#define SOAP_TYPE_tt__ShapeDescriptorExtension (391)
/* tt:ShapeDescriptorExtension */
class SOAP_CMAC tt__ShapeDescriptorExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 391; } /* = unique id SOAP_TYPE_tt__ShapeDescriptorExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ShapeDescriptorExtension(): __any(NULL), soap(NULL) { tt__ShapeDescriptorExtension::soap_default(NULL); }
	virtual ~tt__ShapeDescriptorExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__ColorDescriptor_ColorCluster
#define SOAP_TYPE__tt__ColorDescriptor_ColorCluster (962)
/* tt:ColorDescriptor-ColorCluster */
class SOAP_CMAC _tt__ColorDescriptor_ColorCluster
{
public:
	tt__Color *Color;	/* required element of type tt:Color */
	float *Weight;	/* optional element of type xsd:float */
	tt__ColorCovariance *Covariance;	/* optional element of type tt:ColorCovariance */
public:
	virtual int soap_type() const { return 962; } /* = unique id SOAP_TYPE__tt__ColorDescriptor_ColorCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ColorDescriptor_ColorCluster(): Color(NULL), Weight(NULL), Covariance(NULL) { _tt__ColorDescriptor_ColorCluster::soap_default(NULL); }
	virtual ~_tt__ColorDescriptor_ColorCluster() { }
};
#endif

#ifndef SOAP_TYPE_tt__ColorDescriptor
#define SOAP_TYPE_tt__ColorDescriptor (392)
/* tt:ColorDescriptor */
class SOAP_CMAC tt__ColorDescriptor
{
public:
	int __sizeColorCluster;	/* sequence of elements <ColorCluster> */
	_tt__ColorDescriptor_ColorCluster *ColorCluster;	/* optional element of type tt:ColorDescriptor-ColorCluster */
	class tt__ColorDescriptorExtension *Extension;	/* optional element of type tt:ColorDescriptorExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 392; } /* = unique id SOAP_TYPE_tt__ColorDescriptor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ColorDescriptor(): ColorCluster(NULL), Extension(NULL), soap(NULL) { tt__ColorDescriptor::soap_default(NULL); }
	virtual ~tt__ColorDescriptor() { }
};
#endif

#ifndef SOAP_TYPE_tt__ColorDescriptorExtension
#define SOAP_TYPE_tt__ColorDescriptorExtension (393)
/* tt:ColorDescriptorExtension */
class SOAP_CMAC tt__ColorDescriptorExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 393; } /* = unique id SOAP_TYPE_tt__ColorDescriptorExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ColorDescriptorExtension(): __any(NULL), soap(NULL) { tt__ColorDescriptorExtension::soap_default(NULL); }
	virtual ~tt__ColorDescriptorExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__ClassDescriptor_ClassCandidate
#define SOAP_TYPE__tt__ClassDescriptor_ClassCandidate (967)
/* tt:ClassDescriptor-ClassCandidate */
class SOAP_CMAC _tt__ClassDescriptor_ClassCandidate
{
public:
	enum tt__ClassType Type;	/* required element of type tt:ClassType */
	float Likelihood;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 967; } /* = unique id SOAP_TYPE__tt__ClassDescriptor_ClassCandidate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ClassDescriptor_ClassCandidate() { _tt__ClassDescriptor_ClassCandidate::soap_default(NULL); }
	virtual ~_tt__ClassDescriptor_ClassCandidate() { }
};
#endif

#ifndef SOAP_TYPE_tt__ClassDescriptor
#define SOAP_TYPE_tt__ClassDescriptor (394)
/* tt:ClassDescriptor */
class SOAP_CMAC tt__ClassDescriptor
{
public:
	int __sizeClassCandidate;	/* sequence of elements <ClassCandidate> */
	_tt__ClassDescriptor_ClassCandidate *ClassCandidate;	/* optional element of type tt:ClassDescriptor-ClassCandidate */
	class tt__ClassDescriptorExtension *Extension;	/* optional element of type tt:ClassDescriptorExtension */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 394; } /* = unique id SOAP_TYPE_tt__ClassDescriptor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ClassDescriptor(): ClassCandidate(NULL), Extension(NULL), soap(NULL) { tt__ClassDescriptor::soap_default(NULL); }
	virtual ~tt__ClassDescriptor() { }
};
#endif

#ifndef SOAP_TYPE_tt__ClassDescriptorExtension
#define SOAP_TYPE_tt__ClassDescriptorExtension (395)
/* tt:ClassDescriptorExtension */
class SOAP_CMAC tt__ClassDescriptorExtension
{
public:
	int __sizeOtherTypes;	/* sequence of elements <OtherTypes> */
	class tt__OtherType **OtherTypes;	/* required element of type tt:OtherType */
	class tt__ClassDescriptorExtension2 *Extension;	/* optional element of type tt:ClassDescriptorExtension2 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 395; } /* = unique id SOAP_TYPE_tt__ClassDescriptorExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ClassDescriptorExtension(): OtherTypes(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__ClassDescriptorExtension::soap_default(NULL); }
	virtual ~tt__ClassDescriptorExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ClassDescriptorExtension2
#define SOAP_TYPE_tt__ClassDescriptorExtension2 (396)
/* tt:ClassDescriptorExtension2 */
class SOAP_CMAC tt__ClassDescriptorExtension2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 396; } /* = unique id SOAP_TYPE_tt__ClassDescriptorExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ClassDescriptorExtension2(): __any(NULL), soap(NULL) { tt__ClassDescriptorExtension2::soap_default(NULL); }
	virtual ~tt__ClassDescriptorExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__OtherType
#define SOAP_TYPE_tt__OtherType (397)
/* tt:OtherType */
class SOAP_CMAC tt__OtherType
{
public:
	char *Type;	/* required element of type xsd:string */
	float Likelihood;	/* required element of type xsd:float */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 397; } /* = unique id SOAP_TYPE_tt__OtherType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__OtherType(): Type(NULL), __any(NULL), soap(NULL) { tt__OtherType::soap_default(NULL); }
	virtual ~tt__OtherType() { }
};
#endif

#ifndef SOAP_TYPE_tt__ObjectExtension
#define SOAP_TYPE_tt__ObjectExtension (399)
/* tt:ObjectExtension */
class SOAP_CMAC tt__ObjectExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 399; } /* = unique id SOAP_TYPE_tt__ObjectExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ObjectExtension(): __any(NULL), soap(NULL) { tt__ObjectExtension::soap_default(NULL); }
	virtual ~tt__ObjectExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Transformation
#define SOAP_TYPE_tt__Transformation (400)
/* tt:Transformation */
class SOAP_CMAC tt__Transformation
{
public:
	tt__Vector *Translate;	/* optional element of type tt:Vector */
	tt__Vector *Scale;	/* optional element of type tt:Vector */
	class tt__TransformationExtension *Extension;	/* optional element of type tt:TransformationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 400; } /* = unique id SOAP_TYPE_tt__Transformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Transformation(): Translate(NULL), Scale(NULL), Extension(NULL), soap(NULL) { tt__Transformation::soap_default(NULL); }
	virtual ~tt__Transformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__TransformationExtension
#define SOAP_TYPE_tt__TransformationExtension (401)
/* tt:TransformationExtension */
class SOAP_CMAC tt__TransformationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 401; } /* = unique id SOAP_TYPE_tt__TransformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TransformationExtension(): __any(NULL), soap(NULL) { tt__TransformationExtension::soap_default(NULL); }
	virtual ~tt__TransformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Frame
#define SOAP_TYPE_tt__Frame (402)
/* tt:Frame */
class SOAP_CMAC tt__Frame
{
public:
	tt__PTZStatus *PTZStatus;	/* optional element of type tt:PTZStatus */
	tt__Transformation *Transformation;	/* optional element of type tt:Transformation */
	int __sizeObject;	/* sequence of elements <Object> */
	class tt__Object **Object;	/* optional element of type tt:Object */
	class tt__ObjectTree *ObjectTree;	/* optional element of type tt:ObjectTree */
	class tt__FrameExtension *Extension;	/* optional element of type tt:FrameExtension */
	time_t UtcTime;	/* required attribute */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 402; } /* = unique id SOAP_TYPE_tt__Frame */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Frame(): PTZStatus(NULL), Transformation(NULL), Object(NULL), ObjectTree(NULL), Extension(NULL), soap(NULL) { tt__Frame::soap_default(NULL); }
	virtual ~tt__Frame() { }
};
#endif

#ifndef SOAP_TYPE_tt__FrameExtension
#define SOAP_TYPE_tt__FrameExtension (403)
/* tt:FrameExtension */
class SOAP_CMAC tt__FrameExtension
{
public:
	class tt__MotionInCells *MotionInCells;	/* optional element of type tt:MotionInCells */
	class tt__FrameExtension2 *Extension;	/* optional element of type tt:FrameExtension2 */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 403; } /* = unique id SOAP_TYPE_tt__FrameExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FrameExtension(): MotionInCells(NULL), Extension(NULL), __any(NULL), soap(NULL) { tt__FrameExtension::soap_default(NULL); }
	virtual ~tt__FrameExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__FrameExtension2
#define SOAP_TYPE_tt__FrameExtension2 (404)
/* tt:FrameExtension2 */
class SOAP_CMAC tt__FrameExtension2
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 404; } /* = unique id SOAP_TYPE_tt__FrameExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FrameExtension2(): __any(NULL), soap(NULL) { tt__FrameExtension2::soap_default(NULL); }
	virtual ~tt__FrameExtension2() { }
};
#endif

#ifndef SOAP_TYPE_tt__Merge
#define SOAP_TYPE_tt__Merge (405)
/* tt:Merge */
class SOAP_CMAC tt__Merge
{
public:
	int __sizefrom;	/* sequence of elements <from> */
	class tt__ObjectId **from;	/* required element of type tt:ObjectId */
	tt__ObjectId *to;	/* required element of type tt:ObjectId */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 405; } /* = unique id SOAP_TYPE_tt__Merge */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Merge(): from(NULL), to(NULL), soap(NULL) { tt__Merge::soap_default(NULL); }
	virtual ~tt__Merge() { }
};
#endif

#ifndef SOAP_TYPE_tt__Split
#define SOAP_TYPE_tt__Split (406)
/* tt:Split */
class SOAP_CMAC tt__Split
{
public:
	tt__ObjectId *from;	/* required element of type tt:ObjectId */
	int __sizeto;	/* sequence of elements <to> */
	tt__ObjectId **to;	/* required element of type tt:ObjectId */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 406; } /* = unique id SOAP_TYPE_tt__Split */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Split(): from(NULL), to(NULL), soap(NULL) { tt__Split::soap_default(NULL); }
	virtual ~tt__Split() { }
};
#endif

#ifndef SOAP_TYPE_tt__Rename
#define SOAP_TYPE_tt__Rename (407)
/* tt:Rename */
class SOAP_CMAC tt__Rename
{
public:
	tt__ObjectId *from;	/* required element of type tt:ObjectId */
	tt__ObjectId *to;	/* required element of type tt:ObjectId */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 407; } /* = unique id SOAP_TYPE_tt__Rename */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Rename(): from(NULL), to(NULL), soap(NULL) { tt__Rename::soap_default(NULL); }
	virtual ~tt__Rename() { }
};
#endif

#ifndef SOAP_TYPE_tt__ObjectId
#define SOAP_TYPE_tt__ObjectId (408)
/* tt:ObjectId */
class SOAP_CMAC tt__ObjectId
{
public:
	char *ObjectId;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 408; } /* = unique id SOAP_TYPE_tt__ObjectId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ObjectId(): ObjectId(NULL), soap(NULL) { tt__ObjectId::soap_default(NULL); }
	virtual ~tt__ObjectId() { }
};
#endif

#ifndef SOAP_TYPE__tt__Behaviour_Removed
#define SOAP_TYPE__tt__Behaviour_Removed (982)
/* tt:Behaviour-Removed */
class SOAP_CMAC _tt__Behaviour_Removed
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
public:
	virtual int soap_type() const { return 982; } /* = unique id SOAP_TYPE__tt__Behaviour_Removed */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__Behaviour_Removed(): __any(NULL) { _tt__Behaviour_Removed::soap_default(NULL); }
	virtual ~_tt__Behaviour_Removed() { }
};
#endif

#ifndef SOAP_TYPE__tt__Behaviour_Idle
#define SOAP_TYPE__tt__Behaviour_Idle (984)
/* tt:Behaviour-Idle */
class SOAP_CMAC _tt__Behaviour_Idle
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
public:
	virtual int soap_type() const { return 984; } /* = unique id SOAP_TYPE__tt__Behaviour_Idle */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__Behaviour_Idle(): __any(NULL) { _tt__Behaviour_Idle::soap_default(NULL); }
	virtual ~_tt__Behaviour_Idle() { }
};
#endif

#ifndef SOAP_TYPE_tt__Behaviour
#define SOAP_TYPE_tt__Behaviour (409)
/* tt:Behaviour */
class SOAP_CMAC tt__Behaviour
{
public:
	_tt__Behaviour_Removed *Removed;	/* optional element of type tt:Behaviour-Removed */
	_tt__Behaviour_Idle *Idle;	/* optional element of type tt:Behaviour-Idle */
	class tt__BehaviourExtension *Extension;	/* optional element of type tt:BehaviourExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 409; } /* = unique id SOAP_TYPE_tt__Behaviour */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Behaviour(): Removed(NULL), Idle(NULL), Extension(NULL), soap(NULL) { tt__Behaviour::soap_default(NULL); }
	virtual ~tt__Behaviour() { }
};
#endif

#ifndef SOAP_TYPE_tt__BehaviourExtension
#define SOAP_TYPE_tt__BehaviourExtension (410)
/* tt:BehaviourExtension */
class SOAP_CMAC tt__BehaviourExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 410; } /* = unique id SOAP_TYPE_tt__BehaviourExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__BehaviourExtension(): __any(NULL), soap(NULL) { tt__BehaviourExtension::soap_default(NULL); }
	virtual ~tt__BehaviourExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__ObjectTree
#define SOAP_TYPE_tt__ObjectTree (411)
/* tt:ObjectTree */
class SOAP_CMAC tt__ObjectTree
{
public:
	int __sizeRename;	/* sequence of elements <Rename> */
	tt__Rename **Rename;	/* optional element of type tt:Rename */
	int __sizeSplit;	/* sequence of elements <Split> */
	tt__Split **Split;	/* optional element of type tt:Split */
	int __sizeMerge;	/* sequence of elements <Merge> */
	tt__Merge **Merge;	/* optional element of type tt:Merge */
	int __sizeDelete;	/* sequence of elements <Delete> */
	tt__ObjectId **Delete;	/* optional element of type tt:ObjectId */
	class tt__ObjectTreeExtension *Extension;	/* optional element of type tt:ObjectTreeExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 411; } /* = unique id SOAP_TYPE_tt__ObjectTree */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ObjectTree(): Rename(NULL), Split(NULL), Merge(NULL), Delete(NULL), Extension(NULL), soap(NULL) { tt__ObjectTree::soap_default(NULL); }
	virtual ~tt__ObjectTree() { }
};
#endif

#ifndef SOAP_TYPE_tt__ObjectTreeExtension
#define SOAP_TYPE_tt__ObjectTreeExtension (412)
/* tt:ObjectTreeExtension */
class SOAP_CMAC tt__ObjectTreeExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 412; } /* = unique id SOAP_TYPE_tt__ObjectTreeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ObjectTreeExtension(): __any(NULL), soap(NULL) { tt__ObjectTreeExtension::soap_default(NULL); }
	virtual ~tt__ObjectTreeExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__MotionInCells
#define SOAP_TYPE_tt__MotionInCells (413)
/* tt:MotionInCells */
class SOAP_CMAC tt__MotionInCells
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	char *Columns;	/* required attribute */
	char *Rows;	/* required attribute */
	xsd__base64Binary Cells;	/* required attribute */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 413; } /* = unique id SOAP_TYPE_tt__MotionInCells */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MotionInCells(): __any(NULL), Columns(NULL), Rows(NULL), soap(NULL) { tt__MotionInCells::soap_default(NULL); }
	virtual ~tt__MotionInCells() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsEngineConfiguration (414)
/* tt:AnalyticsEngineConfiguration */
class SOAP_CMAC tt__AnalyticsEngineConfiguration
{
public:
	int __sizeAnalyticsModule;	/* sequence of elements <AnalyticsModule> */
	class tt__Config **AnalyticsModule;	/* optional element of type tt:Config */
	class tt__AnalyticsEngineConfigurationExtension *Extension;	/* optional element of type tt:AnalyticsEngineConfigurationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 414; } /* = unique id SOAP_TYPE_tt__AnalyticsEngineConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsEngineConfiguration(): AnalyticsModule(NULL), Extension(NULL), soap(NULL) { tt__AnalyticsEngineConfiguration::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension (415)
/* tt:AnalyticsEngineConfigurationExtension */
class SOAP_CMAC tt__AnalyticsEngineConfigurationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 415; } /* = unique id SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsEngineConfigurationExtension(): __any(NULL), soap(NULL) { tt__AnalyticsEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__RuleEngineConfiguration
#define SOAP_TYPE_tt__RuleEngineConfiguration (416)
/* tt:RuleEngineConfiguration */
class SOAP_CMAC tt__RuleEngineConfiguration
{
public:
	int __sizeRule;	/* sequence of elements <Rule> */
	tt__Config **Rule;	/* optional element of type tt:Config */
	class tt__RuleEngineConfigurationExtension *Extension;	/* optional element of type tt:RuleEngineConfigurationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 416; } /* = unique id SOAP_TYPE_tt__RuleEngineConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RuleEngineConfiguration(): Rule(NULL), Extension(NULL), soap(NULL) { tt__RuleEngineConfiguration::soap_default(NULL); }
	virtual ~tt__RuleEngineConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__RuleEngineConfigurationExtension
#define SOAP_TYPE_tt__RuleEngineConfigurationExtension (417)
/* tt:RuleEngineConfigurationExtension */
class SOAP_CMAC tt__RuleEngineConfigurationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 417; } /* = unique id SOAP_TYPE_tt__RuleEngineConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RuleEngineConfigurationExtension(): __any(NULL), soap(NULL) { tt__RuleEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__RuleEngineConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Config
#define SOAP_TYPE_tt__Config (418)
/* tt:Config */
class SOAP_CMAC tt__Config
{
public:
	tt__ItemList *Parameters;	/* required element of type tt:ItemList */
	char *Name;	/* required attribute */
	char *Type;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 418; } /* = unique id SOAP_TYPE_tt__Config */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Config(): Parameters(NULL), Name(NULL), Type(NULL), soap(NULL) { tt__Config::soap_default(NULL); }
	virtual ~tt__Config() { }
};
#endif

#ifndef SOAP_TYPE__tt__ConfigDescription_Messages
#define SOAP_TYPE__tt__ConfigDescription_Messages (999)
/* tt:ConfigDescription-Messages */
class SOAP_CMAC _tt__ConfigDescription_Messages
{
public:
	tt__ItemListDescription *Source;	/* optional element of type tt:ItemListDescription */
	tt__ItemListDescription *Key;	/* optional element of type tt:ItemListDescription */
	tt__ItemListDescription *Data;	/* optional element of type tt:ItemListDescription */
	tt__MessageDescriptionExtension *Extension;	/* optional element of type tt:MessageDescriptionExtension */
	bool *IsProperty;	/* optional attribute */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	char *ParentTopic;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 999; } /* = unique id SOAP_TYPE__tt__ConfigDescription_Messages */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__ConfigDescription_Messages(): Source(NULL), Key(NULL), Data(NULL), Extension(NULL), IsProperty(NULL), ParentTopic(NULL) { _tt__ConfigDescription_Messages::soap_default(NULL); }
	virtual ~_tt__ConfigDescription_Messages() { }
};
#endif

#ifndef SOAP_TYPE_tt__ConfigDescription
#define SOAP_TYPE_tt__ConfigDescription (419)
/* tt:ConfigDescription */
class SOAP_CMAC tt__ConfigDescription
{
public:
	tt__ItemListDescription *Parameters;	/* required element of type tt:ItemListDescription */
	int __sizeMessages;	/* sequence of elements <Messages> */
	_tt__ConfigDescription_Messages *Messages;	/* optional element of type tt:ConfigDescription-Messages */
	class tt__ConfigDescriptionExtension *Extension;	/* optional element of type tt:ConfigDescriptionExtension */
	char *Name;	/* required attribute */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 419; } /* = unique id SOAP_TYPE_tt__ConfigDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ConfigDescription(): Parameters(NULL), Messages(NULL), Extension(NULL), Name(NULL), soap(NULL) { tt__ConfigDescription::soap_default(NULL); }
	virtual ~tt__ConfigDescription() { }
};
#endif

#ifndef SOAP_TYPE_tt__ConfigDescriptionExtension
#define SOAP_TYPE_tt__ConfigDescriptionExtension (420)
/* tt:ConfigDescriptionExtension */
class SOAP_CMAC tt__ConfigDescriptionExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 420; } /* = unique id SOAP_TYPE_tt__ConfigDescriptionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ConfigDescriptionExtension(): __any(NULL), soap(NULL) { tt__ConfigDescriptionExtension::soap_default(NULL); }
	virtual ~tt__ConfigDescriptionExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__SupportedRules
#define SOAP_TYPE_tt__SupportedRules (421)
/* tt:SupportedRules */
class SOAP_CMAC tt__SupportedRules
{
public:
	int __sizeRuleContentSchemaLocation;	/* sequence of elements <RuleContentSchemaLocation> */
	char **RuleContentSchemaLocation;	/* optional element of type xsd:anyURI */
	int __sizeRuleDescription;	/* sequence of elements <RuleDescription> */
	tt__ConfigDescription **RuleDescription;	/* optional element of type tt:ConfigDescription */
	class tt__SupportedRulesExtension *Extension;	/* optional element of type tt:SupportedRulesExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 421; } /* = unique id SOAP_TYPE_tt__SupportedRules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SupportedRules(): RuleContentSchemaLocation(NULL), RuleDescription(NULL), Extension(NULL), soap(NULL) { tt__SupportedRules::soap_default(NULL); }
	virtual ~tt__SupportedRules() { }
};
#endif

#ifndef SOAP_TYPE_tt__SupportedRulesExtension
#define SOAP_TYPE_tt__SupportedRulesExtension (422)
/* tt:SupportedRulesExtension */
class SOAP_CMAC tt__SupportedRulesExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 422; } /* = unique id SOAP_TYPE_tt__SupportedRulesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SupportedRulesExtension(): __any(NULL), soap(NULL) { tt__SupportedRulesExtension::soap_default(NULL); }
	virtual ~tt__SupportedRulesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__SupportedAnalyticsModules
#define SOAP_TYPE_tt__SupportedAnalyticsModules (423)
/* tt:SupportedAnalyticsModules */
class SOAP_CMAC tt__SupportedAnalyticsModules
{
public:
	int __sizeAnalyticsModuleContentSchemaLocation;	/* sequence of elements <AnalyticsModuleContentSchemaLocation> */
	char **AnalyticsModuleContentSchemaLocation;	/* optional element of type xsd:anyURI */
	int __sizeAnalyticsModuleDescription;	/* sequence of elements <AnalyticsModuleDescription> */
	tt__ConfigDescription **AnalyticsModuleDescription;	/* optional element of type tt:ConfigDescription */
	class tt__SupportedAnalyticsModulesExtension *Extension;	/* optional element of type tt:SupportedAnalyticsModulesExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 423; } /* = unique id SOAP_TYPE_tt__SupportedAnalyticsModules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SupportedAnalyticsModules(): AnalyticsModuleContentSchemaLocation(NULL), AnalyticsModuleDescription(NULL), Extension(NULL), soap(NULL) { tt__SupportedAnalyticsModules::soap_default(NULL); }
	virtual ~tt__SupportedAnalyticsModules() { }
};
#endif

#ifndef SOAP_TYPE_tt__SupportedAnalyticsModulesExtension
#define SOAP_TYPE_tt__SupportedAnalyticsModulesExtension (424)
/* tt:SupportedAnalyticsModulesExtension */
class SOAP_CMAC tt__SupportedAnalyticsModulesExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 424; } /* = unique id SOAP_TYPE_tt__SupportedAnalyticsModulesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SupportedAnalyticsModulesExtension(): __any(NULL), soap(NULL) { tt__SupportedAnalyticsModulesExtension::soap_default(NULL); }
	virtual ~tt__SupportedAnalyticsModulesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PolygonConfiguration
#define SOAP_TYPE_tt__PolygonConfiguration (425)
/* tt:PolygonConfiguration */
class SOAP_CMAC tt__PolygonConfiguration
{
public:
	tt__Polygon *Polygon;	/* required element of type tt:Polygon */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 425; } /* = unique id SOAP_TYPE_tt__PolygonConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PolygonConfiguration(): Polygon(NULL), __any(NULL), soap(NULL) { tt__PolygonConfiguration::soap_default(NULL); }
	virtual ~tt__PolygonConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__PolylineArray
#define SOAP_TYPE_tt__PolylineArray (426)
/* tt:PolylineArray */
class SOAP_CMAC tt__PolylineArray
{
public:
	int __sizeSegment;	/* sequence of elements <Segment> */
	tt__Polyline **Segment;	/* required element of type tt:Polyline */
	class tt__PolylineArrayExtension *Extension;	/* optional element of type tt:PolylineArrayExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 426; } /* = unique id SOAP_TYPE_tt__PolylineArray */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PolylineArray(): Segment(NULL), Extension(NULL), soap(NULL) { tt__PolylineArray::soap_default(NULL); }
	virtual ~tt__PolylineArray() { }
};
#endif

#ifndef SOAP_TYPE_tt__PolylineArrayExtension
#define SOAP_TYPE_tt__PolylineArrayExtension (427)
/* tt:PolylineArrayExtension */
class SOAP_CMAC tt__PolylineArrayExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 427; } /* = unique id SOAP_TYPE_tt__PolylineArrayExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PolylineArrayExtension(): __any(NULL), soap(NULL) { tt__PolylineArrayExtension::soap_default(NULL); }
	virtual ~tt__PolylineArrayExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PolylineArrayConfiguration
#define SOAP_TYPE_tt__PolylineArrayConfiguration (428)
/* tt:PolylineArrayConfiguration */
class SOAP_CMAC tt__PolylineArrayConfiguration
{
public:
	tt__PolylineArray *PolylineArray;	/* required element of type tt:PolylineArray */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 428; } /* = unique id SOAP_TYPE_tt__PolylineArrayConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PolylineArrayConfiguration(): PolylineArray(NULL), __any(NULL), soap(NULL) { tt__PolylineArrayConfiguration::soap_default(NULL); }
	virtual ~tt__PolylineArrayConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__MotionExpression
#define SOAP_TYPE_tt__MotionExpression (429)
/* tt:MotionExpression */
class SOAP_CMAC tt__MotionExpression
{
public:
	char *Expression;	/* required element of type xsd:string */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	char *Type;	/* optional attribute */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 429; } /* = unique id SOAP_TYPE_tt__MotionExpression */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MotionExpression(): Expression(NULL), __any(NULL), Type(NULL), soap(NULL) { tt__MotionExpression::soap_default(NULL); }
	virtual ~tt__MotionExpression() { }
};
#endif

#ifndef SOAP_TYPE_tt__MotionExpressionConfiguration
#define SOAP_TYPE_tt__MotionExpressionConfiguration (430)
/* tt:MotionExpressionConfiguration */
class SOAP_CMAC tt__MotionExpressionConfiguration
{
public:
	tt__MotionExpression *MotionExpression;	/* required element of type tt:MotionExpression */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 430; } /* = unique id SOAP_TYPE_tt__MotionExpressionConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MotionExpressionConfiguration(): MotionExpression(NULL), __any(NULL), soap(NULL) { tt__MotionExpressionConfiguration::soap_default(NULL); }
	virtual ~tt__MotionExpressionConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__CellLayout
#define SOAP_TYPE_tt__CellLayout (431)
/* tt:CellLayout */
class SOAP_CMAC tt__CellLayout
{
public:
	tt__Transformation *Transformation;	/* required element of type tt:Transformation */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	char *Columns;	/* required attribute */
	char *Rows;	/* required attribute */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 431; } /* = unique id SOAP_TYPE_tt__CellLayout */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CellLayout(): Transformation(NULL), __any(NULL), Columns(NULL), Rows(NULL), soap(NULL) { tt__CellLayout::soap_default(NULL); }
	virtual ~tt__CellLayout() { }
};
#endif

#ifndef SOAP_TYPE__tt__union_MetadataStream
#define SOAP_TYPE__tt__union_MetadataStream (1016)
/* xsd:choice */
union _tt__union_MetadataStream
{
#define SOAP_UNION__tt__union_MetadataStream_VideoAnalytics	(1)
	class tt__VideoAnalyticsStream *VideoAnalytics;
#define SOAP_UNION__tt__union_MetadataStream_PTZ	(2)
	class tt__PTZStream *PTZ;
#define SOAP_UNION__tt__union_MetadataStream_Event	(3)
	class tt__EventStream *Event;
#define SOAP_UNION__tt__union_MetadataStream_Extension	(4)
	class tt__MetadataStreamExtension *Extension;
};
#endif

#ifndef SOAP_TYPE___tt__union_MetadataStream
#define SOAP_TYPE___tt__union_MetadataStream (1011)
/* Operation wrapper: */
class SOAP_CMAC __tt__union_MetadataStream
{
public:
	int __union_MetadataStream;	/* union discriminant (of union defined below) */
	union _tt__union_MetadataStream union_MetadataStream;	/* required element of type xsd:choice */
public:
	virtual int soap_type() const { return 1011; } /* = unique id SOAP_TYPE___tt__union_MetadataStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __tt__union_MetadataStream() { __tt__union_MetadataStream::soap_default(NULL); }
	virtual ~__tt__union_MetadataStream() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataStream
#define SOAP_TYPE_tt__MetadataStream (432)
/* tt:MetadataStream */
class SOAP_CMAC tt__MetadataStream
{
public:
	int __size_MetadataStream;	/* sequence of elements <-union-MetadataStream> */
	__tt__union_MetadataStream *__union_MetadataStream;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 432; } /* = unique id SOAP_TYPE_tt__MetadataStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataStream(): __union_MetadataStream(NULL), soap(NULL) { tt__MetadataStream::soap_default(NULL); }
	virtual ~tt__MetadataStream() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataStreamExtension
#define SOAP_TYPE_tt__MetadataStreamExtension (433)
/* tt:MetadataStreamExtension */
class SOAP_CMAC tt__MetadataStreamExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 433; } /* = unique id SOAP_TYPE_tt__MetadataStreamExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataStreamExtension(): __any(NULL), soap(NULL) { tt__MetadataStreamExtension::soap_default(NULL); }
	virtual ~tt__MetadataStreamExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__union_VideoAnalyticsStream
#define SOAP_TYPE__tt__union_VideoAnalyticsStream (1021)
/* xsd:choice */
union _tt__union_VideoAnalyticsStream
{
#define SOAP_UNION__tt__union_VideoAnalyticsStream_Frame	(1)
	tt__Frame *Frame;
#define SOAP_UNION__tt__union_VideoAnalyticsStream_Extension	(2)
	class tt__VideoAnalyticsStreamExtension *Extension;
};
#endif

#ifndef SOAP_TYPE___tt__union_VideoAnalyticsStream
#define SOAP_TYPE___tt__union_VideoAnalyticsStream (1018)
/* Operation wrapper: */
class SOAP_CMAC __tt__union_VideoAnalyticsStream
{
public:
	int __union_VideoAnalyticsStream;	/* union discriminant (of union defined below) */
	union _tt__union_VideoAnalyticsStream union_VideoAnalyticsStream;	/* required element of type xsd:choice */
public:
	virtual int soap_type() const { return 1018; } /* = unique id SOAP_TYPE___tt__union_VideoAnalyticsStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __tt__union_VideoAnalyticsStream() { __tt__union_VideoAnalyticsStream::soap_default(NULL); }
	virtual ~__tt__union_VideoAnalyticsStream() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoAnalyticsStream
#define SOAP_TYPE_tt__VideoAnalyticsStream (434)
/* tt:VideoAnalyticsStream */
class SOAP_CMAC tt__VideoAnalyticsStream
{
public:
	int __size_VideoAnalyticsStream;	/* sequence of elements <-union-VideoAnalyticsStream> */
	__tt__union_VideoAnalyticsStream *__union_VideoAnalyticsStream;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 434; } /* = unique id SOAP_TYPE_tt__VideoAnalyticsStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoAnalyticsStream(): __union_VideoAnalyticsStream(NULL), soap(NULL) { tt__VideoAnalyticsStream::soap_default(NULL); }
	virtual ~tt__VideoAnalyticsStream() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoAnalyticsStreamExtension
#define SOAP_TYPE_tt__VideoAnalyticsStreamExtension (435)
/* tt:VideoAnalyticsStreamExtension */
class SOAP_CMAC tt__VideoAnalyticsStreamExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 435; } /* = unique id SOAP_TYPE_tt__VideoAnalyticsStreamExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoAnalyticsStreamExtension(): __any(NULL), soap(NULL) { tt__VideoAnalyticsStreamExtension::soap_default(NULL); }
	virtual ~tt__VideoAnalyticsStreamExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__union_PTZStream
#define SOAP_TYPE__tt__union_PTZStream (1025)
/* xsd:choice */
union _tt__union_PTZStream
{
#define SOAP_UNION__tt__union_PTZStream_PTZStatus	(1)
	tt__PTZStatus *PTZStatus;
#define SOAP_UNION__tt__union_PTZStream_Extension	(2)
	class tt__PTZStreamExtension *Extension;
};
#endif

#ifndef SOAP_TYPE___tt__union_PTZStream
#define SOAP_TYPE___tt__union_PTZStream (1023)
/* Operation wrapper: */
class SOAP_CMAC __tt__union_PTZStream
{
public:
	int __union_PTZStream;	/* union discriminant (of union defined below) */
	union _tt__union_PTZStream union_PTZStream;	/* required element of type xsd:choice */
public:
	virtual int soap_type() const { return 1023; } /* = unique id SOAP_TYPE___tt__union_PTZStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __tt__union_PTZStream() { __tt__union_PTZStream::soap_default(NULL); }
	virtual ~__tt__union_PTZStream() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZStream
#define SOAP_TYPE_tt__PTZStream (436)
/* tt:PTZStream */
class SOAP_CMAC tt__PTZStream
{
public:
	int __size_PTZStream;	/* sequence of elements <-union-PTZStream> */
	__tt__union_PTZStream *__union_PTZStream;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 436; } /* = unique id SOAP_TYPE_tt__PTZStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZStream(): __union_PTZStream(NULL), soap(NULL) { tt__PTZStream::soap_default(NULL); }
	virtual ~tt__PTZStream() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZStreamExtension
#define SOAP_TYPE_tt__PTZStreamExtension (437)
/* tt:PTZStreamExtension */
class SOAP_CMAC tt__PTZStreamExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 437; } /* = unique id SOAP_TYPE_tt__PTZStreamExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZStreamExtension(): __any(NULL), soap(NULL) { tt__PTZStreamExtension::soap_default(NULL); }
	virtual ~tt__PTZStreamExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__union_EventStream
#define SOAP_TYPE__tt__union_EventStream (1030)
/* xsd:choice */
union _tt__union_EventStream
{
#define SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage	(1)
	class wsnt__NotificationMessageHolderType *wsnt__NotificationMessage;
#define SOAP_UNION__tt__union_EventStream_Extension	(2)
	class tt__EventStreamExtension *Extension;
};
#endif

#ifndef SOAP_TYPE___tt__union_EventStream
#define SOAP_TYPE___tt__union_EventStream (1027)
/* Operation wrapper: */
class SOAP_CMAC __tt__union_EventStream
{
public:
	int __union_EventStream;	/* union discriminant (of union defined below) */
	union _tt__union_EventStream union_EventStream;	/* required element of type xsd:choice */
public:
	virtual int soap_type() const { return 1027; } /* = unique id SOAP_TYPE___tt__union_EventStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __tt__union_EventStream() { __tt__union_EventStream::soap_default(NULL); }
	virtual ~__tt__union_EventStream() { }
};
#endif

#ifndef SOAP_TYPE_tt__EventStream
#define SOAP_TYPE_tt__EventStream (438)
/* tt:EventStream */
class SOAP_CMAC tt__EventStream
{
public:
	int __size_EventStream;	/* sequence of elements <-union-EventStream> */
	__tt__union_EventStream *__union_EventStream;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 438; } /* = unique id SOAP_TYPE_tt__EventStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EventStream(): __union_EventStream(NULL), soap(NULL) { tt__EventStream::soap_default(NULL); }
	virtual ~tt__EventStream() { }
};
#endif

#ifndef SOAP_TYPE_tt__EventStreamExtension
#define SOAP_TYPE_tt__EventStreamExtension (439)
/* tt:EventStreamExtension */
class SOAP_CMAC tt__EventStreamExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 439; } /* = unique id SOAP_TYPE_tt__EventStreamExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EventStreamExtension(): __any(NULL), soap(NULL) { tt__EventStreamExtension::soap_default(NULL); }
	virtual ~tt__EventStreamExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PaneConfiguration
#define SOAP_TYPE_tt__PaneConfiguration (440)
/* tt:PaneConfiguration */
class SOAP_CMAC tt__PaneConfiguration
{
public:
	char *PaneName;	/* optional element of type xsd:string */
	char *AudioOutputToken;	/* optional element of type tt:ReferenceToken */
	char *AudioSourceToken;	/* optional element of type tt:ReferenceToken */
	tt__AudioEncoderConfiguration *AudioEncoderConfiguration;	/* optional element of type tt:AudioEncoderConfiguration */
	char *ReceiverToken;	/* optional element of type tt:ReferenceToken */
	char *Token;	/* required element of type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 440; } /* = unique id SOAP_TYPE_tt__PaneConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PaneConfiguration(): PaneName(NULL), AudioOutputToken(NULL), AudioSourceToken(NULL), AudioEncoderConfiguration(NULL), ReceiverToken(NULL), Token(NULL), __any(NULL), soap(NULL) { tt__PaneConfiguration::soap_default(NULL); }
	virtual ~tt__PaneConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__PaneLayout
#define SOAP_TYPE_tt__PaneLayout (441)
/* tt:PaneLayout */
class SOAP_CMAC tt__PaneLayout
{
public:
	char *Pane;	/* required element of type tt:ReferenceToken */
	tt__Rectangle *Area;	/* required element of type tt:Rectangle */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 441; } /* = unique id SOAP_TYPE_tt__PaneLayout */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PaneLayout(): Pane(NULL), Area(NULL), __any(NULL), soap(NULL) { tt__PaneLayout::soap_default(NULL); }
	virtual ~tt__PaneLayout() { }
};
#endif

#ifndef SOAP_TYPE_tt__Layout
#define SOAP_TYPE_tt__Layout (442)
/* tt:Layout */
class SOAP_CMAC tt__Layout
{
public:
	int __sizePaneLayout;	/* sequence of elements <PaneLayout> */
	tt__PaneLayout **PaneLayout;	/* required element of type tt:PaneLayout */
	class tt__LayoutExtension *Extension;	/* optional element of type tt:LayoutExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 442; } /* = unique id SOAP_TYPE_tt__Layout */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Layout(): PaneLayout(NULL), Extension(NULL), soap(NULL) { tt__Layout::soap_default(NULL); }
	virtual ~tt__Layout() { }
};
#endif

#ifndef SOAP_TYPE_tt__LayoutExtension
#define SOAP_TYPE_tt__LayoutExtension (443)
/* tt:LayoutExtension */
class SOAP_CMAC tt__LayoutExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 443; } /* = unique id SOAP_TYPE_tt__LayoutExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__LayoutExtension(): __any(NULL), soap(NULL) { tt__LayoutExtension::soap_default(NULL); }
	virtual ~tt__LayoutExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__CodingCapabilities
#define SOAP_TYPE_tt__CodingCapabilities (444)
/* tt:CodingCapabilities */
class SOAP_CMAC tt__CodingCapabilities
{
public:
	tt__AudioEncoderConfigurationOptions *AudioEncodingCapabilities;	/* optional element of type tt:AudioEncoderConfigurationOptions */
	tt__AudioDecoderConfigurationOptions *AudioDecodingCapabilities;	/* optional element of type tt:AudioDecoderConfigurationOptions */
	tt__VideoDecoderConfigurationOptions *VideoDecodingCapabilities;	/* required element of type tt:VideoDecoderConfigurationOptions */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 444; } /* = unique id SOAP_TYPE_tt__CodingCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CodingCapabilities(): AudioEncodingCapabilities(NULL), AudioDecodingCapabilities(NULL), VideoDecodingCapabilities(NULL), __any(NULL), soap(NULL) { tt__CodingCapabilities::soap_default(NULL); }
	virtual ~tt__CodingCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_tt__LayoutOptions
#define SOAP_TYPE_tt__LayoutOptions (445)
/* tt:LayoutOptions */
class SOAP_CMAC tt__LayoutOptions
{
public:
	int __sizePaneLayoutOptions;	/* sequence of elements <PaneLayoutOptions> */
	class tt__PaneLayoutOptions **PaneLayoutOptions;	/* required element of type tt:PaneLayoutOptions */
	class tt__LayoutOptionsExtension *Extension;	/* optional element of type tt:LayoutOptionsExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 445; } /* = unique id SOAP_TYPE_tt__LayoutOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__LayoutOptions(): PaneLayoutOptions(NULL), Extension(NULL), soap(NULL) { tt__LayoutOptions::soap_default(NULL); }
	virtual ~tt__LayoutOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__LayoutOptionsExtension
#define SOAP_TYPE_tt__LayoutOptionsExtension (446)
/* tt:LayoutOptionsExtension */
class SOAP_CMAC tt__LayoutOptionsExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 446; } /* = unique id SOAP_TYPE_tt__LayoutOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__LayoutOptionsExtension(): __any(NULL), soap(NULL) { tt__LayoutOptionsExtension::soap_default(NULL); }
	virtual ~tt__LayoutOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PaneLayoutOptions
#define SOAP_TYPE_tt__PaneLayoutOptions (447)
/* tt:PaneLayoutOptions */
class SOAP_CMAC tt__PaneLayoutOptions
{
public:
	int __sizeArea;	/* sequence of elements <Area> */
	tt__Rectangle **Area;	/* required element of type tt:Rectangle */
	class tt__PaneOptionExtension *Extension;	/* optional element of type tt:PaneOptionExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 447; } /* = unique id SOAP_TYPE_tt__PaneLayoutOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PaneLayoutOptions(): Area(NULL), Extension(NULL), soap(NULL) { tt__PaneLayoutOptions::soap_default(NULL); }
	virtual ~tt__PaneLayoutOptions() { }
};
#endif

#ifndef SOAP_TYPE_tt__PaneOptionExtension
#define SOAP_TYPE_tt__PaneOptionExtension (448)
/* tt:PaneOptionExtension */
class SOAP_CMAC tt__PaneOptionExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 448; } /* = unique id SOAP_TYPE_tt__PaneOptionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PaneOptionExtension(): __any(NULL), soap(NULL) { tt__PaneOptionExtension::soap_default(NULL); }
	virtual ~tt__PaneOptionExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__Receiver
#define SOAP_TYPE_tt__Receiver (449)
/* tt:Receiver */
class SOAP_CMAC tt__Receiver
{
public:
	char *Token;	/* required element of type tt:ReferenceToken */
	class tt__ReceiverConfiguration *Configuration;	/* required element of type tt:ReceiverConfiguration */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 449; } /* = unique id SOAP_TYPE_tt__Receiver */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Receiver(): Token(NULL), Configuration(NULL), __any(NULL), soap(NULL) { tt__Receiver::soap_default(NULL); }
	virtual ~tt__Receiver() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReceiverConfiguration
#define SOAP_TYPE_tt__ReceiverConfiguration (450)
/* tt:ReceiverConfiguration */
class SOAP_CMAC tt__ReceiverConfiguration
{
public:
	enum tt__ReceiverMode Mode;	/* required element of type tt:ReceiverMode */
	char *MediaUri;	/* required element of type xsd:anyURI */
	tt__StreamSetup *StreamSetup;	/* required element of type tt:StreamSetup */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 450; } /* = unique id SOAP_TYPE_tt__ReceiverConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReceiverConfiguration(): MediaUri(NULL), StreamSetup(NULL), __any(NULL), soap(NULL) { tt__ReceiverConfiguration::soap_default(NULL); }
	virtual ~tt__ReceiverConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReceiverStateInformation
#define SOAP_TYPE_tt__ReceiverStateInformation (451)
/* tt:ReceiverStateInformation */
class SOAP_CMAC tt__ReceiverStateInformation
{
public:
	enum tt__ReceiverState State;	/* required element of type tt:ReceiverState */
	bool AutoCreated;	/* required element of type xsd:boolean */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 451; } /* = unique id SOAP_TYPE_tt__ReceiverStateInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReceiverStateInformation(): __any(NULL), soap(NULL) { tt__ReceiverStateInformation::soap_default(NULL); }
	virtual ~tt__ReceiverStateInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__SourceReference
#define SOAP_TYPE_tt__SourceReference (452)
/* tt:SourceReference */
class SOAP_CMAC tt__SourceReference
{
public:
	char *Token;	/* required element of type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	char *Type;	/* optional attribute */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 452; } /* = unique id SOAP_TYPE_tt__SourceReference */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SourceReference(): Token(NULL), __any(NULL), Type(NULL), soap(NULL) { tt__SourceReference::soap_default(NULL); }
	virtual ~tt__SourceReference() { }
};
#endif

#ifndef SOAP_TYPE_tt__DateTimeRange
#define SOAP_TYPE_tt__DateTimeRange (453)
/* tt:DateTimeRange */
class SOAP_CMAC tt__DateTimeRange
{
public:
	time_t From;	/* required element of type xsd:dateTime */
	time_t Until;	/* required element of type xsd:dateTime */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 453; } /* = unique id SOAP_TYPE_tt__DateTimeRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DateTimeRange(): __any(NULL), soap(NULL) { tt__DateTimeRange::soap_default(NULL); }
	virtual ~tt__DateTimeRange() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingSummary
#define SOAP_TYPE_tt__RecordingSummary (454)
/* tt:RecordingSummary */
class SOAP_CMAC tt__RecordingSummary
{
public:
	time_t DataFrom;	/* required element of type xsd:dateTime */
	time_t DataUntil;	/* required element of type xsd:dateTime */
	int NumberRecordings;	/* required element of type xsd:int */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 454; } /* = unique id SOAP_TYPE_tt__RecordingSummary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingSummary(): __any(NULL), soap(NULL) { tt__RecordingSummary::soap_default(NULL); }
	virtual ~tt__RecordingSummary() { }
};
#endif

#ifndef SOAP_TYPE_tt__SearchScope
#define SOAP_TYPE_tt__SearchScope (455)
/* tt:SearchScope */
class SOAP_CMAC tt__SearchScope
{
public:
	int __sizeIncludedSources;	/* sequence of elements <IncludedSources> */
	tt__SourceReference **IncludedSources;	/* optional element of type tt:SourceReference */
	int __sizeIncludedRecordings;	/* sequence of elements <IncludedRecordings> */
	char **IncludedRecordings;	/* optional element of type tt:RecordingReference */
	char *RecordingInformationFilter;	/* optional element of type tt:XPathExpression */
	class tt__SearchScopeExtension *Extension;	/* optional element of type tt:SearchScopeExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 455; } /* = unique id SOAP_TYPE_tt__SearchScope */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SearchScope(): IncludedSources(NULL), IncludedRecordings(NULL), RecordingInformationFilter(NULL), Extension(NULL), soap(NULL) { tt__SearchScope::soap_default(NULL); }
	virtual ~tt__SearchScope() { }
};
#endif

#ifndef SOAP_TYPE_tt__SearchScopeExtension
#define SOAP_TYPE_tt__SearchScopeExtension (456)
/* tt:SearchScopeExtension */
class SOAP_CMAC tt__SearchScopeExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 456; } /* = unique id SOAP_TYPE_tt__SearchScopeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SearchScopeExtension(): __any(NULL), soap(NULL) { tt__SearchScopeExtension::soap_default(NULL); }
	virtual ~tt__SearchScopeExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZPositionFilter
#define SOAP_TYPE_tt__PTZPositionFilter (458)
/* tt:PTZPositionFilter */
class SOAP_CMAC tt__PTZPositionFilter
{
public:
	tt__PTZVector *MinPosition;	/* required element of type tt:PTZVector */
	tt__PTZVector *MaxPosition;	/* required element of type tt:PTZVector */
	bool EnterOrExit;	/* required element of type xsd:boolean */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 458; } /* = unique id SOAP_TYPE_tt__PTZPositionFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZPositionFilter(): MinPosition(NULL), MaxPosition(NULL), __any(NULL), soap(NULL) { tt__PTZPositionFilter::soap_default(NULL); }
	virtual ~tt__PTZPositionFilter() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataFilter
#define SOAP_TYPE_tt__MetadataFilter (459)
/* tt:MetadataFilter */
class SOAP_CMAC tt__MetadataFilter
{
public:
	char *MetadataStreamFilter;	/* required element of type tt:XPathExpression */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 459; } /* = unique id SOAP_TYPE_tt__MetadataFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataFilter(): MetadataStreamFilter(NULL), __any(NULL), soap(NULL) { tt__MetadataFilter::soap_default(NULL); }
	virtual ~tt__MetadataFilter() { }
};
#endif

#ifndef SOAP_TYPE_tt__FindRecordingResultList
#define SOAP_TYPE_tt__FindRecordingResultList (460)
/* tt:FindRecordingResultList */
class SOAP_CMAC tt__FindRecordingResultList
{
public:
	enum tt__SearchState SearchState;	/* required element of type tt:SearchState */
	int __sizeRecordingInformation;	/* sequence of elements <RecordingInformation> */
	class tt__RecordingInformation **RecordingInformation;	/* optional element of type tt:RecordingInformation */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 460; } /* = unique id SOAP_TYPE_tt__FindRecordingResultList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FindRecordingResultList(): RecordingInformation(NULL), soap(NULL) { tt__FindRecordingResultList::soap_default(NULL); }
	virtual ~tt__FindRecordingResultList() { }
};
#endif

#ifndef SOAP_TYPE_tt__FindEventResultList
#define SOAP_TYPE_tt__FindEventResultList (461)
/* tt:FindEventResultList */
class SOAP_CMAC tt__FindEventResultList
{
public:
	enum tt__SearchState SearchState;	/* required element of type tt:SearchState */
	int __sizeResult;	/* sequence of elements <Result> */
	class tt__FindEventResult **Result;	/* optional element of type tt:FindEventResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 461; } /* = unique id SOAP_TYPE_tt__FindEventResultList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FindEventResultList(): Result(NULL), soap(NULL) { tt__FindEventResultList::soap_default(NULL); }
	virtual ~tt__FindEventResultList() { }
};
#endif

#ifndef SOAP_TYPE_tt__FindEventResult
#define SOAP_TYPE_tt__FindEventResult (462)
/* tt:FindEventResult */
class SOAP_CMAC tt__FindEventResult
{
public:
	char *RecordingToken;	/* required element of type tt:RecordingReference */
	char *TrackToken;	/* required element of type tt:TrackReference */
	time_t Time;	/* required element of type xsd:dateTime */
	wsnt__NotificationMessageHolderType *Event;	/* required element of type wsnt:NotificationMessageHolderType */
	bool StartStateEvent;	/* required element of type xsd:boolean */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 462; } /* = unique id SOAP_TYPE_tt__FindEventResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FindEventResult(): RecordingToken(NULL), TrackToken(NULL), Event(NULL), __any(NULL), soap(NULL) { tt__FindEventResult::soap_default(NULL); }
	virtual ~tt__FindEventResult() { }
};
#endif

#ifndef SOAP_TYPE_tt__FindPTZPositionResultList
#define SOAP_TYPE_tt__FindPTZPositionResultList (463)
/* tt:FindPTZPositionResultList */
class SOAP_CMAC tt__FindPTZPositionResultList
{
public:
	enum tt__SearchState SearchState;	/* required element of type tt:SearchState */
	int __sizeResult;	/* sequence of elements <Result> */
	class tt__FindPTZPositionResult **Result;	/* optional element of type tt:FindPTZPositionResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 463; } /* = unique id SOAP_TYPE_tt__FindPTZPositionResultList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FindPTZPositionResultList(): Result(NULL), soap(NULL) { tt__FindPTZPositionResultList::soap_default(NULL); }
	virtual ~tt__FindPTZPositionResultList() { }
};
#endif

#ifndef SOAP_TYPE_tt__FindPTZPositionResult
#define SOAP_TYPE_tt__FindPTZPositionResult (464)
/* tt:FindPTZPositionResult */
class SOAP_CMAC tt__FindPTZPositionResult
{
public:
	char *RecordingToken;	/* required element of type tt:RecordingReference */
	char *TrackToken;	/* required element of type tt:TrackReference */
	time_t Time;	/* required element of type xsd:dateTime */
	tt__PTZVector *Position;	/* required element of type tt:PTZVector */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 464; } /* = unique id SOAP_TYPE_tt__FindPTZPositionResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FindPTZPositionResult(): RecordingToken(NULL), TrackToken(NULL), Position(NULL), __any(NULL), soap(NULL) { tt__FindPTZPositionResult::soap_default(NULL); }
	virtual ~tt__FindPTZPositionResult() { }
};
#endif

#ifndef SOAP_TYPE_tt__FindMetadataResultList
#define SOAP_TYPE_tt__FindMetadataResultList (465)
/* tt:FindMetadataResultList */
class SOAP_CMAC tt__FindMetadataResultList
{
public:
	enum tt__SearchState SearchState;	/* required element of type tt:SearchState */
	int __sizeResult;	/* sequence of elements <Result> */
	class tt__FindMetadataResult **Result;	/* optional element of type tt:FindMetadataResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 465; } /* = unique id SOAP_TYPE_tt__FindMetadataResultList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FindMetadataResultList(): Result(NULL), soap(NULL) { tt__FindMetadataResultList::soap_default(NULL); }
	virtual ~tt__FindMetadataResultList() { }
};
#endif

#ifndef SOAP_TYPE_tt__FindMetadataResult
#define SOAP_TYPE_tt__FindMetadataResult (466)
/* tt:FindMetadataResult */
class SOAP_CMAC tt__FindMetadataResult
{
public:
	char *RecordingToken;	/* required element of type tt:RecordingReference */
	char *TrackToken;	/* required element of type tt:TrackReference */
	time_t Time;	/* required element of type xsd:dateTime */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 466; } /* = unique id SOAP_TYPE_tt__FindMetadataResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__FindMetadataResult(): RecordingToken(NULL), TrackToken(NULL), __any(NULL), soap(NULL) { tt__FindMetadataResult::soap_default(NULL); }
	virtual ~tt__FindMetadataResult() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingInformation
#define SOAP_TYPE_tt__RecordingInformation (467)
/* tt:RecordingInformation */
class SOAP_CMAC tt__RecordingInformation
{
public:
	char *RecordingToken;	/* required element of type tt:RecordingReference */
	class tt__RecordingSourceInformation *Source;	/* required element of type tt:RecordingSourceInformation */
	time_t *EarliestRecording;	/* optional element of type xsd:dateTime */
	time_t *LatestRecording;	/* optional element of type xsd:dateTime */
	char *Content;	/* required element of type tt:Description */
	int __sizeTrack;	/* sequence of elements <Track> */
	class tt__TrackInformation **Track;	/* optional element of type tt:TrackInformation */
	enum tt__RecordingStatus RecordingStatus;	/* required element of type tt:RecordingStatus */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 467; } /* = unique id SOAP_TYPE_tt__RecordingInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingInformation(): RecordingToken(NULL), Source(NULL), EarliestRecording(NULL), LatestRecording(NULL), Content(NULL), Track(NULL), __any(NULL), soap(NULL) { tt__RecordingInformation::soap_default(NULL); }
	virtual ~tt__RecordingInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingSourceInformation
#define SOAP_TYPE_tt__RecordingSourceInformation (468)
/* tt:RecordingSourceInformation */
class SOAP_CMAC tt__RecordingSourceInformation
{
public:
	char *SourceId;	/* required element of type xsd:anyURI */
	char *Name;	/* required element of type tt:Name */
	char *Location;	/* required element of type tt:Description */
	char *Description;	/* required element of type tt:Description */
	char *Address;	/* required element of type xsd:anyURI */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 468; } /* = unique id SOAP_TYPE_tt__RecordingSourceInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingSourceInformation(): SourceId(NULL), Name(NULL), Location(NULL), Description(NULL), Address(NULL), __any(NULL), soap(NULL) { tt__RecordingSourceInformation::soap_default(NULL); }
	virtual ~tt__RecordingSourceInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__TrackInformation
#define SOAP_TYPE_tt__TrackInformation (469)
/* tt:TrackInformation */
class SOAP_CMAC tt__TrackInformation
{
public:
	char *TrackToken;	/* required element of type tt:TrackReference */
	enum tt__TrackType TrackType;	/* required element of type tt:TrackType */
	char *Description;	/* required element of type tt:Description */
	time_t DataFrom;	/* required element of type xsd:dateTime */
	time_t DataTo;	/* required element of type xsd:dateTime */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 469; } /* = unique id SOAP_TYPE_tt__TrackInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TrackInformation(): TrackToken(NULL), Description(NULL), __any(NULL), soap(NULL) { tt__TrackInformation::soap_default(NULL); }
	virtual ~tt__TrackInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__MediaAttributes
#define SOAP_TYPE_tt__MediaAttributes (470)
/* tt:MediaAttributes */
class SOAP_CMAC tt__MediaAttributes
{
public:
	char *RecordingToken;	/* required element of type tt:RecordingReference */
	int __sizeTrackAttributes;	/* sequence of elements <TrackAttributes> */
	class tt__TrackAttributes **TrackAttributes;	/* optional element of type tt:TrackAttributes */
	time_t From;	/* required element of type xsd:dateTime */
	time_t Until;	/* required element of type xsd:dateTime */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 470; } /* = unique id SOAP_TYPE_tt__MediaAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MediaAttributes(): RecordingToken(NULL), TrackAttributes(NULL), __any(NULL), soap(NULL) { tt__MediaAttributes::soap_default(NULL); }
	virtual ~tt__MediaAttributes() { }
};
#endif

#ifndef SOAP_TYPE_tt__TrackAttributes
#define SOAP_TYPE_tt__TrackAttributes (471)
/* tt:TrackAttributes */
class SOAP_CMAC tt__TrackAttributes
{
public:
	tt__TrackInformation *TrackInformation;	/* required element of type tt:TrackInformation */
	class tt__VideoAttributes *VideoAttributes;	/* optional element of type tt:VideoAttributes */
	class tt__AudioAttributes *AudioAttributes;	/* optional element of type tt:AudioAttributes */
	class tt__MetadataAttributes *MetadataAttributes;	/* optional element of type tt:MetadataAttributes */
	class tt__TrackAttributesExtension *Extension;	/* optional element of type tt:TrackAttributesExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 471; } /* = unique id SOAP_TYPE_tt__TrackAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TrackAttributes(): TrackInformation(NULL), VideoAttributes(NULL), AudioAttributes(NULL), MetadataAttributes(NULL), Extension(NULL), soap(NULL) { tt__TrackAttributes::soap_default(NULL); }
	virtual ~tt__TrackAttributes() { }
};
#endif

#ifndef SOAP_TYPE_tt__TrackAttributesExtension
#define SOAP_TYPE_tt__TrackAttributesExtension (472)
/* tt:TrackAttributesExtension */
class SOAP_CMAC tt__TrackAttributesExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 472; } /* = unique id SOAP_TYPE_tt__TrackAttributesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TrackAttributesExtension(): __any(NULL), soap(NULL) { tt__TrackAttributesExtension::soap_default(NULL); }
	virtual ~tt__TrackAttributesExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoAttributes
#define SOAP_TYPE_tt__VideoAttributes (473)
/* tt:VideoAttributes */
class SOAP_CMAC tt__VideoAttributes
{
public:
	int *Bitrate;	/* optional element of type xsd:int */
	int Width;	/* required element of type xsd:int */
	int Height;	/* required element of type xsd:int */
	enum tt__VideoEncoding Encoding;	/* required element of type tt:VideoEncoding */
	float Framerate;	/* required element of type xsd:float */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 473; } /* = unique id SOAP_TYPE_tt__VideoAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoAttributes(): Bitrate(NULL), __any(NULL), soap(NULL) { tt__VideoAttributes::soap_default(NULL); }
	virtual ~tt__VideoAttributes() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioAttributes
#define SOAP_TYPE_tt__AudioAttributes (474)
/* tt:AudioAttributes */
class SOAP_CMAC tt__AudioAttributes
{
public:
	int *Bitrate;	/* optional element of type xsd:int */
	enum tt__AudioEncoding Encoding;	/* required element of type tt:AudioEncoding */
	int Samplerate;	/* required element of type xsd:int */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 474; } /* = unique id SOAP_TYPE_tt__AudioAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioAttributes(): Bitrate(NULL), __any(NULL), soap(NULL) { tt__AudioAttributes::soap_default(NULL); }
	virtual ~tt__AudioAttributes() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataAttributes
#define SOAP_TYPE_tt__MetadataAttributes (475)
/* tt:MetadataAttributes */
class SOAP_CMAC tt__MetadataAttributes
{
public:
	bool CanContainPTZ;	/* required element of type xsd:boolean */
	bool CanContainAnalytics;	/* required element of type xsd:boolean */
	bool CanContainNotifications;	/* required element of type xsd:boolean */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 475; } /* = unique id SOAP_TYPE_tt__MetadataAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataAttributes(): __any(NULL), soap(NULL) { tt__MetadataAttributes::soap_default(NULL); }
	virtual ~tt__MetadataAttributes() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingConfiguration
#define SOAP_TYPE_tt__RecordingConfiguration (476)
/* tt:RecordingConfiguration */
class SOAP_CMAC tt__RecordingConfiguration
{
public:
	tt__RecordingSourceInformation *Source;	/* required element of type tt:RecordingSourceInformation */
	char *Content;	/* required element of type tt:Description */
	char *MaximumRetentionTime;	/* required element of type xsd:duration */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 476; } /* = unique id SOAP_TYPE_tt__RecordingConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingConfiguration(): Source(NULL), Content(NULL), MaximumRetentionTime(NULL), __any(NULL), soap(NULL) { tt__RecordingConfiguration::soap_default(NULL); }
	virtual ~tt__RecordingConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__TrackConfiguration
#define SOAP_TYPE_tt__TrackConfiguration (477)
/* tt:TrackConfiguration */
class SOAP_CMAC tt__TrackConfiguration
{
public:
	enum tt__TrackType TrackType;	/* required element of type tt:TrackType */
	char *Description;	/* required element of type tt:Description */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 477; } /* = unique id SOAP_TYPE_tt__TrackConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__TrackConfiguration(): Description(NULL), __any(NULL), soap(NULL) { tt__TrackConfiguration::soap_default(NULL); }
	virtual ~tt__TrackConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__GetRecordingsResponseItem
#define SOAP_TYPE_tt__GetRecordingsResponseItem (478)
/* tt:GetRecordingsResponseItem */
class SOAP_CMAC tt__GetRecordingsResponseItem
{
public:
	char *RecordingToken;	/* required element of type tt:RecordingReference */
	tt__RecordingConfiguration *Configuration;	/* required element of type tt:RecordingConfiguration */
	class tt__GetTracksResponseList *Tracks;	/* required element of type tt:GetTracksResponseList */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 478; } /* = unique id SOAP_TYPE_tt__GetRecordingsResponseItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__GetRecordingsResponseItem(): RecordingToken(NULL), Configuration(NULL), Tracks(NULL), __any(NULL), soap(NULL) { tt__GetRecordingsResponseItem::soap_default(NULL); }
	virtual ~tt__GetRecordingsResponseItem() { }
};
#endif

#ifndef SOAP_TYPE_tt__GetTracksResponseList
#define SOAP_TYPE_tt__GetTracksResponseList (479)
/* tt:GetTracksResponseList */
class SOAP_CMAC tt__GetTracksResponseList
{
public:
	int __sizeTrack;	/* sequence of elements <Track> */
	class tt__GetTracksResponseItem **Track;	/* optional element of type tt:GetTracksResponseItem */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 479; } /* = unique id SOAP_TYPE_tt__GetTracksResponseList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__GetTracksResponseList(): Track(NULL), soap(NULL) { tt__GetTracksResponseList::soap_default(NULL); }
	virtual ~tt__GetTracksResponseList() { }
};
#endif

#ifndef SOAP_TYPE_tt__GetTracksResponseItem
#define SOAP_TYPE_tt__GetTracksResponseItem (480)
/* tt:GetTracksResponseItem */
class SOAP_CMAC tt__GetTracksResponseItem
{
public:
	char *TrackToken;	/* required element of type tt:TrackReference */
	tt__TrackConfiguration *Configuration;	/* required element of type tt:TrackConfiguration */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 480; } /* = unique id SOAP_TYPE_tt__GetTracksResponseItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__GetTracksResponseItem(): TrackToken(NULL), Configuration(NULL), __any(NULL), soap(NULL) { tt__GetTracksResponseItem::soap_default(NULL); }
	virtual ~tt__GetTracksResponseItem() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobConfiguration
#define SOAP_TYPE_tt__RecordingJobConfiguration (481)
/* tt:RecordingJobConfiguration */
class SOAP_CMAC tt__RecordingJobConfiguration
{
public:
	char *RecordingToken;	/* required element of type tt:RecordingReference */
	char *Mode;	/* required element of type tt:RecordingJobMode */
	int Priority;	/* required element of type xsd:int */
	int __sizeSource;	/* sequence of elements <Source> */
	class tt__RecordingJobSource **Source;	/* optional element of type tt:RecordingJobSource */
	class tt__RecordingJobConfigurationExtension *Extension;	/* optional element of type tt:RecordingJobConfigurationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 481; } /* = unique id SOAP_TYPE_tt__RecordingJobConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobConfiguration(): RecordingToken(NULL), Mode(NULL), Source(NULL), Extension(NULL), soap(NULL) { tt__RecordingJobConfiguration::soap_default(NULL); }
	virtual ~tt__RecordingJobConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobConfigurationExtension
#define SOAP_TYPE_tt__RecordingJobConfigurationExtension (482)
/* tt:RecordingJobConfigurationExtension */
class SOAP_CMAC tt__RecordingJobConfigurationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 482; } /* = unique id SOAP_TYPE_tt__RecordingJobConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobConfigurationExtension(): __any(NULL), soap(NULL) { tt__RecordingJobConfigurationExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobSource
#define SOAP_TYPE_tt__RecordingJobSource (483)
/* tt:RecordingJobSource */
class SOAP_CMAC tt__RecordingJobSource
{
public:
	tt__SourceReference *SourceToken;	/* optional element of type tt:SourceReference */
	bool *AutoCreateReceiver;	/* optional element of type xsd:boolean */
	int __sizeTracks;	/* sequence of elements <Tracks> */
	class tt__RecordingJobTrack **Tracks;	/* optional element of type tt:RecordingJobTrack */
	class tt__RecordingJobSourceExtension *Extension;	/* optional element of type tt:RecordingJobSourceExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 483; } /* = unique id SOAP_TYPE_tt__RecordingJobSource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobSource(): SourceToken(NULL), AutoCreateReceiver(NULL), Tracks(NULL), Extension(NULL), soap(NULL) { tt__RecordingJobSource::soap_default(NULL); }
	virtual ~tt__RecordingJobSource() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobSourceExtension
#define SOAP_TYPE_tt__RecordingJobSourceExtension (484)
/* tt:RecordingJobSourceExtension */
class SOAP_CMAC tt__RecordingJobSourceExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 484; } /* = unique id SOAP_TYPE_tt__RecordingJobSourceExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobSourceExtension(): __any(NULL), soap(NULL) { tt__RecordingJobSourceExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobSourceExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobTrack
#define SOAP_TYPE_tt__RecordingJobTrack (485)
/* tt:RecordingJobTrack */
class SOAP_CMAC tt__RecordingJobTrack
{
public:
	char *SourceTag;	/* required element of type xsd:string */
	char *Destination;	/* required element of type tt:TrackReference */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 485; } /* = unique id SOAP_TYPE_tt__RecordingJobTrack */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobTrack(): SourceTag(NULL), Destination(NULL), __any(NULL), soap(NULL) { tt__RecordingJobTrack::soap_default(NULL); }
	virtual ~tt__RecordingJobTrack() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobStateInformation
#define SOAP_TYPE_tt__RecordingJobStateInformation (486)
/* tt:RecordingJobStateInformation */
class SOAP_CMAC tt__RecordingJobStateInformation
{
public:
	char *RecordingToken;	/* required element of type tt:RecordingReference */
	char *State;	/* required element of type tt:RecordingJobState */
	int __sizeSources;	/* sequence of elements <Sources> */
	class tt__RecordingJobStateSource **Sources;	/* optional element of type tt:RecordingJobStateSource */
	class tt__RecordingJobStateInformationExtension *Extension;	/* optional element of type tt:RecordingJobStateInformationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 486; } /* = unique id SOAP_TYPE_tt__RecordingJobStateInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobStateInformation(): RecordingToken(NULL), State(NULL), Sources(NULL), Extension(NULL), soap(NULL) { tt__RecordingJobStateInformation::soap_default(NULL); }
	virtual ~tt__RecordingJobStateInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobStateInformationExtension
#define SOAP_TYPE_tt__RecordingJobStateInformationExtension (487)
/* tt:RecordingJobStateInformationExtension */
class SOAP_CMAC tt__RecordingJobStateInformationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 487; } /* = unique id SOAP_TYPE_tt__RecordingJobStateInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobStateInformationExtension(): __any(NULL), soap(NULL) { tt__RecordingJobStateInformationExtension::soap_default(NULL); }
	virtual ~tt__RecordingJobStateInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobStateSource
#define SOAP_TYPE_tt__RecordingJobStateSource (488)
/* tt:RecordingJobStateSource */
class SOAP_CMAC tt__RecordingJobStateSource
{
public:
	tt__SourceReference *SourceToken;	/* required element of type tt:SourceReference */
	char *State;	/* required element of type tt:RecordingJobState */
	class tt__RecordingJobStateTracks *Tracks;	/* required element of type tt:RecordingJobStateTracks */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 488; } /* = unique id SOAP_TYPE_tt__RecordingJobStateSource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobStateSource(): SourceToken(NULL), State(NULL), Tracks(NULL), __any(NULL), soap(NULL) { tt__RecordingJobStateSource::soap_default(NULL); }
	virtual ~tt__RecordingJobStateSource() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobStateTracks
#define SOAP_TYPE_tt__RecordingJobStateTracks (489)
/* tt:RecordingJobStateTracks */
class SOAP_CMAC tt__RecordingJobStateTracks
{
public:
	int __sizeTrack;	/* sequence of elements <Track> */
	class tt__RecordingJobStateTrack **Track;	/* optional element of type tt:RecordingJobStateTrack */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 489; } /* = unique id SOAP_TYPE_tt__RecordingJobStateTracks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobStateTracks(): Track(NULL), soap(NULL) { tt__RecordingJobStateTracks::soap_default(NULL); }
	virtual ~tt__RecordingJobStateTracks() { }
};
#endif

#ifndef SOAP_TYPE_tt__RecordingJobStateTrack
#define SOAP_TYPE_tt__RecordingJobStateTrack (490)
/* tt:RecordingJobStateTrack */
class SOAP_CMAC tt__RecordingJobStateTrack
{
public:
	char *SourceTag;	/* required element of type xsd:string */
	char *Destination;	/* required element of type tt:TrackReference */
	char *Error;	/* optional element of type xsd:string */
	char *State;	/* required element of type tt:RecordingJobState */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 490; } /* = unique id SOAP_TYPE_tt__RecordingJobStateTrack */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RecordingJobStateTrack(): SourceTag(NULL), Destination(NULL), Error(NULL), State(NULL), __any(NULL), soap(NULL) { tt__RecordingJobStateTrack::soap_default(NULL); }
	virtual ~tt__RecordingJobStateTrack() { }
};
#endif

#ifndef SOAP_TYPE_tt__GetRecordingJobsResponseItem
#define SOAP_TYPE_tt__GetRecordingJobsResponseItem (491)
/* tt:GetRecordingJobsResponseItem */
class SOAP_CMAC tt__GetRecordingJobsResponseItem
{
public:
	char *JobToken;	/* required element of type tt:RecordingJobReference */
	tt__RecordingJobConfiguration *JobConfiguration;	/* required element of type tt:RecordingJobConfiguration */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 491; } /* = unique id SOAP_TYPE_tt__GetRecordingJobsResponseItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__GetRecordingJobsResponseItem(): JobToken(NULL), JobConfiguration(NULL), __any(NULL), soap(NULL) { tt__GetRecordingJobsResponseItem::soap_default(NULL); }
	virtual ~tt__GetRecordingJobsResponseItem() { }
};
#endif

#ifndef SOAP_TYPE_tt__ReplayConfiguration
#define SOAP_TYPE_tt__ReplayConfiguration (492)
/* tt:ReplayConfiguration */
class SOAP_CMAC tt__ReplayConfiguration
{
public:
	char *SessionTimeout;	/* required element of type xsd:duration */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 492; } /* = unique id SOAP_TYPE_tt__ReplayConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ReplayConfiguration(): SessionTimeout(NULL), __any(NULL), soap(NULL) { tt__ReplayConfiguration::soap_default(NULL); }
	virtual ~tt__ReplayConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration (494)
/* tt:AnalyticsDeviceEngineConfiguration */
class SOAP_CMAC tt__AnalyticsDeviceEngineConfiguration
{
public:
	int __sizeEngineConfiguration;	/* sequence of elements <EngineConfiguration> */
	class tt__EngineConfiguration **EngineConfiguration;	/* required element of type tt:EngineConfiguration */
	class tt__AnalyticsDeviceEngineConfigurationExtension *Extension;	/* optional element of type tt:AnalyticsDeviceEngineConfigurationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 494; } /* = unique id SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsDeviceEngineConfiguration(): EngineConfiguration(NULL), Extension(NULL), soap(NULL) { tt__AnalyticsDeviceEngineConfiguration::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceEngineConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension (495)
/* tt:AnalyticsDeviceEngineConfigurationExtension */
class SOAP_CMAC tt__AnalyticsDeviceEngineConfigurationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 495; } /* = unique id SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsDeviceEngineConfigurationExtension(): __any(NULL), soap(NULL) { tt__AnalyticsDeviceEngineConfigurationExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsDeviceEngineConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__EngineConfiguration
#define SOAP_TYPE_tt__EngineConfiguration (496)
/* tt:EngineConfiguration */
class SOAP_CMAC tt__EngineConfiguration
{
public:
	tt__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;	/* required element of type tt:VideoAnalyticsConfiguration */
	class tt__AnalyticsEngineInputInfo *AnalyticsEngineInputInfo;	/* required element of type tt:AnalyticsEngineInputInfo */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 496; } /* = unique id SOAP_TYPE_tt__EngineConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EngineConfiguration(): VideoAnalyticsConfiguration(NULL), AnalyticsEngineInputInfo(NULL), __any(NULL), soap(NULL) { tt__EngineConfiguration::soap_default(NULL); }
	virtual ~tt__EngineConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngineInputInfo
#define SOAP_TYPE_tt__AnalyticsEngineInputInfo (497)
/* tt:AnalyticsEngineInputInfo */
class SOAP_CMAC tt__AnalyticsEngineInputInfo
{
public:
	tt__Config *InputInfo;	/* optional element of type tt:Config */
	class tt__AnalyticsEngineInputInfoExtension *Extension;	/* optional element of type tt:AnalyticsEngineInputInfoExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 497; } /* = unique id SOAP_TYPE_tt__AnalyticsEngineInputInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsEngineInputInfo(): InputInfo(NULL), Extension(NULL), soap(NULL) { tt__AnalyticsEngineInputInfo::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInputInfo() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension
#define SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension (498)
/* tt:AnalyticsEngineInputInfoExtension */
class SOAP_CMAC tt__AnalyticsEngineInputInfoExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 498; } /* = unique id SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsEngineInputInfoExtension(): __any(NULL), soap(NULL) { tt__AnalyticsEngineInputInfoExtension::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInputInfoExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__SourceIdentification
#define SOAP_TYPE_tt__SourceIdentification (500)
/* tt:SourceIdentification */
class SOAP_CMAC tt__SourceIdentification
{
public:
	char *Name;	/* required element of type xsd:string */
	int __sizeToken;	/* sequence of elements <Token> */
	char **Token;	/* required element of type tt:ReferenceToken */
	class tt__SourceIdentificationExtension *Extension;	/* optional element of type tt:SourceIdentificationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 500; } /* = unique id SOAP_TYPE_tt__SourceIdentification */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SourceIdentification(): Name(NULL), Token(NULL), Extension(NULL), soap(NULL) { tt__SourceIdentification::soap_default(NULL); }
	virtual ~tt__SourceIdentification() { }
};
#endif

#ifndef SOAP_TYPE_tt__SourceIdentificationExtension
#define SOAP_TYPE_tt__SourceIdentificationExtension (501)
/* tt:SourceIdentificationExtension */
class SOAP_CMAC tt__SourceIdentificationExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 501; } /* = unique id SOAP_TYPE_tt__SourceIdentificationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__SourceIdentificationExtension(): __any(NULL), soap(NULL) { tt__SourceIdentificationExtension::soap_default(NULL); }
	virtual ~tt__SourceIdentificationExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataInput
#define SOAP_TYPE_tt__MetadataInput (502)
/* tt:MetadataInput */
class SOAP_CMAC tt__MetadataInput
{
public:
	int __sizeMetadataConfig;	/* sequence of elements <MetadataConfig> */
	tt__Config **MetadataConfig;	/* optional element of type tt:Config */
	class tt__MetadataInputExtension *Extension;	/* optional element of type tt:MetadataInputExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 502; } /* = unique id SOAP_TYPE_tt__MetadataInput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataInput(): MetadataConfig(NULL), Extension(NULL), soap(NULL) { tt__MetadataInput::soap_default(NULL); }
	virtual ~tt__MetadataInput() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataInputExtension
#define SOAP_TYPE_tt__MetadataInputExtension (503)
/* tt:MetadataInputExtension */
class SOAP_CMAC tt__MetadataInputExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 503; } /* = unique id SOAP_TYPE_tt__MetadataInputExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataInputExtension(): __any(NULL), soap(NULL) { tt__MetadataInputExtension::soap_default(NULL); }
	virtual ~tt__MetadataInputExtension() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsStateInformation
#define SOAP_TYPE_tt__AnalyticsStateInformation (505)
/* tt:AnalyticsStateInformation */
class SOAP_CMAC tt__AnalyticsStateInformation
{
public:
	char *AnalyticsEngineControlToken;	/* required element of type tt:ReferenceToken */
	class tt__AnalyticsState *State;	/* required element of type tt:AnalyticsState */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 505; } /* = unique id SOAP_TYPE_tt__AnalyticsStateInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsStateInformation(): AnalyticsEngineControlToken(NULL), State(NULL), __any(NULL), soap(NULL) { tt__AnalyticsStateInformation::soap_default(NULL); }
	virtual ~tt__AnalyticsStateInformation() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsState
#define SOAP_TYPE_tt__AnalyticsState (506)
/* tt:AnalyticsState */
class SOAP_CMAC tt__AnalyticsState
{
public:
	char *Error;	/* optional element of type xsd:string */
	char *State;	/* required element of type xsd:string */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 506; } /* = unique id SOAP_TYPE_tt__AnalyticsState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsState(): Error(NULL), State(NULL), __any(NULL), soap(NULL) { tt__AnalyticsState::soap_default(NULL); }
	virtual ~tt__AnalyticsState() { }
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (1093)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

#ifndef SOAP_TYPE_tt__ActionEngineEventPayload
#define SOAP_TYPE_tt__ActionEngineEventPayload (507)
/* tt:ActionEngineEventPayload */
class SOAP_CMAC tt__ActionEngineEventPayload
{
public:
	char *RequestInfo;	/* optional element of type SOAP-ENV:Envelope */
	char *ResponseInfo;	/* optional element of type SOAP-ENV:Envelope */
	struct SOAP_ENV__Fault *Fault;	/* optional element of type SOAP-ENV:Fault */
	class tt__ActionEngineEventPayloadExtension *Extension;	/* optional element of type tt:ActionEngineEventPayloadExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 507; } /* = unique id SOAP_TYPE_tt__ActionEngineEventPayload */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ActionEngineEventPayload(): RequestInfo(NULL), ResponseInfo(NULL), Fault(NULL), Extension(NULL), soap(NULL) { tt__ActionEngineEventPayload::soap_default(NULL); }
	virtual ~tt__ActionEngineEventPayload() { }
};
#endif

#ifndef SOAP_TYPE_tt__ActionEngineEventPayloadExtension
#define SOAP_TYPE_tt__ActionEngineEventPayloadExtension (508)
/* tt:ActionEngineEventPayloadExtension */
class SOAP_CMAC tt__ActionEngineEventPayloadExtension
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 508; } /* = unique id SOAP_TYPE_tt__ActionEngineEventPayloadExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__ActionEngineEventPayloadExtension(): __any(NULL), soap(NULL) { tt__ActionEngineEventPayloadExtension::soap_default(NULL); }
	virtual ~tt__ActionEngineEventPayloadExtension() { }
};
#endif

#ifndef SOAP_TYPE__tt__Message
#define SOAP_TYPE__tt__Message (509)
/* tt:Message */
class SOAP_CMAC _tt__Message
{
public:
	tt__ItemList *Source;	/* optional element of type tt:ItemList */
	tt__ItemList *Key;	/* optional element of type tt:ItemList */
	tt__ItemList *Data;	/* optional element of type tt:ItemList */
	tt__MessageExtension *Extension;	/* optional element of type tt:MessageExtension */
	time_t UtcTime;	/* required attribute */
	enum tt__PropertyOperation *PropertyOperation;	/* optional attribute */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 509; } /* = unique id SOAP_TYPE__tt__Message */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tt__Message(): Source(NULL), Key(NULL), Data(NULL), Extension(NULL), PropertyOperation(NULL), soap(NULL) { _tt__Message::soap_default(NULL); }
	virtual ~_tt__Message() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__QueryExpressionType
#define SOAP_TYPE_wsnt__QueryExpressionType (512)
/* wsnt:QueryExpressionType */
class SOAP_CMAC wsnt__QueryExpressionType
{
public:
	struct soap_dom_element __any;	/* external */
	char *Dialect;	/* required attribute */
	struct soap_dom_element __mixed;	/* external */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 512; } /* = unique id SOAP_TYPE_wsnt__QueryExpressionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__QueryExpressionType(): Dialect(NULL), soap(NULL) { wsnt__QueryExpressionType::soap_default(NULL); }
	virtual ~wsnt__QueryExpressionType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__TopicExpressionType
#define SOAP_TYPE_wsnt__TopicExpressionType (513)
/* wsnt:TopicExpressionType */
class SOAP_CMAC wsnt__TopicExpressionType
{
public:
	struct soap_dom_element __any;	/* external */
	char *Dialect;	/* required attribute */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap_dom_element __mixed;	/* external */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 513; } /* = unique id SOAP_TYPE_wsnt__TopicExpressionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__TopicExpressionType(): Dialect(NULL), soap(NULL) { wsnt__TopicExpressionType::soap_default(NULL); }
	virtual ~wsnt__TopicExpressionType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__FilterType
#define SOAP_TYPE_wsnt__FilterType (514)
/* wsnt:FilterType */
class SOAP_CMAC wsnt__FilterType
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 514; } /* = unique id SOAP_TYPE_wsnt__FilterType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__FilterType(): __any(NULL), soap(NULL) { wsnt__FilterType::soap_default(NULL); }
	virtual ~wsnt__FilterType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__SubscriptionPolicyType
#define SOAP_TYPE_wsnt__SubscriptionPolicyType (515)
/* wsnt:SubscriptionPolicyType */
class SOAP_CMAC wsnt__SubscriptionPolicyType
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 515; } /* = unique id SOAP_TYPE_wsnt__SubscriptionPolicyType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__SubscriptionPolicyType(): __any(NULL), soap(NULL) { wsnt__SubscriptionPolicyType::soap_default(NULL); }
	virtual ~wsnt__SubscriptionPolicyType() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
#define SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (1100)
/* wsnt:NotificationMessageHolderType-Message */
class SOAP_CMAC _wsnt__NotificationMessageHolderType_Message
{
public:
	struct soap_dom_element __any;	/* external */
public:
	virtual int soap_type() const { return 1100; } /* = unique id SOAP_TYPE__wsnt__NotificationMessageHolderType_Message */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__NotificationMessageHolderType_Message() { _wsnt__NotificationMessageHolderType_Message::soap_default(NULL); }
	virtual ~_wsnt__NotificationMessageHolderType_Message() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__NotificationMessageHolderType
#define SOAP_TYPE_wsnt__NotificationMessageHolderType (516)
/* wsnt:NotificationMessageHolderType */
class SOAP_CMAC wsnt__NotificationMessageHolderType
{
public:
	class wsa5__EndpointReferenceType *SubscriptionReference;	/* optional element of type wsa5:EndpointReferenceType */
	wsnt__TopicExpressionType *Topic;	/* optional element of type wsnt:TopicExpressionType */
	wsa5__EndpointReferenceType *ProducerReference;	/* optional element of type wsa5:EndpointReferenceType */
	_wsnt__NotificationMessageHolderType_Message Message;	/* required element of type wsnt:NotificationMessageHolderType-Message */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 516; } /* = unique id SOAP_TYPE_wsnt__NotificationMessageHolderType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__NotificationMessageHolderType(): SubscriptionReference(NULL), Topic(NULL), ProducerReference(NULL), soap(NULL) { wsnt__NotificationMessageHolderType::soap_default(NULL); }
	virtual ~wsnt__NotificationMessageHolderType() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__NotificationProducerRP
#define SOAP_TYPE__wsnt__NotificationProducerRP (537)
/* wsnt:NotificationProducerRP */
class SOAP_CMAC _wsnt__NotificationProducerRP
{
public:
	int __sizeTopicExpression;	/* sequence of elements <TopicExpression> */
	wsnt__TopicExpressionType **TopicExpression;	/* optional element of type wsnt:TopicExpressionType */
	bool *FixedTopicSet;	/* optional element of type xsd:boolean */
	int __sizeTopicExpressionDialect;	/* sequence of elements <TopicExpressionDialect> */
	char **TopicExpressionDialect;	/* optional element of type xsd:anyURI */
	class wstop__TopicSetType *wstop__TopicSet;	/* optional element of type wstop:TopicSetType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 537; } /* = unique id SOAP_TYPE__wsnt__NotificationProducerRP */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__NotificationProducerRP(): TopicExpression(NULL), FixedTopicSet(NULL), TopicExpressionDialect(NULL), wstop__TopicSet(NULL), soap(NULL) { _wsnt__NotificationProducerRP::soap_default(NULL); }
	virtual ~_wsnt__NotificationProducerRP() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__SubscriptionManagerRP
#define SOAP_TYPE__wsnt__SubscriptionManagerRP (538)
/* wsnt:SubscriptionManagerRP */
class SOAP_CMAC _wsnt__SubscriptionManagerRP
{
public:
	wsa5__EndpointReferenceType *ConsumerReference;	/* required element of type wsa5:EndpointReferenceType */
	wsnt__FilterType *Filter;	/* optional element of type wsnt:FilterType */
	wsnt__SubscriptionPolicyType *SubscriptionPolicy;	/* optional element of type wsnt:SubscriptionPolicyType */
	time_t *CreationTime;	/* optional element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 538; } /* = unique id SOAP_TYPE__wsnt__SubscriptionManagerRP */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__SubscriptionManagerRP(): ConsumerReference(NULL), Filter(NULL), SubscriptionPolicy(NULL), CreationTime(NULL), soap(NULL) { _wsnt__SubscriptionManagerRP::soap_default(NULL); }
	virtual ~_wsnt__SubscriptionManagerRP() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__Notify
#define SOAP_TYPE__wsnt__Notify (539)
/* wsnt:Notify */
class SOAP_CMAC _wsnt__Notify
{
public:
	int __sizeNotificationMessage;	/* sequence of elements <NotificationMessage> */
	wsnt__NotificationMessageHolderType **NotificationMessage;	/* required element of type wsnt:NotificationMessageHolderType */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 539; } /* = unique id SOAP_TYPE__wsnt__Notify */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__Notify(): NotificationMessage(NULL), __any(NULL), soap(NULL) { _wsnt__Notify::soap_default(NULL); }
	virtual ~_wsnt__Notify() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__UseRaw
#define SOAP_TYPE__wsnt__UseRaw (540)
/* wsnt:UseRaw */
class SOAP_CMAC _wsnt__UseRaw
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 540; } /* = unique id SOAP_TYPE__wsnt__UseRaw */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__UseRaw(): soap(NULL) { _wsnt__UseRaw::soap_default(NULL); }
	virtual ~_wsnt__UseRaw() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (1105)
/* wsnt:Subscribe-SubscriptionPolicy */
class SOAP_CMAC _wsnt__Subscribe_SubscriptionPolicy
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
public:
	virtual int soap_type() const { return 1105; } /* = unique id SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__Subscribe_SubscriptionPolicy(): __any(NULL) { _wsnt__Subscribe_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_wsnt__Subscribe_SubscriptionPolicy() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__Subscribe
#define SOAP_TYPE__wsnt__Subscribe (541)
/* wsnt:Subscribe */
class SOAP_CMAC _wsnt__Subscribe
{
public:
	wsa5__EndpointReferenceType *ConsumerReference;	/* required element of type wsa5:EndpointReferenceType */
	wsnt__FilterType *Filter;	/* optional element of type wsnt:FilterType */
	char *InitialTerminationTime;	/* optional element of type wsnt:AbsoluteOrRelativeTimeType */
	_wsnt__Subscribe_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of type wsnt:Subscribe-SubscriptionPolicy */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 541; } /* = unique id SOAP_TYPE__wsnt__Subscribe */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__Subscribe(): ConsumerReference(NULL), Filter(NULL), InitialTerminationTime(NULL), SubscriptionPolicy(NULL), __any(NULL), soap(NULL) { _wsnt__Subscribe::soap_default(NULL); }
	virtual ~_wsnt__Subscribe() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__SubscribeResponse
#define SOAP_TYPE__wsnt__SubscribeResponse (542)
/* wsnt:SubscribeResponse */
class SOAP_CMAC _wsnt__SubscribeResponse
{
public:
	wsa5__EndpointReferenceType *SubscriptionReference;	/* required element of type wsa5:EndpointReferenceType */
	time_t *CurrentTime;	/* optional element of type xsd:dateTime */
	time_t *TerminationTime;	/* optional element of type xsd:dateTime */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 542; } /* = unique id SOAP_TYPE__wsnt__SubscribeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__SubscribeResponse(): SubscriptionReference(NULL), CurrentTime(NULL), TerminationTime(NULL), __any(NULL), soap(NULL) { _wsnt__SubscribeResponse::soap_default(NULL); }
	virtual ~_wsnt__SubscribeResponse() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__GetCurrentMessage
#define SOAP_TYPE__wsnt__GetCurrentMessage (543)
/* wsnt:GetCurrentMessage */
class SOAP_CMAC _wsnt__GetCurrentMessage
{
public:
	wsnt__TopicExpressionType *Topic;	/* required element of type wsnt:TopicExpressionType */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 543; } /* = unique id SOAP_TYPE__wsnt__GetCurrentMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__GetCurrentMessage(): Topic(NULL), __any(NULL), soap(NULL) { _wsnt__GetCurrentMessage::soap_default(NULL); }
	virtual ~_wsnt__GetCurrentMessage() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__GetCurrentMessageResponse
#define SOAP_TYPE__wsnt__GetCurrentMessageResponse (544)
/* wsnt:GetCurrentMessageResponse */
class SOAP_CMAC _wsnt__GetCurrentMessageResponse
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 544; } /* = unique id SOAP_TYPE__wsnt__GetCurrentMessageResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__GetCurrentMessageResponse(): __any(NULL), soap(NULL) { _wsnt__GetCurrentMessageResponse::soap_default(NULL); }
	virtual ~_wsnt__GetCurrentMessageResponse() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__GetMessages
#define SOAP_TYPE__wsnt__GetMessages (545)
/* wsnt:GetMessages */
class SOAP_CMAC _wsnt__GetMessages
{
public:
	char *MaximumNumber;	/* optional element of type xsd:nonNegativeInteger */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 545; } /* = unique id SOAP_TYPE__wsnt__GetMessages */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__GetMessages(): MaximumNumber(NULL), __any(NULL), soap(NULL) { _wsnt__GetMessages::soap_default(NULL); }
	virtual ~_wsnt__GetMessages() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__GetMessagesResponse
#define SOAP_TYPE__wsnt__GetMessagesResponse (546)
/* wsnt:GetMessagesResponse */
class SOAP_CMAC _wsnt__GetMessagesResponse
{
public:
	int __sizeNotificationMessage;	/* sequence of elements <NotificationMessage> */
	wsnt__NotificationMessageHolderType **NotificationMessage;	/* optional element of type wsnt:NotificationMessageHolderType */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 546; } /* = unique id SOAP_TYPE__wsnt__GetMessagesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__GetMessagesResponse(): NotificationMessage(NULL), __any(NULL), soap(NULL) { _wsnt__GetMessagesResponse::soap_default(NULL); }
	virtual ~_wsnt__GetMessagesResponse() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__DestroyPullPoint
#define SOAP_TYPE__wsnt__DestroyPullPoint (547)
/* wsnt:DestroyPullPoint */
class SOAP_CMAC _wsnt__DestroyPullPoint
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 547; } /* = unique id SOAP_TYPE__wsnt__DestroyPullPoint */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__DestroyPullPoint(): __any(NULL), soap(NULL) { _wsnt__DestroyPullPoint::soap_default(NULL); }
	virtual ~_wsnt__DestroyPullPoint() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__DestroyPullPointResponse
#define SOAP_TYPE__wsnt__DestroyPullPointResponse (548)
/* wsnt:DestroyPullPointResponse */
class SOAP_CMAC _wsnt__DestroyPullPointResponse
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 548; } /* = unique id SOAP_TYPE__wsnt__DestroyPullPointResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__DestroyPullPointResponse(): __any(NULL), soap(NULL) { _wsnt__DestroyPullPointResponse::soap_default(NULL); }
	virtual ~_wsnt__DestroyPullPointResponse() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__CreatePullPoint
#define SOAP_TYPE__wsnt__CreatePullPoint (549)
/* wsnt:CreatePullPoint */
class SOAP_CMAC _wsnt__CreatePullPoint
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 549; } /* = unique id SOAP_TYPE__wsnt__CreatePullPoint */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__CreatePullPoint(): __any(NULL), soap(NULL) { _wsnt__CreatePullPoint::soap_default(NULL); }
	virtual ~_wsnt__CreatePullPoint() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__CreatePullPointResponse
#define SOAP_TYPE__wsnt__CreatePullPointResponse (550)
/* wsnt:CreatePullPointResponse */
class SOAP_CMAC _wsnt__CreatePullPointResponse
{
public:
	wsa5__EndpointReferenceType *PullPoint;	/* required element of type wsa5:EndpointReferenceType */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 550; } /* = unique id SOAP_TYPE__wsnt__CreatePullPointResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__CreatePullPointResponse(): PullPoint(NULL), __any(NULL), soap(NULL) { _wsnt__CreatePullPointResponse::soap_default(NULL); }
	virtual ~_wsnt__CreatePullPointResponse() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__Renew
#define SOAP_TYPE__wsnt__Renew (551)
/* wsnt:Renew */
class SOAP_CMAC _wsnt__Renew
{
public:
	char *TerminationTime;	/* required element of type wsnt:AbsoluteOrRelativeTimeType */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 551; } /* = unique id SOAP_TYPE__wsnt__Renew */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__Renew(): TerminationTime(NULL), __any(NULL), soap(NULL) { _wsnt__Renew::soap_default(NULL); }
	virtual ~_wsnt__Renew() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__RenewResponse
#define SOAP_TYPE__wsnt__RenewResponse (552)
/* wsnt:RenewResponse */
class SOAP_CMAC _wsnt__RenewResponse
{
public:
	time_t TerminationTime;	/* required element of type xsd:dateTime */
	time_t *CurrentTime;	/* optional element of type xsd:dateTime */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 552; } /* = unique id SOAP_TYPE__wsnt__RenewResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__RenewResponse(): CurrentTime(NULL), __any(NULL), soap(NULL) { _wsnt__RenewResponse::soap_default(NULL); }
	virtual ~_wsnt__RenewResponse() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__Unsubscribe
#define SOAP_TYPE__wsnt__Unsubscribe (553)
/* wsnt:Unsubscribe */
class SOAP_CMAC _wsnt__Unsubscribe
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 553; } /* = unique id SOAP_TYPE__wsnt__Unsubscribe */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__Unsubscribe(): __any(NULL), soap(NULL) { _wsnt__Unsubscribe::soap_default(NULL); }
	virtual ~_wsnt__Unsubscribe() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__UnsubscribeResponse
#define SOAP_TYPE__wsnt__UnsubscribeResponse (554)
/* wsnt:UnsubscribeResponse */
class SOAP_CMAC _wsnt__UnsubscribeResponse
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 554; } /* = unique id SOAP_TYPE__wsnt__UnsubscribeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__UnsubscribeResponse(): __any(NULL), soap(NULL) { _wsnt__UnsubscribeResponse::soap_default(NULL); }
	virtual ~_wsnt__UnsubscribeResponse() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__PauseSubscription
#define SOAP_TYPE__wsnt__PauseSubscription (555)
/* wsnt:PauseSubscription */
class SOAP_CMAC _wsnt__PauseSubscription
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 555; } /* = unique id SOAP_TYPE__wsnt__PauseSubscription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__PauseSubscription(): __any(NULL), soap(NULL) { _wsnt__PauseSubscription::soap_default(NULL); }
	virtual ~_wsnt__PauseSubscription() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__PauseSubscriptionResponse
#define SOAP_TYPE__wsnt__PauseSubscriptionResponse (556)
/* wsnt:PauseSubscriptionResponse */
class SOAP_CMAC _wsnt__PauseSubscriptionResponse
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 556; } /* = unique id SOAP_TYPE__wsnt__PauseSubscriptionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__PauseSubscriptionResponse(): __any(NULL), soap(NULL) { _wsnt__PauseSubscriptionResponse::soap_default(NULL); }
	virtual ~_wsnt__PauseSubscriptionResponse() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__ResumeSubscription
#define SOAP_TYPE__wsnt__ResumeSubscription (557)
/* wsnt:ResumeSubscription */
class SOAP_CMAC _wsnt__ResumeSubscription
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 557; } /* = unique id SOAP_TYPE__wsnt__ResumeSubscription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__ResumeSubscription(): __any(NULL), soap(NULL) { _wsnt__ResumeSubscription::soap_default(NULL); }
	virtual ~_wsnt__ResumeSubscription() { }
};
#endif

#ifndef SOAP_TYPE__wsnt__ResumeSubscriptionResponse
#define SOAP_TYPE__wsnt__ResumeSubscriptionResponse (558)
/* wsnt:ResumeSubscriptionResponse */
class SOAP_CMAC _wsnt__ResumeSubscriptionResponse
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 558; } /* = unique id SOAP_TYPE__wsnt__ResumeSubscriptionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsnt__ResumeSubscriptionResponse(): __any(NULL), soap(NULL) { _wsnt__ResumeSubscriptionResponse::soap_default(NULL); }
	virtual ~_wsnt__ResumeSubscriptionResponse() { }
};
#endif

#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (560)
/* wsa5:EndpointReferenceType */
class SOAP_CMAC wsa5__EndpointReferenceType
{
public:
	class wsa5__AttributedURIType *Address;	/* required element of type wsa5:AttributedURIType */
	class wsa5__ReferenceParametersType *ReferenceParameters;	/* optional element of type wsa5:ReferenceParametersType */
	class wsa5__MetadataType *Metadata;	/* optional element of type wsa5:MetadataType */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 560; } /* = unique id SOAP_TYPE_wsa5__EndpointReferenceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsa5__EndpointReferenceType(): Address(NULL), ReferenceParameters(NULL), Metadata(NULL), __any(NULL), soap(NULL) { wsa5__EndpointReferenceType::soap_default(NULL); }
	virtual ~wsa5__EndpointReferenceType() { }
};
#endif

#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (561)
/* wsa5:ReferenceParametersType */
class SOAP_CMAC wsa5__ReferenceParametersType
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 561; } /* = unique id SOAP_TYPE_wsa5__ReferenceParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsa5__ReferenceParametersType(): __any(NULL), soap(NULL) { wsa5__ReferenceParametersType::soap_default(NULL); }
	virtual ~wsa5__ReferenceParametersType() { }
};
#endif

#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (562)
/* wsa5:MetadataType */
class SOAP_CMAC wsa5__MetadataType
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 562; } /* = unique id SOAP_TYPE_wsa5__MetadataType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsa5__MetadataType(): __any(NULL), soap(NULL) { wsa5__MetadataType::soap_default(NULL); }
	virtual ~wsa5__MetadataType() { }
};
#endif

#ifndef SOAP_TYPE_wsa5__AttributedAnyType
#define SOAP_TYPE_wsa5__AttributedAnyType (567)
/* wsa5:AttributedAnyType */
class SOAP_CMAC wsa5__AttributedAnyType
{
public:
	struct soap_dom_element __any;	/* external */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 567; } /* = unique id SOAP_TYPE_wsa5__AttributedAnyType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsa5__AttributedAnyType(): soap(NULL) { wsa5__AttributedAnyType::soap_default(NULL); }
	virtual ~wsa5__AttributedAnyType() { }
};
#endif

#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (568)
/* wsa5:ProblemActionType */
class SOAP_CMAC wsa5__ProblemActionType
{
public:
	wsa5__AttributedURIType *Action;	/* optional element of type wsa5:AttributedURIType */
	char *SoapAction;	/* optional element of type xsd:anyURI */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 568; } /* = unique id SOAP_TYPE_wsa5__ProblemActionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsa5__ProblemActionType(): Action(NULL), SoapAction(NULL), soap(NULL) { wsa5__ProblemActionType::soap_default(NULL); }
	virtual ~wsa5__ProblemActionType() { }
};
#endif

#ifndef SOAP_TYPE__wsbf__BaseFaultType_ErrorCode
#define SOAP_TYPE__wsbf__BaseFaultType_ErrorCode (1110)
/* wsbf:BaseFaultType-ErrorCode */
class SOAP_CMAC _wsbf__BaseFaultType_ErrorCode
{
public:
	char *dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1110; } /* = unique id SOAP_TYPE__wsbf__BaseFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsbf__BaseFaultType_ErrorCode(): dialect(NULL) { _wsbf__BaseFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_wsbf__BaseFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__wsbf__BaseFaultType_Description
#define SOAP_TYPE__wsbf__BaseFaultType_Description (1112)
/* Primitive wsbf:BaseFaultType-Description schema type: */
class SOAP_CMAC _wsbf__BaseFaultType_Description
{
public:
	char *__item;
	char *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1112; } /* = unique id SOAP_TYPE__wsbf__BaseFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsbf__BaseFaultType_Description(): __item(NULL), xml__lang(NULL) { _wsbf__BaseFaultType_Description::soap_default(NULL); }
	virtual ~_wsbf__BaseFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__wsbf__BaseFaultType_FaultCause
#define SOAP_TYPE__wsbf__BaseFaultType_FaultCause (1114)
/* wsbf:BaseFaultType-FaultCause */
class SOAP_CMAC _wsbf__BaseFaultType_FaultCause
{
public:
	struct soap_dom_element __any;	/* external */
public:
	virtual int soap_type() const { return 1114; } /* = unique id SOAP_TYPE__wsbf__BaseFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wsbf__BaseFaultType_FaultCause() { _wsbf__BaseFaultType_FaultCause::soap_default(NULL); }
	virtual ~_wsbf__BaseFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_wsbf__BaseFaultType
#define SOAP_TYPE_wsbf__BaseFaultType (569)
/* wsbf:BaseFaultType */
class SOAP_CMAC wsbf__BaseFaultType
{
public:
	time_t Timestamp;	/* required element of type xsd:dateTime */
	wsa5__EndpointReferenceType *Originator;	/* optional element of type wsa5:EndpointReferenceType */
	_wsbf__BaseFaultType_ErrorCode *ErrorCode;	/* optional element of type wsbf:BaseFaultType-ErrorCode */
	int __sizeDescription;	/* sequence of elements <Description> */
	_wsbf__BaseFaultType_Description *Description;	/* optional element of type wsbf:BaseFaultType-Description */
	_wsbf__BaseFaultType_FaultCause *FaultCause;	/* optional element of type wsbf:BaseFaultType-FaultCause */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 569; } /* = unique id SOAP_TYPE_wsbf__BaseFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsbf__BaseFaultType(): Originator(NULL), ErrorCode(NULL), Description(NULL), FaultCause(NULL), __any(NULL), soap(NULL) { wsbf__BaseFaultType::soap_default(NULL); }
	virtual ~wsbf__BaseFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wstop__Documentation
#define SOAP_TYPE_wstop__Documentation (570)
/* wstop:Documentation */
class SOAP_CMAC wstop__Documentation
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_element __mixed;	/* external */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 570; } /* = unique id SOAP_TYPE_wstop__Documentation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wstop__Documentation(): __any(NULL), soap(NULL) { wstop__Documentation::soap_default(NULL); }
	virtual ~wstop__Documentation() { }
};
#endif

#ifndef SOAP_TYPE_wstop__ExtensibleDocumented
#define SOAP_TYPE_wstop__ExtensibleDocumented (571)
/* wstop:ExtensibleDocumented */
class SOAP_CMAC wstop__ExtensibleDocumented
{
public:
	wstop__Documentation *documentation;	/* optional element of type wstop:Documentation */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 571; } /* = unique id SOAP_TYPE_wstop__ExtensibleDocumented */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wstop__ExtensibleDocumented(): documentation(NULL), soap(NULL) { wstop__ExtensibleDocumented::soap_default(NULL); }
	virtual ~wstop__ExtensibleDocumented() { }
};
#endif

#ifndef SOAP_TYPE_wstop__QueryExpressionType
#define SOAP_TYPE_wstop__QueryExpressionType (572)
/* wstop:QueryExpressionType */
class SOAP_CMAC wstop__QueryExpressionType
{
public:
	struct soap_dom_element __any;	/* external */
	char *Dialect;	/* required attribute */
	struct soap_dom_element __mixed;	/* external */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 572; } /* = unique id SOAP_TYPE_wstop__QueryExpressionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wstop__QueryExpressionType(): Dialect(NULL), soap(NULL) { wstop__QueryExpressionType::soap_default(NULL); }
	virtual ~wstop__QueryExpressionType() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSource
#define SOAP_TYPE_tt__VideoSource (89)
/* tt:VideoSource */
class SOAP_CMAC tt__VideoSource : public tt__DeviceEntity
{
public:
	float Framerate;	/* required element of type xsd:float */
	tt__VideoResolution *Resolution;	/* required element of type tt:VideoResolution */
	tt__ImagingSettings *Imaging;	/* optional element of type tt:ImagingSettings */
	tt__VideoSourceExtension *Extension;	/* optional element of type tt:VideoSourceExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 89; } /* = unique id SOAP_TYPE_tt__VideoSource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSource(): Resolution(NULL), Imaging(NULL), Extension(NULL) { tt__VideoSource::soap_default(NULL); }
	virtual ~tt__VideoSource() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioSource
#define SOAP_TYPE_tt__AudioSource (92)
/* tt:AudioSource */
class SOAP_CMAC tt__AudioSource : public tt__DeviceEntity
{
public:
	int Channels;	/* required element of type xsd:int */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 92; } /* = unique id SOAP_TYPE_tt__AudioSource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioSource(): __any(NULL) { tt__AudioSource::soap_default(NULL); }
	virtual ~tt__AudioSource() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoSourceConfiguration
#define SOAP_TYPE_tt__VideoSourceConfiguration (97)
/* tt:VideoSourceConfiguration */
class SOAP_CMAC tt__VideoSourceConfiguration : public tt__ConfigurationEntity
{
public:
	char *SourceToken;	/* required element of type tt:ReferenceToken */
	tt__IntRectangle *Bounds;	/* required element of type tt:IntRectangle */
	tt__VideoSourceConfigurationExtension *Extension;	/* optional element of type tt:VideoSourceConfigurationExtension */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 97; } /* = unique id SOAP_TYPE_tt__VideoSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoSourceConfiguration(): SourceToken(NULL), Bounds(NULL), Extension(NULL), __any(NULL) { tt__VideoSourceConfiguration::soap_default(NULL); }
	virtual ~tt__VideoSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoEncoderConfiguration
#define SOAP_TYPE_tt__VideoEncoderConfiguration (107)
/* tt:VideoEncoderConfiguration */
class SOAP_CMAC tt__VideoEncoderConfiguration : public tt__ConfigurationEntity
{
public:
	enum tt__VideoEncoding Encoding;	/* required element of type tt:VideoEncoding */
	tt__VideoResolution *Resolution;	/* required element of type tt:VideoResolution */
	float Quality;	/* required element of type xsd:float */
	tt__VideoRateControl *RateControl;	/* optional element of type tt:VideoRateControl */
	tt__Mpeg4Configuration *MPEG4;	/* optional element of type tt:Mpeg4Configuration */
	tt__H264Configuration *H264;	/* optional element of type tt:H264Configuration */
	tt__MulticastConfiguration *Multicast;	/* required element of type tt:MulticastConfiguration */
	char *SessionTimeout;	/* required element of type xsd:duration */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 107; } /* = unique id SOAP_TYPE_tt__VideoEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoEncoderConfiguration(): Resolution(NULL), RateControl(NULL), MPEG4(NULL), H264(NULL), Multicast(NULL), SessionTimeout(NULL), __any(NULL) { tt__VideoEncoderConfiguration::soap_default(NULL); }
	virtual ~tt__VideoEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__JpegOptions2
#define SOAP_TYPE_tt__JpegOptions2 (116)
/* tt:JpegOptions2 */
class SOAP_CMAC tt__JpegOptions2 : public tt__JpegOptions
{
public:
	tt__IntRange *BitrateRange;	/* required element of type tt:IntRange */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 116; } /* = unique id SOAP_TYPE_tt__JpegOptions2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__JpegOptions2(): BitrateRange(NULL), __any(NULL) { tt__JpegOptions2::soap_default(NULL); }
	virtual ~tt__JpegOptions2() { }
};
#endif

#ifndef SOAP_TYPE_tt__Mpeg4Options2
#define SOAP_TYPE_tt__Mpeg4Options2 (118)
/* tt:Mpeg4Options2 */
class SOAP_CMAC tt__Mpeg4Options2 : public tt__Mpeg4Options
{
public:
	tt__IntRange *BitrateRange;	/* required element of type tt:IntRange */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 118; } /* = unique id SOAP_TYPE_tt__Mpeg4Options2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Mpeg4Options2(): BitrateRange(NULL), __any(NULL) { tt__Mpeg4Options2::soap_default(NULL); }
	virtual ~tt__Mpeg4Options2() { }
};
#endif

#ifndef SOAP_TYPE_tt__H264Options2
#define SOAP_TYPE_tt__H264Options2 (120)
/* tt:H264Options2 */
class SOAP_CMAC tt__H264Options2 : public tt__H264Options
{
public:
	tt__IntRange *BitrateRange;	/* required element of type tt:IntRange */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 120; } /* = unique id SOAP_TYPE_tt__H264Options2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__H264Options2(): BitrateRange(NULL), __any(NULL) { tt__H264Options2::soap_default(NULL); }
	virtual ~tt__H264Options2() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioSourceConfiguration
#define SOAP_TYPE_tt__AudioSourceConfiguration (121)
/* tt:AudioSourceConfiguration */
class SOAP_CMAC tt__AudioSourceConfiguration : public tt__ConfigurationEntity
{
public:
	char *SourceToken;	/* required element of type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 121; } /* = unique id SOAP_TYPE_tt__AudioSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioSourceConfiguration(): SourceToken(NULL), __any(NULL) { tt__AudioSourceConfiguration::soap_default(NULL); }
	virtual ~tt__AudioSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioEncoderConfiguration
#define SOAP_TYPE_tt__AudioEncoderConfiguration (124)
/* tt:AudioEncoderConfiguration */
class SOAP_CMAC tt__AudioEncoderConfiguration : public tt__ConfigurationEntity
{
public:
	enum tt__AudioEncoding Encoding;	/* required element of type tt:AudioEncoding */
	int Bitrate;	/* required element of type xsd:int */
	int SampleRate;	/* required element of type xsd:int */
	tt__MulticastConfiguration *Multicast;	/* required element of type tt:MulticastConfiguration */
	char *SessionTimeout;	/* required element of type xsd:duration */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 124; } /* = unique id SOAP_TYPE_tt__AudioEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioEncoderConfiguration(): Multicast(NULL), SessionTimeout(NULL), __any(NULL) { tt__AudioEncoderConfiguration::soap_default(NULL); }
	virtual ~tt__AudioEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoAnalyticsConfiguration
#define SOAP_TYPE_tt__VideoAnalyticsConfiguration (127)
/* tt:VideoAnalyticsConfiguration */
class SOAP_CMAC tt__VideoAnalyticsConfiguration : public tt__ConfigurationEntity
{
public:
	tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;	/* required element of type tt:AnalyticsEngineConfiguration */
	tt__RuleEngineConfiguration *RuleEngineConfiguration;	/* required element of type tt:RuleEngineConfiguration */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 127; } /* = unique id SOAP_TYPE_tt__VideoAnalyticsConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoAnalyticsConfiguration(): AnalyticsEngineConfiguration(NULL), RuleEngineConfiguration(NULL), __any(NULL) { tt__VideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~tt__VideoAnalyticsConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__MetadataConfiguration
#define SOAP_TYPE_tt__MetadataConfiguration (128)
/* tt:MetadataConfiguration */
class SOAP_CMAC tt__MetadataConfiguration : public tt__ConfigurationEntity
{
public:
	tt__PTZFilter *PTZStatus;	/* optional element of type tt:PTZFilter */
	tt__EventSubscription *Events;	/* optional element of type tt:EventSubscription */
	bool *Analytics;	/* optional element of type xsd:boolean */
	tt__MulticastConfiguration *Multicast;	/* required element of type tt:MulticastConfiguration */
	char *SessionTimeout;	/* required element of type xsd:duration */
	tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;	/* optional element of type tt:AnalyticsEngineConfiguration */
	tt__MetadataConfigurationExtension *Extension;	/* optional element of type tt:MetadataConfigurationExtension */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 128; } /* = unique id SOAP_TYPE_tt__MetadataConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__MetadataConfiguration(): PTZStatus(NULL), Events(NULL), Analytics(NULL), Multicast(NULL), SessionTimeout(NULL), AnalyticsEngineConfiguration(NULL), Extension(NULL), __any(NULL) { tt__MetadataConfiguration::soap_default(NULL); }
	virtual ~tt__MetadataConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoOutput
#define SOAP_TYPE_tt__VideoOutput (135)
/* tt:VideoOutput */
class SOAP_CMAC tt__VideoOutput : public tt__DeviceEntity
{
public:
	tt__Layout *Layout;	/* required element of type tt:Layout */
	tt__VideoResolution *Resolution;	/* optional element of type tt:VideoResolution */
	float *RefreshRate;	/* optional element of type xsd:float */
	float *AspectRatio;	/* optional element of type xsd:float */
	tt__VideoOutputExtension *Extension;	/* optional element of type tt:VideoOutputExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 135; } /* = unique id SOAP_TYPE_tt__VideoOutput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoOutput(): Layout(NULL), Resolution(NULL), RefreshRate(NULL), AspectRatio(NULL), Extension(NULL) { tt__VideoOutput::soap_default(NULL); }
	virtual ~tt__VideoOutput() { }
};
#endif

#ifndef SOAP_TYPE_tt__VideoOutputConfiguration
#define SOAP_TYPE_tt__VideoOutputConfiguration (137)
/* tt:VideoOutputConfiguration */
class SOAP_CMAC tt__VideoOutputConfiguration : public tt__ConfigurationEntity
{
public:
	char *OutputToken;	/* required element of type tt:ReferenceToken */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 137; } /* = unique id SOAP_TYPE_tt__VideoOutputConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__VideoOutputConfiguration(): OutputToken(NULL), __any(NULL) { tt__VideoOutputConfiguration::soap_default(NULL); }
	virtual ~tt__VideoOutputConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioOutput
#define SOAP_TYPE_tt__AudioOutput (144)
/* tt:AudioOutput */
class SOAP_CMAC tt__AudioOutput : public tt__DeviceEntity
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 144; } /* = unique id SOAP_TYPE_tt__AudioOutput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioOutput(): __any(NULL) { tt__AudioOutput::soap_default(NULL); }
	virtual ~tt__AudioOutput() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioOutputConfiguration
#define SOAP_TYPE_tt__AudioOutputConfiguration (145)
/* tt:AudioOutputConfiguration */
class SOAP_CMAC tt__AudioOutputConfiguration : public tt__ConfigurationEntity
{
public:
	char *OutputToken;	/* required element of type tt:ReferenceToken */
	char *SendPrimacy;	/* optional element of type xsd:anyURI */
	int OutputLevel;	/* required element of type xsd:int */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 145; } /* = unique id SOAP_TYPE_tt__AudioOutputConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioOutputConfiguration(): OutputToken(NULL), SendPrimacy(NULL), __any(NULL) { tt__AudioOutputConfiguration::soap_default(NULL); }
	virtual ~tt__AudioOutputConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__AudioDecoderConfiguration
#define SOAP_TYPE_tt__AudioDecoderConfiguration (147)
/* tt:AudioDecoderConfiguration */
class SOAP_CMAC tt__AudioDecoderConfiguration : public tt__ConfigurationEntity
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 147; } /* = unique id SOAP_TYPE_tt__AudioDecoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AudioDecoderConfiguration(): __any(NULL) { tt__AudioDecoderConfiguration::soap_default(NULL); }
	virtual ~tt__AudioDecoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__NetworkInterface
#define SOAP_TYPE_tt__NetworkInterface (158)
/* tt:NetworkInterface */
class SOAP_CMAC tt__NetworkInterface : public tt__DeviceEntity
{
public:
	bool Enabled;	/* required element of type xsd:boolean */
	tt__NetworkInterfaceInfo *Info;	/* optional element of type tt:NetworkInterfaceInfo */
	tt__NetworkInterfaceLink *Link;	/* optional element of type tt:NetworkInterfaceLink */
	tt__IPv4NetworkInterface *IPv4;	/* optional element of type tt:IPv4NetworkInterface */
	tt__IPv6NetworkInterface *IPv6;	/* optional element of type tt:IPv6NetworkInterface */
	tt__NetworkInterfaceExtension *Extension;	/* optional element of type tt:NetworkInterfaceExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 158; } /* = unique id SOAP_TYPE_tt__NetworkInterface */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__NetworkInterface(): Info(NULL), Link(NULL), IPv4(NULL), IPv6(NULL), Extension(NULL) { tt__NetworkInterface::soap_default(NULL); }
	virtual ~tt__NetworkInterface() { }
};
#endif

#ifndef SOAP_TYPE_tt__CertificateUsage
#define SOAP_TYPE_tt__CertificateUsage (262)
/* Primitive tt:CertificateUsage schema type: */
class SOAP_CMAC tt__CertificateUsage
{
public:
	char *__item;
	bool Critical;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 262; } /* = unique id SOAP_TYPE_tt__CertificateUsage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__CertificateUsage(): __item(NULL), soap(NULL) { tt__CertificateUsage::soap_default(NULL); }
	virtual ~tt__CertificateUsage() { }
};
#endif

#ifndef SOAP_TYPE_tt__RelayOutput
#define SOAP_TYPE_tt__RelayOutput (271)
/* tt:RelayOutput */
class SOAP_CMAC tt__RelayOutput : public tt__DeviceEntity
{
public:
	tt__RelayOutputSettings *Properties;	/* required element of type tt:RelayOutputSettings */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 271; } /* = unique id SOAP_TYPE_tt__RelayOutput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__RelayOutput(): Properties(NULL), __any(NULL) { tt__RelayOutput::soap_default(NULL); }
	virtual ~tt__RelayOutput() { }
};
#endif

#ifndef SOAP_TYPE_tt__DigitalInput
#define SOAP_TYPE_tt__DigitalInput (272)
/* tt:DigitalInput */
class SOAP_CMAC tt__DigitalInput : public tt__DeviceEntity
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 272; } /* = unique id SOAP_TYPE_tt__DigitalInput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__DigitalInput(): __any(NULL) { tt__DigitalInput::soap_default(NULL); }
	virtual ~tt__DigitalInput() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZNode
#define SOAP_TYPE_tt__PTZNode (273)
/* tt:PTZNode */
class SOAP_CMAC tt__PTZNode : public tt__DeviceEntity
{
public:
	char *Name;	/* optional element of type tt:Name */
	tt__PTZSpaces *SupportedPTZSpaces;	/* required element of type tt:PTZSpaces */
	int MaximumNumberOfPresets;	/* required element of type xsd:int */
	bool HomeSupported;	/* required element of type xsd:boolean */
	int __sizeAuxiliaryCommands;	/* sequence of elements <AuxiliaryCommands> */
	char **AuxiliaryCommands;	/* optional element of type tt:AuxiliaryData */
	tt__PTZNodeExtension *Extension;	/* optional element of type tt:PTZNodeExtension */
	bool *FixedHomePosition;	/* optional attribute */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 273; } /* = unique id SOAP_TYPE_tt__PTZNode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZNode(): Name(NULL), SupportedPTZSpaces(NULL), AuxiliaryCommands(NULL), Extension(NULL), FixedHomePosition(NULL) { tt__PTZNode::soap_default(NULL); }
	virtual ~tt__PTZNode() { }
};
#endif

#ifndef SOAP_TYPE_tt__PTZConfiguration
#define SOAP_TYPE_tt__PTZConfiguration (278)
/* tt:PTZConfiguration */
class SOAP_CMAC tt__PTZConfiguration : public tt__ConfigurationEntity
{
public:
	char *NodeToken;	/* required element of type tt:ReferenceToken */
	char *DefaultAbsolutePantTiltPositionSpace;	/* optional element of type xsd:anyURI */
	char *DefaultAbsoluteZoomPositionSpace;	/* optional element of type xsd:anyURI */
	char *DefaultRelativePanTiltTranslationSpace;	/* optional element of type xsd:anyURI */
	char *DefaultRelativeZoomTranslationSpace;	/* optional element of type xsd:anyURI */
	char *DefaultContinuousPanTiltVelocitySpace;	/* optional element of type xsd:anyURI */
	char *DefaultContinuousZoomVelocitySpace;	/* optional element of type xsd:anyURI */
	tt__PTZSpeed *DefaultPTZSpeed;	/* optional element of type tt:PTZSpeed */
	char *DefaultPTZTimeout;	/* optional element of type xsd:duration */
	tt__PanTiltLimits *PanTiltLimits;	/* optional element of type tt:PanTiltLimits */
	tt__ZoomLimits *ZoomLimits;	/* optional element of type tt:ZoomLimits */
	tt__PTZConfigurationExtension *Extension;	/* optional element of type tt:PTZConfigurationExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 278; } /* = unique id SOAP_TYPE_tt__PTZConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__PTZConfiguration(): NodeToken(NULL), DefaultAbsolutePantTiltPositionSpace(NULL), DefaultAbsoluteZoomPositionSpace(NULL), DefaultRelativePanTiltTranslationSpace(NULL), DefaultRelativeZoomTranslationSpace(NULL), DefaultContinuousPanTiltVelocitySpace(NULL), DefaultContinuousZoomVelocitySpace(NULL), DefaultPTZSpeed(NULL), DefaultPTZTimeout(NULL), PanTiltLimits(NULL), ZoomLimits(NULL), Extension(NULL) { tt__PTZConfiguration::soap_default(NULL); }
	virtual ~tt__PTZConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_tt__Object
#define SOAP_TYPE_tt__Object (398)
/* tt:Object */
class SOAP_CMAC tt__Object : public tt__ObjectId
{
public:
	tt__Appearance *Appearance;	/* optional element of type tt:Appearance */
	tt__Behaviour *Behaviour;	/* optional element of type tt:Behaviour */
	tt__ObjectExtension *Extension;	/* optional element of type tt:ObjectExtension */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 398; } /* = unique id SOAP_TYPE_tt__Object */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__Object(): Appearance(NULL), Behaviour(NULL), Extension(NULL) { tt__Object::soap_default(NULL); }
	virtual ~tt__Object() { }
};
#endif

#ifndef SOAP_TYPE_tt__EventFilter
#define SOAP_TYPE_tt__EventFilter (457)
/* tt:EventFilter */
class SOAP_CMAC tt__EventFilter : public wsnt__FilterType
{
public:
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 457; } /* = unique id SOAP_TYPE_tt__EventFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__EventFilter() { tt__EventFilter::soap_default(NULL); }
	virtual ~tt__EventFilter() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngine
#define SOAP_TYPE_tt__AnalyticsEngine (493)
/* tt:AnalyticsEngine */
class SOAP_CMAC tt__AnalyticsEngine : public tt__ConfigurationEntity
{
public:
	tt__AnalyticsDeviceEngineConfiguration *AnalyticsEngineConfiguration;	/* required element of type tt:AnalyticsDeviceEngineConfiguration */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 493; } /* = unique id SOAP_TYPE_tt__AnalyticsEngine */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsEngine(): AnalyticsEngineConfiguration(NULL), __any(NULL) { tt__AnalyticsEngine::soap_default(NULL); }
	virtual ~tt__AnalyticsEngine() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngineInput
#define SOAP_TYPE_tt__AnalyticsEngineInput (499)
/* tt:AnalyticsEngineInput */
class SOAP_CMAC tt__AnalyticsEngineInput : public tt__ConfigurationEntity
{
public:
	tt__SourceIdentification *SourceIdentification;	/* required element of type tt:SourceIdentification */
	tt__VideoEncoderConfiguration *VideoInput;	/* required element of type tt:VideoEncoderConfiguration */
	tt__MetadataInput *MetadataInput;	/* required element of type tt:MetadataInput */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 499; } /* = unique id SOAP_TYPE_tt__AnalyticsEngineInput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsEngineInput(): SourceIdentification(NULL), VideoInput(NULL), MetadataInput(NULL), __any(NULL) { tt__AnalyticsEngineInput::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineInput() { }
};
#endif

#ifndef SOAP_TYPE_tt__AnalyticsEngineControl
#define SOAP_TYPE_tt__AnalyticsEngineControl (504)
/* tt:AnalyticsEngineControl */
class SOAP_CMAC tt__AnalyticsEngineControl : public tt__ConfigurationEntity
{
public:
	char *EngineToken;	/* required element of type tt:ReferenceToken */
	char *EngineConfigToken;	/* required element of type tt:ReferenceToken */
	int __sizeInputToken;	/* sequence of elements <InputToken> */
	char **InputToken;	/* required element of type tt:ReferenceToken */
	int __sizeReceiverToken;	/* sequence of elements <ReceiverToken> */
	char **ReceiverToken;	/* required element of type tt:ReferenceToken */
	tt__MulticastConfiguration *Multicast;	/* optional element of type tt:MulticastConfiguration */
	tt__Config *Subscription;	/* required element of type tt:Config */
	enum tt__ModeOfOperation Mode;	/* required element of type tt:ModeOfOperation */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
public:
	virtual int soap_type() const { return 504; } /* = unique id SOAP_TYPE_tt__AnalyticsEngineControl */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tt__AnalyticsEngineControl(): EngineToken(NULL), EngineConfigToken(NULL), InputToken(NULL), ReceiverToken(NULL), Multicast(NULL), Subscription(NULL), __any(NULL) { tt__AnalyticsEngineControl::soap_default(NULL); }
	virtual ~tt__AnalyticsEngineControl() { }
};
#endif

#ifndef SOAP_TYPE_xmime5__base64Binary
#define SOAP_TYPE_xmime5__base64Binary (510)
/* Primitive xmime5:base64Binary schema type: */
class SOAP_CMAC xmime5__base64Binary
{
public:
	xsd__base64Binary __item;
	char *contentType;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 510; } /* = unique id SOAP_TYPE_xmime5__base64Binary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmime5__base64Binary(): contentType(NULL), soap(NULL) { xmime5__base64Binary::soap_default(NULL); }
	virtual ~xmime5__base64Binary() { }
};
#endif

#ifndef SOAP_TYPE_xmime5__hexBinary
#define SOAP_TYPE_xmime5__hexBinary (511)
/* Primitive xmime5:hexBinary schema type: */
class SOAP_CMAC xmime5__hexBinary
{
public:
	xsd__hexBinary __item;
	char *contentType;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 511; } /* = unique id SOAP_TYPE_xmime5__hexBinary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xmime5__hexBinary(): contentType(NULL), soap(NULL) { xmime5__hexBinary::soap_default(NULL); }
	virtual ~xmime5__hexBinary() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
#define SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (517)
/* wsnt:SubscribeCreationFailedFaultType */
class SOAP_CMAC wsnt__SubscribeCreationFailedFaultType : public wsbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 517; } /* = unique id SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__SubscribeCreationFailedFaultType() { wsnt__SubscribeCreationFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__SubscribeCreationFailedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__InvalidFilterFaultType
#define SOAP_TYPE_wsnt__InvalidFilterFaultType (518)
/* wsnt:InvalidFilterFaultType */
class SOAP_CMAC wsnt__InvalidFilterFaultType : public wsbf__BaseFaultType
{
public:
	int __sizeUnknownFilter;	/* sequence of elements <UnknownFilter> */
	char **UnknownFilter;	/* required element of type xsd:QName */
public:
	virtual int soap_type() const { return 518; } /* = unique id SOAP_TYPE_wsnt__InvalidFilterFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__InvalidFilterFaultType(): UnknownFilter(NULL) { wsnt__InvalidFilterFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidFilterFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (519)
/* wsnt:TopicExpressionDialectUnknownFaultType */
class SOAP_CMAC wsnt__TopicExpressionDialectUnknownFaultType : public wsbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 519; } /* = unique id SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__TopicExpressionDialectUnknownFaultType() { wsnt__TopicExpressionDialectUnknownFaultType::soap_default(NULL); }
	virtual ~wsnt__TopicExpressionDialectUnknownFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (520)
/* wsnt:InvalidTopicExpressionFaultType */
class SOAP_CMAC wsnt__InvalidTopicExpressionFaultType : public wsbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 520; } /* = unique id SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__InvalidTopicExpressionFaultType() { wsnt__InvalidTopicExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidTopicExpressionFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__TopicNotSupportedFaultType
#define SOAP_TYPE_wsnt__TopicNotSupportedFaultType (521)
/* wsnt:TopicNotSupportedFaultType */
class SOAP_CMAC wsnt__TopicNotSupportedFaultType : public wsbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 521; } /* = unique id SOAP_TYPE_wsnt__TopicNotSupportedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__TopicNotSupportedFaultType() { wsnt__TopicNotSupportedFaultType::soap_default(NULL); }
	virtual ~wsnt__TopicNotSupportedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (522)
/* wsnt:MultipleTopicsSpecifiedFaultType */
class SOAP_CMAC wsnt__MultipleTopicsSpecifiedFaultType : public wsbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 522; } /* = unique id SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__MultipleTopicsSpecifiedFaultType() { wsnt__MultipleTopicsSpecifiedFaultType::soap_default(NULL); }
	virtual ~wsnt__MultipleTopicsSpecifiedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (523)
/* wsnt:InvalidProducerPropertiesExpressionFaultType */
class SOAP_CMAC wsnt__InvalidProducerPropertiesExpressionFaultType : public wsbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 523; } /* = unique id SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__InvalidProducerPropertiesExpressionFaultType() { wsnt__InvalidProducerPropertiesExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidProducerPropertiesExpressionFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (524)
/* wsnt:InvalidMessageContentExpressionFaultType */
class SOAP_CMAC wsnt__InvalidMessageContentExpressionFaultType : public wsbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 524; } /* = unique id SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__InvalidMessageContentExpressionFaultType() { wsnt__InvalidMessageContentExpressionFaultType::soap_default(NULL); }
	virtual ~wsnt__InvalidMessageContentExpressionFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (525)
/* wsnt:UnrecognizedPolicyRequestFaultType */
class SOAP_CMAC wsnt__UnrecognizedPolicyRequestFaultType : public wsbf__BaseFaultType
{
public:
	int __sizeUnrecognizedPolicy;	/* sequence of elements <UnrecognizedPolicy> */
	char **UnrecognizedPolicy;	/* optional element of type xsd:QName */
public:
	virtual int soap_type() const { return 525; } /* = unique id SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__UnrecognizedPolicyRequestFaultType(): UnrecognizedPolicy(NULL) { wsnt__UnrecognizedPolicyRequestFaultType::soap_default(NULL); }
	virtual ~wsnt__UnrecognizedPolicyRequestFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (526)
/* wsnt:UnsupportedPolicyRequestFaultType */
class SOAP_CMAC wsnt__UnsupportedPolicyRequestFaultType : public wsbf__BaseFaultType
{
public:
	int __sizeUnsupportedPolicy;	/* sequence of elements <UnsupportedPolicy> */
	char **UnsupportedPolicy;	/* optional element of type xsd:QName */
public:
	virtual int soap_type() const { return 526; } /* = unique id SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__UnsupportedPolicyRequestFaultType(): UnsupportedPolicy(NULL) { wsnt__UnsupportedPolicyRequestFaultType::soap_default(NULL); }
	virtual ~wsnt__UnsupportedPolicyRequestFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (527)
/* wsnt:NotifyMessageNotSupportedFaultType */
class SOAP_CMAC wsnt__NotifyMessageNotSupportedFaultType : public wsbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 527; } /* = unique id SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__NotifyMessageNotSupportedFaultType() { wsnt__NotifyMessageNotSupportedFaultType::soap_default(NULL); }
	virtual ~wsnt__NotifyMessageNotSupportedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (528)
/* wsnt:UnacceptableInitialTerminationTimeFaultType */
class SOAP_CMAC wsnt__UnacceptableInitialTerminationTimeFaultType : public wsbf__BaseFaultType
{
public:
	time_t MinimumTime;	/* required element of type xsd:dateTime */
	time_t *MaximumTime;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 528; } /* = unique id SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__UnacceptableInitialTerminationTimeFaultType(): MaximumTime(NULL) { wsnt__UnacceptableInitialTerminationTimeFaultType::soap_default(NULL); }
	virtual ~wsnt__UnacceptableInitialTerminationTimeFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (529)
/* wsnt:NoCurrentMessageOnTopicFaultType */
class SOAP_CMAC wsnt__NoCurrentMessageOnTopicFaultType : public wsbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 529; } /* = unique id SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__NoCurrentMessageOnTopicFaultType() { wsnt__NoCurrentMessageOnTopicFaultType::soap_default(NULL); }
	virtual ~wsnt__NoCurrentMessageOnTopicFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
#define SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (530)
/* wsnt:UnableToGetMessagesFaultType */
class SOAP_CMAC wsnt__UnableToGetMessagesFaultType : public wsbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 530; } /* = unique id SOAP_TYPE_wsnt__UnableToGetMessagesFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__UnableToGetMessagesFaultType() { wsnt__UnableToGetMessagesFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToGetMessagesFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (531)
/* wsnt:UnableToDestroyPullPointFaultType */
class SOAP_CMAC wsnt__UnableToDestroyPullPointFaultType : public wsbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 531; } /* = unique id SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__UnableToDestroyPullPointFaultType() { wsnt__UnableToDestroyPullPointFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToDestroyPullPointFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
#define SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (532)
/* wsnt:UnableToCreatePullPointFaultType */
class SOAP_CMAC wsnt__UnableToCreatePullPointFaultType : public wsbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 532; } /* = unique id SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__UnableToCreatePullPointFaultType() { wsnt__UnableToCreatePullPointFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToCreatePullPointFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (533)
/* wsnt:UnacceptableTerminationTimeFaultType */
class SOAP_CMAC wsnt__UnacceptableTerminationTimeFaultType : public wsbf__BaseFaultType
{
public:
	time_t MinimumTime;	/* required element of type xsd:dateTime */
	time_t *MaximumTime;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 533; } /* = unique id SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__UnacceptableTerminationTimeFaultType(): MaximumTime(NULL) { wsnt__UnacceptableTerminationTimeFaultType::soap_default(NULL); }
	virtual ~wsnt__UnacceptableTerminationTimeFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (534)
/* wsnt:UnableToDestroySubscriptionFaultType */
class SOAP_CMAC wsnt__UnableToDestroySubscriptionFaultType : public wsbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 534; } /* = unique id SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__UnableToDestroySubscriptionFaultType() { wsnt__UnableToDestroySubscriptionFaultType::soap_default(NULL); }
	virtual ~wsnt__UnableToDestroySubscriptionFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__PauseFailedFaultType
#define SOAP_TYPE_wsnt__PauseFailedFaultType (535)
/* wsnt:PauseFailedFaultType */
class SOAP_CMAC wsnt__PauseFailedFaultType : public wsbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 535; } /* = unique id SOAP_TYPE_wsnt__PauseFailedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__PauseFailedFaultType() { wsnt__PauseFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__PauseFailedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsnt__ResumeFailedFaultType
#define SOAP_TYPE_wsnt__ResumeFailedFaultType (536)
/* wsnt:ResumeFailedFaultType */
class SOAP_CMAC wsnt__ResumeFailedFaultType : public wsbf__BaseFaultType
{
public:
	virtual int soap_type() const { return 536; } /* = unique id SOAP_TYPE_wsnt__ResumeFailedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsnt__ResumeFailedFaultType() { wsnt__ResumeFailedFaultType::soap_default(NULL); }
	virtual ~wsnt__ResumeFailedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (563)
/* Primitive wsa5:RelatesToType schema type: */
class SOAP_CMAC wsa5__RelatesToType
{
public:
	char *__item;
	char *RelationshipType;	/* optional attribute */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 563; } /* = unique id SOAP_TYPE_wsa5__RelatesToType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsa5__RelatesToType(): __item(NULL), RelationshipType(NULL), soap(NULL) { wsa5__RelatesToType::soap_default(NULL); }
	virtual ~wsa5__RelatesToType() { }
};
#endif

#ifndef SOAP_TYPE_wsa5__AttributedURIType
#define SOAP_TYPE_wsa5__AttributedURIType (564)
/* Primitive wsa5:AttributedURIType schema type: */
class SOAP_CMAC wsa5__AttributedURIType
{
public:
	char *__item;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 564; } /* = unique id SOAP_TYPE_wsa5__AttributedURIType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsa5__AttributedURIType(): __item(NULL), soap(NULL) { wsa5__AttributedURIType::soap_default(NULL); }
	virtual ~wsa5__AttributedURIType() { }
};
#endif

#ifndef SOAP_TYPE_wsa5__AttributedUnsignedLongType
#define SOAP_TYPE_wsa5__AttributedUnsignedLongType (565)
/* Primitive wsa5:AttributedUnsignedLongType schema type: */
class SOAP_CMAC wsa5__AttributedUnsignedLongType
{
public:
	ULONG64 __item;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 565; } /* = unique id SOAP_TYPE_wsa5__AttributedUnsignedLongType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsa5__AttributedUnsignedLongType(): soap(NULL) { wsa5__AttributedUnsignedLongType::soap_default(NULL); }
	virtual ~wsa5__AttributedUnsignedLongType() { }
};
#endif

#ifndef SOAP_TYPE_wsa5__AttributedQNameType
#define SOAP_TYPE_wsa5__AttributedQNameType (566)
/* Primitive wsa5:AttributedQNameType schema type: */
class SOAP_CMAC wsa5__AttributedQNameType
{
public:
	char *__item;
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 566; } /* = unique id SOAP_TYPE_wsa5__AttributedQNameType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsa5__AttributedQNameType(): __item(NULL), soap(NULL) { wsa5__AttributedQNameType::soap_default(NULL); }
	virtual ~wsa5__AttributedQNameType() { }
};
#endif

#ifndef SOAP_TYPE__wstop__TopicNamespaceType_Topic
#define SOAP_TYPE__wstop__TopicNamespaceType_Topic (1150)
/* wstop:TopicNamespaceType-Topic */
class SOAP_CMAC _wstop__TopicNamespaceType_Topic
{
public:
	wstop__QueryExpressionType *MessagePattern;	/* optional element of type wstop:QueryExpressionType */
	int __sizeTopic;	/* sequence of elements <Topic> */
	class wstop__TopicType **Topic;	/* optional element of type wstop:TopicType */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	char *name;	/* required attribute */
	char **messageTypes;	/* optional attribute */
	bool final;	/* optional attribute */
	wstop__Documentation *documentation;	/* optional element of type wstop:Documentation */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	char **parent;	/* optional attribute */
public:
	virtual int soap_type() const { return 1150; } /* = unique id SOAP_TYPE__wstop__TopicNamespaceType_Topic */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _wstop__TopicNamespaceType_Topic(): MessagePattern(NULL), Topic(NULL), __any(NULL), name(NULL), messageTypes(NULL), documentation(NULL), parent(NULL) { _wstop__TopicNamespaceType_Topic::soap_default(NULL); }
	virtual ~_wstop__TopicNamespaceType_Topic() { }
};
#endif

#ifndef SOAP_TYPE_wstop__TopicNamespaceType
#define SOAP_TYPE_wstop__TopicNamespaceType (573)
/* wstop:TopicNamespaceType */
class SOAP_CMAC wstop__TopicNamespaceType : public wstop__ExtensibleDocumented
{
public:
	int __sizeTopic;	/* sequence of elements <Topic> */
	_wstop__TopicNamespaceType_Topic *Topic;	/* optional element of type wstop:TopicNamespaceType-Topic */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	char *name;	/* optional attribute */
	char *targetNamespace;	/* required attribute */
	bool final;	/* optional attribute */
public:
	virtual int soap_type() const { return 573; } /* = unique id SOAP_TYPE_wstop__TopicNamespaceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wstop__TopicNamespaceType(): Topic(NULL), __any(NULL), name(NULL), targetNamespace(NULL) { wstop__TopicNamespaceType::soap_default(NULL); }
	virtual ~wstop__TopicNamespaceType() { }
};
#endif

#ifndef SOAP_TYPE_wstop__TopicType
#define SOAP_TYPE_wstop__TopicType (574)
/* wstop:TopicType */
class SOAP_CMAC wstop__TopicType : public wstop__ExtensibleDocumented
{
public:
	wstop__QueryExpressionType *MessagePattern;	/* optional element of type wstop:QueryExpressionType */
	int __sizeTopic;	/* sequence of elements <Topic> */
	wstop__TopicType **Topic;	/* optional element of type wstop:TopicType */
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
	char *name;	/* required attribute */
	char **messageTypes;	/* optional attribute */
	bool final;	/* optional attribute */
public:
	virtual int soap_type() const { return 574; } /* = unique id SOAP_TYPE_wstop__TopicType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wstop__TopicType(): MessagePattern(NULL), Topic(NULL), __any(NULL), name(NULL), messageTypes(NULL) { wstop__TopicType::soap_default(NULL); }
	virtual ~wstop__TopicType() { }
};
#endif

#ifndef SOAP_TYPE_wstop__TopicSetType
#define SOAP_TYPE_wstop__TopicSetType (575)
/* wstop:TopicSetType */
class SOAP_CMAC wstop__TopicSetType : public wstop__ExtensibleDocumented
{
public:
	int __size;	/* sequence of elements <-any> */
	struct soap_dom_element *__any;
public:
	virtual int soap_type() const { return 575; } /* = unique id SOAP_TYPE_wstop__TopicSetType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wstop__TopicSetType(): __any(NULL) { wstop__TopicSetType::soap_default(NULL); }
	virtual ~wstop__TopicSetType() { }
};
#endif

#ifndef SOAP_TYPE___tptz__GetServiceCapabilities
#define SOAP_TYPE___tptz__GetServiceCapabilities (1160)
/* Operation wrapper: */
struct __tptz__GetServiceCapabilities
{
public:
	_tptz__GetServiceCapabilities *tptz__GetServiceCapabilities;	/* optional element of type tptz:GetServiceCapabilities */
};
#endif

#ifndef SOAP_TYPE___tptz__GetConfigurations
#define SOAP_TYPE___tptz__GetConfigurations (1164)
/* Operation wrapper: */
struct __tptz__GetConfigurations
{
public:
	_tptz__GetConfigurations *tptz__GetConfigurations;	/* optional element of type tptz:GetConfigurations */
};
#endif

#ifndef SOAP_TYPE___tptz__GetPresets
#define SOAP_TYPE___tptz__GetPresets (1168)
/* Operation wrapper: */
struct __tptz__GetPresets
{
public:
	_tptz__GetPresets *tptz__GetPresets;	/* optional element of type tptz:GetPresets */
};
#endif

#ifndef SOAP_TYPE___tptz__SetPreset
#define SOAP_TYPE___tptz__SetPreset (1172)
/* Operation wrapper: */
struct __tptz__SetPreset
{
public:
	_tptz__SetPreset *tptz__SetPreset;	/* optional element of type tptz:SetPreset */
};
#endif

#ifndef SOAP_TYPE___tptz__RemovePreset
#define SOAP_TYPE___tptz__RemovePreset (1176)
/* Operation wrapper: */
struct __tptz__RemovePreset
{
public:
	_tptz__RemovePreset *tptz__RemovePreset;	/* optional element of type tptz:RemovePreset */
};
#endif

#ifndef SOAP_TYPE___tptz__GotoPreset
#define SOAP_TYPE___tptz__GotoPreset (1180)
/* Operation wrapper: */
struct __tptz__GotoPreset
{
public:
	_tptz__GotoPreset *tptz__GotoPreset;	/* optional element of type tptz:GotoPreset */
};
#endif

#ifndef SOAP_TYPE___tptz__GetStatus
#define SOAP_TYPE___tptz__GetStatus (1184)
/* Operation wrapper: */
struct __tptz__GetStatus
{
public:
	_tptz__GetStatus *tptz__GetStatus;	/* optional element of type tptz:GetStatus */
};
#endif

#ifndef SOAP_TYPE___tptz__GetConfiguration
#define SOAP_TYPE___tptz__GetConfiguration (1188)
/* Operation wrapper: */
struct __tptz__GetConfiguration
{
public:
	_tptz__GetConfiguration *tptz__GetConfiguration;	/* optional element of type tptz:GetConfiguration */
};
#endif

#ifndef SOAP_TYPE___tptz__GetNodes
#define SOAP_TYPE___tptz__GetNodes (1192)
/* Operation wrapper: */
struct __tptz__GetNodes
{
public:
	_tptz__GetNodes *tptz__GetNodes;	/* optional element of type tptz:GetNodes */
};
#endif

#ifndef SOAP_TYPE___tptz__GetNode
#define SOAP_TYPE___tptz__GetNode (1196)
/* Operation wrapper: */
struct __tptz__GetNode
{
public:
	_tptz__GetNode *tptz__GetNode;	/* optional element of type tptz:GetNode */
};
#endif

#ifndef SOAP_TYPE___tptz__SetConfiguration
#define SOAP_TYPE___tptz__SetConfiguration (1200)
/* Operation wrapper: */
struct __tptz__SetConfiguration
{
public:
	_tptz__SetConfiguration *tptz__SetConfiguration;	/* optional element of type tptz:SetConfiguration */
};
#endif

#ifndef SOAP_TYPE___tptz__GetConfigurationOptions
#define SOAP_TYPE___tptz__GetConfigurationOptions (1204)
/* Operation wrapper: */
struct __tptz__GetConfigurationOptions
{
public:
	_tptz__GetConfigurationOptions *tptz__GetConfigurationOptions;	/* optional element of type tptz:GetConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___tptz__GotoHomePosition
#define SOAP_TYPE___tptz__GotoHomePosition (1208)
/* Operation wrapper: */
struct __tptz__GotoHomePosition
{
public:
	_tptz__GotoHomePosition *tptz__GotoHomePosition;	/* optional element of type tptz:GotoHomePosition */
};
#endif

#ifndef SOAP_TYPE___tptz__SetHomePosition
#define SOAP_TYPE___tptz__SetHomePosition (1212)
/* Operation wrapper: */
struct __tptz__SetHomePosition
{
public:
	_tptz__SetHomePosition *tptz__SetHomePosition;	/* optional element of type tptz:SetHomePosition */
};
#endif

#ifndef SOAP_TYPE___tptz__ContinuousMove
#define SOAP_TYPE___tptz__ContinuousMove (1216)
/* Operation wrapper: */
struct __tptz__ContinuousMove
{
public:
	_tptz__ContinuousMove *tptz__ContinuousMove;	/* optional element of type tptz:ContinuousMove */
};
#endif

#ifndef SOAP_TYPE___tptz__RelativeMove
#define SOAP_TYPE___tptz__RelativeMove (1220)
/* Operation wrapper: */
struct __tptz__RelativeMove
{
public:
	_tptz__RelativeMove *tptz__RelativeMove;	/* optional element of type tptz:RelativeMove */
};
#endif

#ifndef SOAP_TYPE___tptz__SendAuxiliaryCommand
#define SOAP_TYPE___tptz__SendAuxiliaryCommand (1224)
/* Operation wrapper: */
struct __tptz__SendAuxiliaryCommand
{
public:
	_tptz__SendAuxiliaryCommand *tptz__SendAuxiliaryCommand;	/* optional element of type tptz:SendAuxiliaryCommand */
};
#endif

#ifndef SOAP_TYPE___tptz__AbsoluteMove
#define SOAP_TYPE___tptz__AbsoluteMove (1228)
/* Operation wrapper: */
struct __tptz__AbsoluteMove
{
public:
	_tptz__AbsoluteMove *tptz__AbsoluteMove;	/* optional element of type tptz:AbsoluteMove */
};
#endif

#ifndef SOAP_TYPE___tptz__Stop
#define SOAP_TYPE___tptz__Stop (1232)
/* Operation wrapper: */
struct __tptz__Stop
{
public:
	_tptz__Stop *tptz__Stop;	/* optional element of type tptz:Stop */
};
#endif

#ifndef SOAP_TYPE___tptz__GetPresetTours
#define SOAP_TYPE___tptz__GetPresetTours (1236)
/* Operation wrapper: */
struct __tptz__GetPresetTours
{
public:
	_tptz__GetPresetTours *tptz__GetPresetTours;	/* optional element of type tptz:GetPresetTours */
};
#endif

#ifndef SOAP_TYPE___tptz__GetPresetTour
#define SOAP_TYPE___tptz__GetPresetTour (1240)
/* Operation wrapper: */
struct __tptz__GetPresetTour
{
public:
	_tptz__GetPresetTour *tptz__GetPresetTour;	/* optional element of type tptz:GetPresetTour */
};
#endif

#ifndef SOAP_TYPE___tptz__GetPresetTourOptions
#define SOAP_TYPE___tptz__GetPresetTourOptions (1244)
/* Operation wrapper: */
struct __tptz__GetPresetTourOptions
{
public:
	_tptz__GetPresetTourOptions *tptz__GetPresetTourOptions;	/* optional element of type tptz:GetPresetTourOptions */
};
#endif

#ifndef SOAP_TYPE___tptz__CreatePresetTour
#define SOAP_TYPE___tptz__CreatePresetTour (1248)
/* Operation wrapper: */
struct __tptz__CreatePresetTour
{
public:
	_tptz__CreatePresetTour *tptz__CreatePresetTour;	/* optional element of type tptz:CreatePresetTour */
};
#endif

#ifndef SOAP_TYPE___tptz__ModifyPresetTour
#define SOAP_TYPE___tptz__ModifyPresetTour (1252)
/* Operation wrapper: */
struct __tptz__ModifyPresetTour
{
public:
	_tptz__ModifyPresetTour *tptz__ModifyPresetTour;	/* optional element of type tptz:ModifyPresetTour */
};
#endif

#ifndef SOAP_TYPE___tptz__OperatePresetTour
#define SOAP_TYPE___tptz__OperatePresetTour (1256)
/* Operation wrapper: */
struct __tptz__OperatePresetTour
{
public:
	_tptz__OperatePresetTour *tptz__OperatePresetTour;	/* optional element of type tptz:OperatePresetTour */
};
#endif

#ifndef SOAP_TYPE___tptz__RemovePresetTour
#define SOAP_TYPE___tptz__RemovePresetTour (1260)
/* Operation wrapper: */
struct __tptz__RemovePresetTour
{
public:
	_tptz__RemovePresetTour *tptz__RemovePresetTour;	/* optional element of type tptz:RemovePresetTour */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (1261)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (1262)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (1264)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (1267)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Envelope
#define SOAP_TYPE_SOAP_ENV__Envelope (12)
typedef char *SOAP_ENV__Envelope;
#endif

#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (13)
typedef char *xsd__NCName;
#endif

#ifndef SOAP_TYPE_xsd__anySimpleType
#define SOAP_TYPE_xsd__anySimpleType (14)
typedef char *xsd__anySimpleType;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (15)
typedef char *xsd__anyURI;
#endif

#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (21)
typedef char *xsd__duration;
#endif

#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (23)
typedef char *xsd__integer;
#endif

#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (24)
typedef char *xsd__nonNegativeInteger;
#endif

#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (25)
typedef char *xsd__token;
#endif

#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (26)
typedef char *_xml__lang;
#endif

#ifndef SOAP_TYPE_tt__IntAttrList
#define SOAP_TYPE_tt__IntAttrList (576)
typedef char *tt__IntAttrList;
#endif

#ifndef SOAP_TYPE_tt__FloatAttrList
#define SOAP_TYPE_tt__FloatAttrList (577)
typedef char *tt__FloatAttrList;
#endif

#ifndef SOAP_TYPE_tt__StringAttrList
#define SOAP_TYPE_tt__StringAttrList (578)
typedef char *tt__StringAttrList;
#endif

#ifndef SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType (579)
typedef char *wsnt__AbsoluteOrRelativeTimeType;
#endif

#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (580)
typedef char *wsa5__RelationshipTypeOpenEnum;
#endif

#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (581)
typedef char *wsa5__FaultCodesOpenEnumType;
#endif

#ifndef SOAP_TYPE_tt__ReferenceToken
#define SOAP_TYPE_tt__ReferenceToken (582)
typedef char *tt__ReferenceToken;
#endif

#ifndef SOAP_TYPE_tt__Name
#define SOAP_TYPE_tt__Name (583)
typedef char *tt__Name;
#endif

#ifndef SOAP_TYPE_tt__NetworkInterfaceConfigPriority
#define SOAP_TYPE_tt__NetworkInterfaceConfigPriority (593)
typedef char *tt__NetworkInterfaceConfigPriority;
#endif

#ifndef SOAP_TYPE_tt__IANA_IfTypes
#define SOAP_TYPE_tt__IANA_IfTypes (595)
typedef int tt__IANA_IfTypes;
#endif

#ifndef SOAP_TYPE_tt__IPv4Address
#define SOAP_TYPE_tt__IPv4Address (599)
typedef char *tt__IPv4Address;
#endif

#ifndef SOAP_TYPE_tt__IPv6Address
#define SOAP_TYPE_tt__IPv6Address (600)
typedef char *tt__IPv6Address;
#endif

#ifndef SOAP_TYPE_tt__HwAddress
#define SOAP_TYPE_tt__HwAddress (601)
typedef char *tt__HwAddress;
#endif

#ifndef SOAP_TYPE_tt__DNSName
#define SOAP_TYPE_tt__DNSName (603)
typedef char *tt__DNSName;
#endif

#ifndef SOAP_TYPE_tt__Domain
#define SOAP_TYPE_tt__Domain (604)
typedef char *tt__Domain;
#endif

#ifndef SOAP_TYPE_tt__Dot11SSIDType
#define SOAP_TYPE_tt__Dot11SSIDType (607)
typedef xsd__hexBinary tt__Dot11SSIDType;
#endif

#ifndef SOAP_TYPE_tt__Dot11PSK
#define SOAP_TYPE_tt__Dot11PSK (611)
typedef xsd__hexBinary tt__Dot11PSK;
#endif

#ifndef SOAP_TYPE_tt__Dot11PSKPassphrase
#define SOAP_TYPE_tt__Dot11PSKPassphrase (612)
typedef char *tt__Dot11PSKPassphrase;
#endif

#ifndef SOAP_TYPE_tt__AuxiliaryData
#define SOAP_TYPE_tt__AuxiliaryData (625)
typedef char *tt__AuxiliaryData;
#endif

#ifndef SOAP_TYPE_tt__TopicNamespaceLocation
#define SOAP_TYPE_tt__TopicNamespaceLocation (639)
typedef char *tt__TopicNamespaceLocation;
#endif

#ifndef SOAP_TYPE_tt__Description
#define SOAP_TYPE_tt__Description (645)
typedef char *tt__Description;
#endif

#ifndef SOAP_TYPE_tt__XPathExpression
#define SOAP_TYPE_tt__XPathExpression (646)
typedef char *tt__XPathExpression;
#endif

#ifndef SOAP_TYPE_tt__RecordingJobMode
#define SOAP_TYPE_tt__RecordingJobMode (650)
typedef char *tt__RecordingJobMode;
#endif

#ifndef SOAP_TYPE_tt__RecordingJobState
#define SOAP_TYPE_tt__RecordingJobState (651)
typedef char *tt__RecordingJobState;
#endif

#ifndef SOAP_TYPE_wstop__FullTopicExpression
#define SOAP_TYPE_wstop__FullTopicExpression (655)
typedef char *wstop__FullTopicExpression;
#endif

#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression
#define SOAP_TYPE_wstop__ConcreteTopicExpression (656)
typedef char *wstop__ConcreteTopicExpression;
#endif

#ifndef SOAP_TYPE_wstop__SimpleTopicExpression
#define SOAP_TYPE_wstop__SimpleTopicExpression (657)
typedef char *wstop__SimpleTopicExpression;
#endif

#ifndef SOAP_TYPE_tt__ReceiverReference
#define SOAP_TYPE_tt__ReceiverReference (658)
typedef char *tt__ReceiverReference;
#endif

#ifndef SOAP_TYPE_tt__RecordingReference
#define SOAP_TYPE_tt__RecordingReference (659)
typedef char *tt__RecordingReference;
#endif

#ifndef SOAP_TYPE_tt__TrackReference
#define SOAP_TYPE_tt__TrackReference (660)
typedef char *tt__TrackReference;
#endif

#ifndef SOAP_TYPE_tt__JobToken
#define SOAP_TYPE_tt__JobToken (661)
typedef char *tt__JobToken;
#endif

#ifndef SOAP_TYPE_tt__RecordingJobReference
#define SOAP_TYPE_tt__RecordingJobReference (662)
typedef char *tt__RecordingJobReference;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of ptzStub.h */
