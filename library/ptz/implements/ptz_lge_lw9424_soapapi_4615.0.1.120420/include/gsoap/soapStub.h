/* soapStub.h
   Generated by gSOAP 2.7.16 from soap.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#define SOAP_NAMESPACE_OF_ns1	"http://tempuri.org/"
#ifndef WITH_NONAMESPACES
#define WITH_NONAMESPACES
#endif
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns1__PARITY_USCORET
#define SOAP_TYPE_ns1__PARITY_USCORET (74)
/* ns1:PARITY_T */
enum ns1__PARITY_USCORET {ns1__PARITY_USCORET__PARITY_USCORENONE = 0, ns1__PARITY_USCORET__PARITY_USCOREEVEN = 1, ns1__PARITY_USCORET__PARITY_USCOREODD = 2};
#endif

#ifndef SOAP_TYPE_ns1__OSD_USCOREMENU_USCORET
#define SOAP_TYPE_ns1__OSD_USCOREMENU_USCORET (75)
/* ns1:OSD_MENU_T */
enum ns1__OSD_USCOREMENU_USCORET {ns1__OSD_USCOREMENU_USCORET__OSD_USCOREMENU_USCOREOPEN = 0, ns1__OSD_USCOREMENU_USCORET__OSD_USCOREMENU_USCORECLOSE = 1, ns1__OSD_USCOREMENU_USCORET__OSD_USCOREMENU_USCOREUP = 2, ns1__OSD_USCOREMENU_USCORET__OSD_USCOREMENU_USCOREDOWN = 3, ns1__OSD_USCOREMENU_USCORET__OSD_USCOREMENU_USCORELEFT = 4, ns1__OSD_USCOREMENU_USCORET__OSD_USCOREMENU_USCORERIGHT = 5, ns1__OSD_USCOREMENU_USCORET__OSD_USCOREMENU_USCORESELECT = 6, ns1__OSD_USCOREMENU_USCORET__OSD_USCOREMENU_USCOREBACK = 7};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (9)
typedef struct soap_dom_element xsd__anyType;
#endif
#ifndef SOAP_TYPE_xsd__anyAttribute
#define SOAP_TYPE_xsd__anyAttribute (11)
typedef struct soap_dom_attribute xsd__anyAttribute;
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif





#ifndef SOAP_TYPE_ns1__ArrayOfString
#define SOAP_TYPE_ns1__ArrayOfString (12)
/* ns1:ArrayOfString */
class SOAP_CMAC ns1__ArrayOfString
{
public:
	int __sizestring;	/* sequence of elements <string> */
	char **string;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ns1__ArrayOfString */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfString(): string(NULL), soap(NULL) { ns1__ArrayOfString::soap_default(NULL); }
	virtual ~ns1__ArrayOfString() { }
};
#endif

#ifndef SOAP_TYPE_ns1__PTZProtocol_USCORET
#define SOAP_TYPE_ns1__PTZProtocol_USCORET (13)
/* ns1:PTZProtocol_T */
class SOAP_CMAC ns1__PTZProtocol_USCORET
{
public:
	char *name;	/* optional element of type xsd:string */
	class ns1__IntRange_USCORET *presetIDRange;	/* optional element of type ns1:IntRange_T */
	ns1__IntRange_USCORET *panSpeedRange;	/* optional element of type ns1:IntRange_T */
	ns1__IntRange_USCORET *tiltSpeedRange;	/* optional element of type ns1:IntRange_T */
	ns1__IntRange_USCORET *zoomSpeedRange;	/* optional element of type ns1:IntRange_T */
	ns1__IntRange_USCORET *focusSpeedRange;	/* optional element of type ns1:IntRange_T */
	ns1__IntRange_USCORET *cameraIDRange;	/* optional element of type ns1:IntRange_T */
	ns1__IntRange_USCORET *presetSpeedRange;	/* optional element of type ns1:IntRange_T */
	ns1__IntRange_USCORET *parkTimeRange;	/* optional element of type ns1:IntRange_T */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_ns1__PTZProtocol_USCORET */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__PTZProtocol_USCORET(): name(NULL), presetIDRange(NULL), panSpeedRange(NULL), tiltSpeedRange(NULL), zoomSpeedRange(NULL), focusSpeedRange(NULL), cameraIDRange(NULL), presetSpeedRange(NULL), parkTimeRange(NULL), soap(NULL) { ns1__PTZProtocol_USCORET::soap_default(NULL); }
	virtual ~ns1__PTZProtocol_USCORET() { }
};
#endif

#ifndef SOAP_TYPE_ns1__IntRange_USCORET
#define SOAP_TYPE_ns1__IntRange_USCORET (14)
/* ns1:IntRange_T */
class SOAP_CMAC ns1__IntRange_USCORET
{
public:
	int min_;	/* required element of type xsd:int */
	int max_;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ns1__IntRange_USCORET */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__IntRange_USCORET(): soap(NULL) { ns1__IntRange_USCORET::soap_default(NULL); }
	virtual ~ns1__IntRange_USCORET() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfParameter_USCORET
#define SOAP_TYPE_ns1__ArrayOfParameter_USCORET (15)
/* ns1:ArrayOfParameter_T */
class SOAP_CMAC ns1__ArrayOfParameter_USCORET
{
public:
	int __sizeParameter_USCORET;	/* sequence of elements <Parameter_T> */
	class ns1__Parameter_USCORET **Parameter_USCORET;	/* optional element of type ns1:Parameter_T */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_ns1__ArrayOfParameter_USCORET */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfParameter_USCORET(): Parameter_USCORET(NULL), soap(NULL) { ns1__ArrayOfParameter_USCORET::soap_default(NULL); }
	virtual ~ns1__ArrayOfParameter_USCORET() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Parameter_USCORET
#define SOAP_TYPE_ns1__Parameter_USCORET (16)
/* ns1:Parameter_T */
class SOAP_CMAC ns1__Parameter_USCORET
{
public:
	char *key;	/* optional element of type xsd:string */
	char *value;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns1__Parameter_USCORET */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Parameter_USCORET(): key(NULL), value(NULL), soap(NULL) { ns1__Parameter_USCORET::soap_default(NULL); }
	virtual ~ns1__Parameter_USCORET() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfPreset_USCORET
#define SOAP_TYPE_ns1__ArrayOfPreset_USCORET (17)
/* ns1:ArrayOfPreset_T */
class SOAP_CMAC ns1__ArrayOfPreset_USCORET
{
public:
	int __sizePreset_USCORET;	/* sequence of elements <Preset_T> */
	class ns1__Preset_USCORET **Preset_USCORET;	/* optional element of type ns1:Preset_T */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns1__ArrayOfPreset_USCORET */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfPreset_USCORET(): Preset_USCORET(NULL), soap(NULL) { ns1__ArrayOfPreset_USCORET::soap_default(NULL); }
	virtual ~ns1__ArrayOfPreset_USCORET() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Preset_USCORET
#define SOAP_TYPE_ns1__Preset_USCORET (18)
/* ns1:Preset_T */
class SOAP_CMAC ns1__Preset_USCORET
{
public:
	char *alias;	/* optional element of type xsd:string */
	int sequence;	/* required element of type xsd:int */
	int presetSpeed;	/* required element of type xsd:int */
	int parkTime;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns1__Preset_USCORET */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Preset_USCORET(): alias(NULL), soap(NULL) { ns1__Preset_USCORET::soap_default(NULL); }
	virtual ~ns1__Preset_USCORET() { }
};
#endif

#ifndef SOAP_TYPE_ns1__PortConfig_USCORET
#define SOAP_TYPE_ns1__PortConfig_USCORET (19)
/* ns1:PortConfig_T */
class SOAP_CMAC ns1__PortConfig_USCORET
{
public:
	int baudRate;	/* required element of type xsd:int */
	int dataBit;	/* required element of type xsd:int */
	enum ns1__PARITY_USCORET parity;	/* required element of type ns1:PARITY_T */
	int stopBit;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ns1__PortConfig_USCORET */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__PortConfig_USCORET(): soap(NULL) { ns1__PortConfig_USCORET::soap_default(NULL); }
	virtual ~ns1__PortConfig_USCORET() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetPTZProtocolList
#define SOAP_TYPE__ns1__GetPTZProtocolList (20)
/* ns1:GetPTZProtocolList */
class SOAP_CMAC _ns1__GetPTZProtocolList
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE__ns1__GetPTZProtocolList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetPTZProtocolList(): soap(NULL) { _ns1__GetPTZProtocolList::soap_default(NULL); }
	virtual ~_ns1__GetPTZProtocolList() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetPTZProtocolListResponse
#define SOAP_TYPE__ns1__GetPTZProtocolListResponse (21)
/* ns1:GetPTZProtocolListResponse */
class SOAP_CMAC _ns1__GetPTZProtocolListResponse
{
public:
	ns1__ArrayOfString *GetPTZProtocolListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ArrayOfString */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE__ns1__GetPTZProtocolListResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetPTZProtocolListResponse(): GetPTZProtocolListResult(NULL), soap(NULL) { _ns1__GetPTZProtocolListResponse::soap_default(NULL); }
	virtual ~_ns1__GetPTZProtocolListResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetPTZProtocol
#define SOAP_TYPE__ns1__GetPTZProtocol (22)
/* ns1:GetPTZProtocol */
class SOAP_CMAC _ns1__GetPTZProtocol
{
public:
	int channel;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE__ns1__GetPTZProtocol */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetPTZProtocol(): soap(NULL) { _ns1__GetPTZProtocol::soap_default(NULL); }
	virtual ~_ns1__GetPTZProtocol() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetPTZProtocolResponse
#define SOAP_TYPE__ns1__GetPTZProtocolResponse (23)
/* ns1:GetPTZProtocolResponse */
class SOAP_CMAC _ns1__GetPTZProtocolResponse
{
public:
	char *GetPTZProtocolResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE__ns1__GetPTZProtocolResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetPTZProtocolResponse(): GetPTZProtocolResult(NULL), soap(NULL) { _ns1__GetPTZProtocolResponse::soap_default(NULL); }
	virtual ~_ns1__GetPTZProtocolResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetPTZProtocol
#define SOAP_TYPE__ns1__SetPTZProtocol (24)
/* ns1:SetPTZProtocol */
class SOAP_CMAC _ns1__SetPTZProtocol
{
public:
	int channel;	/* required element of type xsd:int */
	char *protocolName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE__ns1__SetPTZProtocol */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetPTZProtocol(): protocolName(NULL), soap(NULL) { _ns1__SetPTZProtocol::soap_default(NULL); }
	virtual ~_ns1__SetPTZProtocol() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetPTZProtocolResponse
#define SOAP_TYPE__ns1__SetPTZProtocolResponse (25)
/* ns1:SetPTZProtocolResponse */
class SOAP_CMAC _ns1__SetPTZProtocolResponse
{
public:
	bool SetPTZProtocolResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE__ns1__SetPTZProtocolResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetPTZProtocolResponse(): soap(NULL) { _ns1__SetPTZProtocolResponse::soap_default(NULL); }
	virtual ~_ns1__SetPTZProtocolResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddPTZProtocol
#define SOAP_TYPE__ns1__AddPTZProtocol (26)
/* ns1:AddPTZProtocol */
class SOAP_CMAC _ns1__AddPTZProtocol
{
public:
	char *filename;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE__ns1__AddPTZProtocol */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddPTZProtocol(): filename(NULL), soap(NULL) { _ns1__AddPTZProtocol::soap_default(NULL); }
	virtual ~_ns1__AddPTZProtocol() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddPTZProtocolResponse
#define SOAP_TYPE__ns1__AddPTZProtocolResponse (27)
/* ns1:AddPTZProtocolResponse */
class SOAP_CMAC _ns1__AddPTZProtocolResponse
{
public:
	bool AddPTZProtocolResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE__ns1__AddPTZProtocolResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddPTZProtocolResponse(): soap(NULL) { _ns1__AddPTZProtocolResponse::soap_default(NULL); }
	virtual ~_ns1__AddPTZProtocolResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemovePTZProtocol
#define SOAP_TYPE__ns1__RemovePTZProtocol (28)
/* ns1:RemovePTZProtocol */
class SOAP_CMAC _ns1__RemovePTZProtocol
{
public:
	char *protocolName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE__ns1__RemovePTZProtocol */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemovePTZProtocol(): protocolName(NULL), soap(NULL) { _ns1__RemovePTZProtocol::soap_default(NULL); }
	virtual ~_ns1__RemovePTZProtocol() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemovePTZProtocolResponse
#define SOAP_TYPE__ns1__RemovePTZProtocolResponse (29)
/* ns1:RemovePTZProtocolResponse */
class SOAP_CMAC _ns1__RemovePTZProtocolResponse
{
public:
	bool RemovePTZProtocolResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE__ns1__RemovePTZProtocolResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemovePTZProtocolResponse(): soap(NULL) { _ns1__RemovePTZProtocolResponse::soap_default(NULL); }
	virtual ~_ns1__RemovePTZProtocolResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetPTZProtocolInfo
#define SOAP_TYPE__ns1__GetPTZProtocolInfo (30)
/* ns1:GetPTZProtocolInfo */
class SOAP_CMAC _ns1__GetPTZProtocolInfo
{
public:
	char *protocolName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE__ns1__GetPTZProtocolInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetPTZProtocolInfo(): protocolName(NULL), soap(NULL) { _ns1__GetPTZProtocolInfo::soap_default(NULL); }
	virtual ~_ns1__GetPTZProtocolInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetPTZProtocolInfoResponse
#define SOAP_TYPE__ns1__GetPTZProtocolInfoResponse (31)
/* ns1:GetPTZProtocolInfoResponse */
class SOAP_CMAC _ns1__GetPTZProtocolInfoResponse
{
public:
	ns1__PTZProtocol_USCORET *GetPTZProtocolInfoResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:PTZProtocol_T */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE__ns1__GetPTZProtocolInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetPTZProtocolInfoResponse(): GetPTZProtocolInfoResult(NULL), soap(NULL) { _ns1__GetPTZProtocolInfoResponse::soap_default(NULL); }
	virtual ~_ns1__GetPTZProtocolInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetPTZCommandList
#define SOAP_TYPE__ns1__GetPTZCommandList (32)
/* ns1:GetPTZCommandList */
class SOAP_CMAC _ns1__GetPTZCommandList
{
public:
	char *protocolName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE__ns1__GetPTZCommandList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetPTZCommandList(): protocolName(NULL), soap(NULL) { _ns1__GetPTZCommandList::soap_default(NULL); }
	virtual ~_ns1__GetPTZCommandList() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetPTZCommandListResponse
#define SOAP_TYPE__ns1__GetPTZCommandListResponse (33)
/* ns1:GetPTZCommandListResponse */
class SOAP_CMAC _ns1__GetPTZCommandListResponse
{
public:
	ns1__ArrayOfParameter_USCORET *GetPTZCommandListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ArrayOfParameter_T */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE__ns1__GetPTZCommandListResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetPTZCommandListResponse(): GetPTZCommandListResult(NULL), soap(NULL) { _ns1__GetPTZCommandListResponse::soap_default(NULL); }
	virtual ~_ns1__GetPTZCommandListResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__ControlPTZ
#define SOAP_TYPE__ns1__ControlPTZ (34)
/* ns1:ControlPTZ */
class SOAP_CMAC _ns1__ControlPTZ
{
public:
	int channel;	/* required element of type xsd:int */
	ns1__ArrayOfParameter_USCORET *param;	/* optional element of type ns1:ArrayOfParameter_T */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE__ns1__ControlPTZ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__ControlPTZ(): param(NULL), soap(NULL) { _ns1__ControlPTZ::soap_default(NULL); }
	virtual ~_ns1__ControlPTZ() { }
};
#endif

#ifndef SOAP_TYPE__ns1__ControlPTZResponse
#define SOAP_TYPE__ns1__ControlPTZResponse (35)
/* ns1:ControlPTZResponse */
class SOAP_CMAC _ns1__ControlPTZResponse
{
public:
	int resultCode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE__ns1__ControlPTZResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__ControlPTZResponse(): soap(NULL) { _ns1__ControlPTZResponse::soap_default(NULL); }
	virtual ~_ns1__ControlPTZResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__Stop
#define SOAP_TYPE__ns1__Stop (36)
/* ns1:Stop */
class SOAP_CMAC _ns1__Stop
{
public:
	int channel;	/* required element of type xsd:int */
	ns1__ArrayOfParameter_USCORET *param;	/* optional element of type ns1:ArrayOfParameter_T */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE__ns1__Stop */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__Stop(): param(NULL), soap(NULL) { _ns1__Stop::soap_default(NULL); }
	virtual ~_ns1__Stop() { }
};
#endif

#ifndef SOAP_TYPE__ns1__StopResponse
#define SOAP_TYPE__ns1__StopResponse (37)
/* ns1:StopResponse */
class SOAP_CMAC _ns1__StopResponse
{
public:
	int resultCode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE__ns1__StopResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__StopResponse(): soap(NULL) { _ns1__StopResponse::soap_default(NULL); }
	virtual ~_ns1__StopResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetPresetList
#define SOAP_TYPE__ns1__GetPresetList (38)
/* ns1:GetPresetList */
class SOAP_CMAC _ns1__GetPresetList
{
public:
	int channel;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE__ns1__GetPresetList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetPresetList(): soap(NULL) { _ns1__GetPresetList::soap_default(NULL); }
	virtual ~_ns1__GetPresetList() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetPresetListResponse
#define SOAP_TYPE__ns1__GetPresetListResponse (39)
/* ns1:GetPresetListResponse */
class SOAP_CMAC _ns1__GetPresetListResponse
{
public:
	ns1__ArrayOfPreset_USCORET *GetPresetListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ArrayOfPreset_T */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE__ns1__GetPresetListResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetPresetListResponse(): GetPresetListResult(NULL), soap(NULL) { _ns1__GetPresetListResponse::soap_default(NULL); }
	virtual ~_ns1__GetPresetListResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddPreset
#define SOAP_TYPE__ns1__AddPreset (40)
/* ns1:AddPreset */
class SOAP_CMAC _ns1__AddPreset
{
public:
	int channel;	/* required element of type xsd:int */
	ns1__Preset_USCORET *preset;	/* optional element of type ns1:Preset_T */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE__ns1__AddPreset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddPreset(): preset(NULL), soap(NULL) { _ns1__AddPreset::soap_default(NULL); }
	virtual ~_ns1__AddPreset() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddPresetResponse
#define SOAP_TYPE__ns1__AddPresetResponse (41)
/* ns1:AddPresetResponse */
class SOAP_CMAC _ns1__AddPresetResponse
{
public:
	bool AddPresetResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE__ns1__AddPresetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddPresetResponse(): soap(NULL) { _ns1__AddPresetResponse::soap_default(NULL); }
	virtual ~_ns1__AddPresetResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GotoPreset
#define SOAP_TYPE__ns1__GotoPreset (42)
/* ns1:GotoPreset */
class SOAP_CMAC _ns1__GotoPreset
{
public:
	int channel;	/* required element of type xsd:int */
	char *alias;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE__ns1__GotoPreset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GotoPreset(): alias(NULL), soap(NULL) { _ns1__GotoPreset::soap_default(NULL); }
	virtual ~_ns1__GotoPreset() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GotoPresetResponse
#define SOAP_TYPE__ns1__GotoPresetResponse (43)
/* ns1:GotoPresetResponse */
class SOAP_CMAC _ns1__GotoPresetResponse
{
public:
	int resultCode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE__ns1__GotoPresetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GotoPresetResponse(): soap(NULL) { _ns1__GotoPresetResponse::soap_default(NULL); }
	virtual ~_ns1__GotoPresetResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemovePreset
#define SOAP_TYPE__ns1__RemovePreset (44)
/* ns1:RemovePreset */
class SOAP_CMAC _ns1__RemovePreset
{
public:
	int channel;	/* required element of type xsd:int */
	char *alias;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE__ns1__RemovePreset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemovePreset(): alias(NULL), soap(NULL) { _ns1__RemovePreset::soap_default(NULL); }
	virtual ~_ns1__RemovePreset() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemovePresetResponse
#define SOAP_TYPE__ns1__RemovePresetResponse (45)
/* ns1:RemovePresetResponse */
class SOAP_CMAC _ns1__RemovePresetResponse
{
public:
	bool RemovePresetResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE__ns1__RemovePresetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemovePresetResponse(): soap(NULL) { _ns1__RemovePresetResponse::soap_default(NULL); }
	virtual ~_ns1__RemovePresetResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetPresetTour
#define SOAP_TYPE__ns1__GetPresetTour (46)
/* ns1:GetPresetTour */
class SOAP_CMAC _ns1__GetPresetTour
{
public:
	int channel;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE__ns1__GetPresetTour */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetPresetTour(): soap(NULL) { _ns1__GetPresetTour::soap_default(NULL); }
	virtual ~_ns1__GetPresetTour() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetPresetTourResponse
#define SOAP_TYPE__ns1__GetPresetTourResponse (47)
/* ns1:GetPresetTourResponse */
class SOAP_CMAC _ns1__GetPresetTourResponse
{
public:
	ns1__ArrayOfPreset_USCORET *GetPresetTourResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ArrayOfPreset_T */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE__ns1__GetPresetTourResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetPresetTourResponse(): GetPresetTourResult(NULL), soap(NULL) { _ns1__GetPresetTourResponse::soap_default(NULL); }
	virtual ~_ns1__GetPresetTourResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetPresetTour
#define SOAP_TYPE__ns1__SetPresetTour (48)
/* ns1:SetPresetTour */
class SOAP_CMAC _ns1__SetPresetTour
{
public:
	int channel;	/* required element of type xsd:int */
	ns1__ArrayOfPreset_USCORET *presetList;	/* optional element of type ns1:ArrayOfPreset_T */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE__ns1__SetPresetTour */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetPresetTour(): presetList(NULL), soap(NULL) { _ns1__SetPresetTour::soap_default(NULL); }
	virtual ~_ns1__SetPresetTour() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetPresetTourResponse
#define SOAP_TYPE__ns1__SetPresetTourResponse (49)
/* ns1:SetPresetTourResponse */
class SOAP_CMAC _ns1__SetPresetTourResponse
{
public:
	bool SetPresetTourResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE__ns1__SetPresetTourResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetPresetTourResponse(): soap(NULL) { _ns1__SetPresetTourResponse::soap_default(NULL); }
	virtual ~_ns1__SetPresetTourResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__PlayPresetTour
#define SOAP_TYPE__ns1__PlayPresetTour (50)
/* ns1:PlayPresetTour */
class SOAP_CMAC _ns1__PlayPresetTour
{
public:
	int channel;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE__ns1__PlayPresetTour */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__PlayPresetTour(): soap(NULL) { _ns1__PlayPresetTour::soap_default(NULL); }
	virtual ~_ns1__PlayPresetTour() { }
};
#endif

#ifndef SOAP_TYPE__ns1__PlayPresetTourResponse
#define SOAP_TYPE__ns1__PlayPresetTourResponse (51)
/* ns1:PlayPresetTourResponse */
class SOAP_CMAC _ns1__PlayPresetTourResponse
{
public:
	int resultCode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE__ns1__PlayPresetTourResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__PlayPresetTourResponse(): soap(NULL) { _ns1__PlayPresetTourResponse::soap_default(NULL); }
	virtual ~_ns1__PlayPresetTourResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__StopPresetTour
#define SOAP_TYPE__ns1__StopPresetTour (52)
/* ns1:StopPresetTour */
class SOAP_CMAC _ns1__StopPresetTour
{
public:
	int channel;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE__ns1__StopPresetTour */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__StopPresetTour(): soap(NULL) { _ns1__StopPresetTour::soap_default(NULL); }
	virtual ~_ns1__StopPresetTour() { }
};
#endif

#ifndef SOAP_TYPE__ns1__StopPresetTourResponse
#define SOAP_TYPE__ns1__StopPresetTourResponse (53)
/* ns1:StopPresetTourResponse */
class SOAP_CMAC _ns1__StopPresetTourResponse
{
public:
	int resultCode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE__ns1__StopPresetTourResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__StopPresetTourResponse(): soap(NULL) { _ns1__StopPresetTourResponse::soap_default(NULL); }
	virtual ~_ns1__StopPresetTourResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__StartPatternRecording
#define SOAP_TYPE__ns1__StartPatternRecording (54)
/* ns1:StartPatternRecording */
class SOAP_CMAC _ns1__StartPatternRecording
{
public:
	int channel;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE__ns1__StartPatternRecording */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__StartPatternRecording(): soap(NULL) { _ns1__StartPatternRecording::soap_default(NULL); }
	virtual ~_ns1__StartPatternRecording() { }
};
#endif

#ifndef SOAP_TYPE__ns1__StartPatternRecordingResponse
#define SOAP_TYPE__ns1__StartPatternRecordingResponse (55)
/* ns1:StartPatternRecordingResponse */
class SOAP_CMAC _ns1__StartPatternRecordingResponse
{
public:
	bool StartPatternRecordingResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE__ns1__StartPatternRecordingResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__StartPatternRecordingResponse(): soap(NULL) { _ns1__StartPatternRecordingResponse::soap_default(NULL); }
	virtual ~_ns1__StartPatternRecordingResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__StopPatternRecording
#define SOAP_TYPE__ns1__StopPatternRecording (56)
/* ns1:StopPatternRecording */
class SOAP_CMAC _ns1__StopPatternRecording
{
public:
	int channel;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE__ns1__StopPatternRecording */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__StopPatternRecording(): soap(NULL) { _ns1__StopPatternRecording::soap_default(NULL); }
	virtual ~_ns1__StopPatternRecording() { }
};
#endif

#ifndef SOAP_TYPE__ns1__StopPatternRecordingResponse
#define SOAP_TYPE__ns1__StopPatternRecordingResponse (57)
/* ns1:StopPatternRecordingResponse */
class SOAP_CMAC _ns1__StopPatternRecordingResponse
{
public:
	bool StopPatternRecordingResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE__ns1__StopPatternRecordingResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__StopPatternRecordingResponse(): soap(NULL) { _ns1__StopPatternRecordingResponse::soap_default(NULL); }
	virtual ~_ns1__StopPatternRecordingResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__PlayRecordedPattern
#define SOAP_TYPE__ns1__PlayRecordedPattern (58)
/* ns1:PlayRecordedPattern */
class SOAP_CMAC _ns1__PlayRecordedPattern
{
public:
	int channel;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE__ns1__PlayRecordedPattern */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__PlayRecordedPattern(): soap(NULL) { _ns1__PlayRecordedPattern::soap_default(NULL); }
	virtual ~_ns1__PlayRecordedPattern() { }
};
#endif

#ifndef SOAP_TYPE__ns1__PlayRecordedPatternResponse
#define SOAP_TYPE__ns1__PlayRecordedPatternResponse (59)
/* ns1:PlayRecordedPatternResponse */
class SOAP_CMAC _ns1__PlayRecordedPatternResponse
{
public:
	int resultCode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE__ns1__PlayRecordedPatternResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__PlayRecordedPatternResponse(): soap(NULL) { _ns1__PlayRecordedPatternResponse::soap_default(NULL); }
	virtual ~_ns1__PlayRecordedPatternResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__StopRecordedPattern
#define SOAP_TYPE__ns1__StopRecordedPattern (60)
/* ns1:StopRecordedPattern */
class SOAP_CMAC _ns1__StopRecordedPattern
{
public:
	int channel;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE__ns1__StopRecordedPattern */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__StopRecordedPattern(): soap(NULL) { _ns1__StopRecordedPattern::soap_default(NULL); }
	virtual ~_ns1__StopRecordedPattern() { }
};
#endif

#ifndef SOAP_TYPE__ns1__StopRecordedPatternResponse
#define SOAP_TYPE__ns1__StopRecordedPatternResponse (61)
/* ns1:StopRecordedPatternResponse */
class SOAP_CMAC _ns1__StopRecordedPatternResponse
{
public:
	int resultCode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE__ns1__StopRecordedPatternResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__StopRecordedPatternResponse(): soap(NULL) { _ns1__StopRecordedPatternResponse::soap_default(NULL); }
	virtual ~_ns1__StopRecordedPatternResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetPTZConfiguration
#define SOAP_TYPE__ns1__GetPTZConfiguration (62)
/* ns1:GetPTZConfiguration */
class SOAP_CMAC _ns1__GetPTZConfiguration
{
public:
	int channel;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE__ns1__GetPTZConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetPTZConfiguration(): soap(NULL) { _ns1__GetPTZConfiguration::soap_default(NULL); }
	virtual ~_ns1__GetPTZConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetPTZConfigurationResponse
#define SOAP_TYPE__ns1__GetPTZConfigurationResponse (63)
/* ns1:GetPTZConfigurationResponse */
class SOAP_CMAC _ns1__GetPTZConfigurationResponse
{
public:
	ns1__ArrayOfParameter_USCORET *GetPTZConfigurationResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ArrayOfParameter_T */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE__ns1__GetPTZConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetPTZConfigurationResponse(): GetPTZConfigurationResult(NULL), soap(NULL) { _ns1__GetPTZConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__GetPTZConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetPTZConfiguration
#define SOAP_TYPE__ns1__SetPTZConfiguration (64)
/* ns1:SetPTZConfiguration */
class SOAP_CMAC _ns1__SetPTZConfiguration
{
public:
	int channel;	/* required element of type xsd:int */
	ns1__ArrayOfParameter_USCORET *param;	/* optional element of type ns1:ArrayOfParameter_T */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE__ns1__SetPTZConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetPTZConfiguration(): param(NULL), soap(NULL) { _ns1__SetPTZConfiguration::soap_default(NULL); }
	virtual ~_ns1__SetPTZConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetPTZConfigurationResponse
#define SOAP_TYPE__ns1__SetPTZConfigurationResponse (65)
/* ns1:SetPTZConfigurationResponse */
class SOAP_CMAC _ns1__SetPTZConfigurationResponse
{
public:
	bool SetPTZConfigurationResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE__ns1__SetPTZConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetPTZConfigurationResponse(): soap(NULL) { _ns1__SetPTZConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__SetPTZConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetPTZPort
#define SOAP_TYPE__ns1__GetPTZPort (66)
/* ns1:GetPTZPort */
class SOAP_CMAC _ns1__GetPTZPort
{
public:
	int channel;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE__ns1__GetPTZPort */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetPTZPort(): soap(NULL) { _ns1__GetPTZPort::soap_default(NULL); }
	virtual ~_ns1__GetPTZPort() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetPTZPortResponse
#define SOAP_TYPE__ns1__GetPTZPortResponse (67)
/* ns1:GetPTZPortResponse */
class SOAP_CMAC _ns1__GetPTZPortResponse
{
public:
	ns1__PortConfig_USCORET *GetPTZPortResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:PortConfig_T */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE__ns1__GetPTZPortResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetPTZPortResponse(): GetPTZPortResult(NULL), soap(NULL) { _ns1__GetPTZPortResponse::soap_default(NULL); }
	virtual ~_ns1__GetPTZPortResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetPTZPort
#define SOAP_TYPE__ns1__SetPTZPort (68)
/* ns1:SetPTZPort */
class SOAP_CMAC _ns1__SetPTZPort
{
public:
	int channel;	/* required element of type xsd:int */
	ns1__PortConfig_USCORET *port;	/* optional element of type ns1:PortConfig_T */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE__ns1__SetPTZPort */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetPTZPort(): port(NULL), soap(NULL) { _ns1__SetPTZPort::soap_default(NULL); }
	virtual ~_ns1__SetPTZPort() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetPTZPortResponse
#define SOAP_TYPE__ns1__SetPTZPortResponse (69)
/* ns1:SetPTZPortResponse */
class SOAP_CMAC _ns1__SetPTZPortResponse
{
public:
	bool SetPTZPortResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE__ns1__SetPTZPortResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetPTZPortResponse(): soap(NULL) { _ns1__SetPTZPortResponse::soap_default(NULL); }
	virtual ~_ns1__SetPTZPortResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__PTZByPass
#define SOAP_TYPE__ns1__PTZByPass (70)
/* ns1:PTZByPass */
class SOAP_CMAC _ns1__PTZByPass
{
public:
	int channel;	/* required element of type xsd:int */
	char *command;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE__ns1__PTZByPass */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__PTZByPass(): command(NULL), soap(NULL) { _ns1__PTZByPass::soap_default(NULL); }
	virtual ~_ns1__PTZByPass() { }
};
#endif

#ifndef SOAP_TYPE__ns1__PTZByPassResponse
#define SOAP_TYPE__ns1__PTZByPassResponse (71)
/* ns1:PTZByPassResponse */
class SOAP_CMAC _ns1__PTZByPassResponse
{
public:
	char *PTZByPassResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE__ns1__PTZByPassResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__PTZByPassResponse(): PTZByPassResult(NULL), soap(NULL) { _ns1__PTZByPassResponse::soap_default(NULL); }
	virtual ~_ns1__PTZByPassResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__OSDMenu
#define SOAP_TYPE__ns1__OSDMenu (72)
/* ns1:OSDMenu */
class SOAP_CMAC _ns1__OSDMenu
{
public:
	enum ns1__OSD_USCOREMENU_USCORET osdMenu;	/* required element of type ns1:OSD_MENU_T */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE__ns1__OSDMenu */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__OSDMenu(): soap(NULL) { _ns1__OSDMenu::soap_default(NULL); }
	virtual ~_ns1__OSDMenu() { }
};
#endif

#ifndef SOAP_TYPE__ns1__OSDMenuResponse
#define SOAP_TYPE__ns1__OSDMenuResponse (73)
/* ns1:OSDMenuResponse */
class SOAP_CMAC _ns1__OSDMenuResponse
{
public:
	bool OSDMenuResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique id SOAP_TYPE__ns1__OSDMenuResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__OSDMenuResponse(): soap(NULL) { _ns1__OSDMenuResponse::soap_default(NULL); }
	virtual ~_ns1__OSDMenuResponse() { }
};
#endif

#ifndef SOAP_TYPE___ns2__GetPTZProtocolList
#define SOAP_TYPE___ns2__GetPTZProtocolList (92)
/* Operation wrapper: */
struct __ns2__GetPTZProtocolList
{
public:
	_ns1__GetPTZProtocolList *ns1__GetPTZProtocolList;	/* optional element of type ns1:GetPTZProtocolList */
};
#endif

#ifndef SOAP_TYPE___ns2__GetPTZProtocol
#define SOAP_TYPE___ns2__GetPTZProtocol (96)
/* Operation wrapper: */
struct __ns2__GetPTZProtocol
{
public:
	_ns1__GetPTZProtocol *ns1__GetPTZProtocol;	/* optional element of type ns1:GetPTZProtocol */
};
#endif

#ifndef SOAP_TYPE___ns2__SetPTZProtocol
#define SOAP_TYPE___ns2__SetPTZProtocol (100)
/* Operation wrapper: */
struct __ns2__SetPTZProtocol
{
public:
	_ns1__SetPTZProtocol *ns1__SetPTZProtocol;	/* optional element of type ns1:SetPTZProtocol */
};
#endif

#ifndef SOAP_TYPE___ns2__AddPTZProtocol
#define SOAP_TYPE___ns2__AddPTZProtocol (104)
/* Operation wrapper: */
struct __ns2__AddPTZProtocol
{
public:
	_ns1__AddPTZProtocol *ns1__AddPTZProtocol;	/* optional element of type ns1:AddPTZProtocol */
};
#endif

#ifndef SOAP_TYPE___ns2__RemovePTZProtocol
#define SOAP_TYPE___ns2__RemovePTZProtocol (108)
/* Operation wrapper: */
struct __ns2__RemovePTZProtocol
{
public:
	_ns1__RemovePTZProtocol *ns1__RemovePTZProtocol;	/* optional element of type ns1:RemovePTZProtocol */
};
#endif

#ifndef SOAP_TYPE___ns2__GetPTZProtocolInfo
#define SOAP_TYPE___ns2__GetPTZProtocolInfo (112)
/* Operation wrapper: */
struct __ns2__GetPTZProtocolInfo
{
public:
	_ns1__GetPTZProtocolInfo *ns1__GetPTZProtocolInfo;	/* optional element of type ns1:GetPTZProtocolInfo */
};
#endif

#ifndef SOAP_TYPE___ns2__GetPTZCommandList
#define SOAP_TYPE___ns2__GetPTZCommandList (116)
/* Operation wrapper: */
struct __ns2__GetPTZCommandList
{
public:
	_ns1__GetPTZCommandList *ns1__GetPTZCommandList;	/* optional element of type ns1:GetPTZCommandList */
};
#endif

#ifndef SOAP_TYPE___ns2__ControlPTZ
#define SOAP_TYPE___ns2__ControlPTZ (120)
/* Operation wrapper: */
struct __ns2__ControlPTZ
{
public:
	_ns1__ControlPTZ *ns1__ControlPTZ;	/* optional element of type ns1:ControlPTZ */
};
#endif

#ifndef SOAP_TYPE___ns2__Stop
#define SOAP_TYPE___ns2__Stop (124)
/* Operation wrapper: */
struct __ns2__Stop
{
public:
	_ns1__Stop *ns1__Stop;	/* optional element of type ns1:Stop */
};
#endif

#ifndef SOAP_TYPE___ns2__GetPresetList
#define SOAP_TYPE___ns2__GetPresetList (128)
/* Operation wrapper: */
struct __ns2__GetPresetList
{
public:
	_ns1__GetPresetList *ns1__GetPresetList;	/* optional element of type ns1:GetPresetList */
};
#endif

#ifndef SOAP_TYPE___ns2__AddPreset
#define SOAP_TYPE___ns2__AddPreset (132)
/* Operation wrapper: */
struct __ns2__AddPreset
{
public:
	_ns1__AddPreset *ns1__AddPreset;	/* optional element of type ns1:AddPreset */
};
#endif

#ifndef SOAP_TYPE___ns2__GotoPreset
#define SOAP_TYPE___ns2__GotoPreset (136)
/* Operation wrapper: */
struct __ns2__GotoPreset
{
public:
	_ns1__GotoPreset *ns1__GotoPreset;	/* optional element of type ns1:GotoPreset */
};
#endif

#ifndef SOAP_TYPE___ns2__RemovePreset
#define SOAP_TYPE___ns2__RemovePreset (140)
/* Operation wrapper: */
struct __ns2__RemovePreset
{
public:
	_ns1__RemovePreset *ns1__RemovePreset;	/* optional element of type ns1:RemovePreset */
};
#endif

#ifndef SOAP_TYPE___ns2__GetPresetTour
#define SOAP_TYPE___ns2__GetPresetTour (144)
/* Operation wrapper: */
struct __ns2__GetPresetTour
{
public:
	_ns1__GetPresetTour *ns1__GetPresetTour;	/* optional element of type ns1:GetPresetTour */
};
#endif

#ifndef SOAP_TYPE___ns2__SetPresetTour
#define SOAP_TYPE___ns2__SetPresetTour (148)
/* Operation wrapper: */
struct __ns2__SetPresetTour
{
public:
	_ns1__SetPresetTour *ns1__SetPresetTour;	/* optional element of type ns1:SetPresetTour */
};
#endif

#ifndef SOAP_TYPE___ns2__PlayPresetTour
#define SOAP_TYPE___ns2__PlayPresetTour (152)
/* Operation wrapper: */
struct __ns2__PlayPresetTour
{
public:
	_ns1__PlayPresetTour *ns1__PlayPresetTour;	/* optional element of type ns1:PlayPresetTour */
};
#endif

#ifndef SOAP_TYPE___ns2__StopPresetTour
#define SOAP_TYPE___ns2__StopPresetTour (156)
/* Operation wrapper: */
struct __ns2__StopPresetTour
{
public:
	_ns1__StopPresetTour *ns1__StopPresetTour;	/* optional element of type ns1:StopPresetTour */
};
#endif

#ifndef SOAP_TYPE___ns2__StartPatternRecording
#define SOAP_TYPE___ns2__StartPatternRecording (160)
/* Operation wrapper: */
struct __ns2__StartPatternRecording
{
public:
	_ns1__StartPatternRecording *ns1__StartPatternRecording;	/* optional element of type ns1:StartPatternRecording */
};
#endif

#ifndef SOAP_TYPE___ns2__StopPatternRecording
#define SOAP_TYPE___ns2__StopPatternRecording (164)
/* Operation wrapper: */
struct __ns2__StopPatternRecording
{
public:
	_ns1__StopPatternRecording *ns1__StopPatternRecording;	/* optional element of type ns1:StopPatternRecording */
};
#endif

#ifndef SOAP_TYPE___ns2__PlayRecordedPattern
#define SOAP_TYPE___ns2__PlayRecordedPattern (168)
/* Operation wrapper: */
struct __ns2__PlayRecordedPattern
{
public:
	_ns1__PlayRecordedPattern *ns1__PlayRecordedPattern;	/* optional element of type ns1:PlayRecordedPattern */
};
#endif

#ifndef SOAP_TYPE___ns2__StopRecordedPattern
#define SOAP_TYPE___ns2__StopRecordedPattern (172)
/* Operation wrapper: */
struct __ns2__StopRecordedPattern
{
public:
	_ns1__StopRecordedPattern *ns1__StopRecordedPattern;	/* optional element of type ns1:StopRecordedPattern */
};
#endif

#ifndef SOAP_TYPE___ns2__GetPTZConfiguration
#define SOAP_TYPE___ns2__GetPTZConfiguration (176)
/* Operation wrapper: */
struct __ns2__GetPTZConfiguration
{
public:
	_ns1__GetPTZConfiguration *ns1__GetPTZConfiguration;	/* optional element of type ns1:GetPTZConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns2__SetPTZConfiguration
#define SOAP_TYPE___ns2__SetPTZConfiguration (180)
/* Operation wrapper: */
struct __ns2__SetPTZConfiguration
{
public:
	_ns1__SetPTZConfiguration *ns1__SetPTZConfiguration;	/* optional element of type ns1:SetPTZConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns2__GetPTZPort
#define SOAP_TYPE___ns2__GetPTZPort (184)
/* Operation wrapper: */
struct __ns2__GetPTZPort
{
public:
	_ns1__GetPTZPort *ns1__GetPTZPort;	/* optional element of type ns1:GetPTZPort */
};
#endif

#ifndef SOAP_TYPE___ns2__SetPTZPort
#define SOAP_TYPE___ns2__SetPTZPort (188)
/* Operation wrapper: */
struct __ns2__SetPTZPort
{
public:
	_ns1__SetPTZPort *ns1__SetPTZPort;	/* optional element of type ns1:SetPTZPort */
};
#endif

#ifndef SOAP_TYPE___ns2__PTZByPass
#define SOAP_TYPE___ns2__PTZByPass (192)
/* Operation wrapper: */
struct __ns2__PTZByPass
{
public:
	_ns1__PTZByPass *ns1__PTZByPass;	/* optional element of type ns1:PTZByPass */
};
#endif

#ifndef SOAP_TYPE___ns2__OSDMenu
#define SOAP_TYPE___ns2__OSDMenu (196)
/* Operation wrapper: */
struct __ns2__OSDMenu
{
public:
	_ns1__OSDMenu *ns1__OSDMenu;	/* optional element of type ns1:OSDMenu */
};
#endif

#ifndef SOAP_TYPE___ns3__GetPTZProtocolList
#define SOAP_TYPE___ns3__GetPTZProtocolList (198)
/* Operation wrapper: */
struct __ns3__GetPTZProtocolList
{
public:
	_ns1__GetPTZProtocolList *ns1__GetPTZProtocolList;	/* optional element of type ns1:GetPTZProtocolList */
};
#endif

#ifndef SOAP_TYPE___ns3__GetPTZProtocol
#define SOAP_TYPE___ns3__GetPTZProtocol (200)
/* Operation wrapper: */
struct __ns3__GetPTZProtocol
{
public:
	_ns1__GetPTZProtocol *ns1__GetPTZProtocol;	/* optional element of type ns1:GetPTZProtocol */
};
#endif

#ifndef SOAP_TYPE___ns3__SetPTZProtocol
#define SOAP_TYPE___ns3__SetPTZProtocol (202)
/* Operation wrapper: */
struct __ns3__SetPTZProtocol
{
public:
	_ns1__SetPTZProtocol *ns1__SetPTZProtocol;	/* optional element of type ns1:SetPTZProtocol */
};
#endif

#ifndef SOAP_TYPE___ns3__AddPTZProtocol
#define SOAP_TYPE___ns3__AddPTZProtocol (204)
/* Operation wrapper: */
struct __ns3__AddPTZProtocol
{
public:
	_ns1__AddPTZProtocol *ns1__AddPTZProtocol;	/* optional element of type ns1:AddPTZProtocol */
};
#endif

#ifndef SOAP_TYPE___ns3__RemovePTZProtocol
#define SOAP_TYPE___ns3__RemovePTZProtocol (206)
/* Operation wrapper: */
struct __ns3__RemovePTZProtocol
{
public:
	_ns1__RemovePTZProtocol *ns1__RemovePTZProtocol;	/* optional element of type ns1:RemovePTZProtocol */
};
#endif

#ifndef SOAP_TYPE___ns3__GetPTZProtocolInfo
#define SOAP_TYPE___ns3__GetPTZProtocolInfo (208)
/* Operation wrapper: */
struct __ns3__GetPTZProtocolInfo
{
public:
	_ns1__GetPTZProtocolInfo *ns1__GetPTZProtocolInfo;	/* optional element of type ns1:GetPTZProtocolInfo */
};
#endif

#ifndef SOAP_TYPE___ns3__GetPTZCommandList
#define SOAP_TYPE___ns3__GetPTZCommandList (210)
/* Operation wrapper: */
struct __ns3__GetPTZCommandList
{
public:
	_ns1__GetPTZCommandList *ns1__GetPTZCommandList;	/* optional element of type ns1:GetPTZCommandList */
};
#endif

#ifndef SOAP_TYPE___ns3__ControlPTZ
#define SOAP_TYPE___ns3__ControlPTZ (212)
/* Operation wrapper: */
struct __ns3__ControlPTZ
{
public:
	_ns1__ControlPTZ *ns1__ControlPTZ;	/* optional element of type ns1:ControlPTZ */
};
#endif

#ifndef SOAP_TYPE___ns3__Stop
#define SOAP_TYPE___ns3__Stop (214)
/* Operation wrapper: */
struct __ns3__Stop
{
public:
	_ns1__Stop *ns1__Stop;	/* optional element of type ns1:Stop */
};
#endif

#ifndef SOAP_TYPE___ns3__GetPresetList
#define SOAP_TYPE___ns3__GetPresetList (216)
/* Operation wrapper: */
struct __ns3__GetPresetList
{
public:
	_ns1__GetPresetList *ns1__GetPresetList;	/* optional element of type ns1:GetPresetList */
};
#endif

#ifndef SOAP_TYPE___ns3__AddPreset
#define SOAP_TYPE___ns3__AddPreset (218)
/* Operation wrapper: */
struct __ns3__AddPreset
{
public:
	_ns1__AddPreset *ns1__AddPreset;	/* optional element of type ns1:AddPreset */
};
#endif

#ifndef SOAP_TYPE___ns3__GotoPreset
#define SOAP_TYPE___ns3__GotoPreset (220)
/* Operation wrapper: */
struct __ns3__GotoPreset
{
public:
	_ns1__GotoPreset *ns1__GotoPreset;	/* optional element of type ns1:GotoPreset */
};
#endif

#ifndef SOAP_TYPE___ns3__RemovePreset
#define SOAP_TYPE___ns3__RemovePreset (222)
/* Operation wrapper: */
struct __ns3__RemovePreset
{
public:
	_ns1__RemovePreset *ns1__RemovePreset;	/* optional element of type ns1:RemovePreset */
};
#endif

#ifndef SOAP_TYPE___ns3__GetPresetTour
#define SOAP_TYPE___ns3__GetPresetTour (224)
/* Operation wrapper: */
struct __ns3__GetPresetTour
{
public:
	_ns1__GetPresetTour *ns1__GetPresetTour;	/* optional element of type ns1:GetPresetTour */
};
#endif

#ifndef SOAP_TYPE___ns3__SetPresetTour
#define SOAP_TYPE___ns3__SetPresetTour (226)
/* Operation wrapper: */
struct __ns3__SetPresetTour
{
public:
	_ns1__SetPresetTour *ns1__SetPresetTour;	/* optional element of type ns1:SetPresetTour */
};
#endif

#ifndef SOAP_TYPE___ns3__PlayPresetTour
#define SOAP_TYPE___ns3__PlayPresetTour (228)
/* Operation wrapper: */
struct __ns3__PlayPresetTour
{
public:
	_ns1__PlayPresetTour *ns1__PlayPresetTour;	/* optional element of type ns1:PlayPresetTour */
};
#endif

#ifndef SOAP_TYPE___ns3__StopPresetTour
#define SOAP_TYPE___ns3__StopPresetTour (230)
/* Operation wrapper: */
struct __ns3__StopPresetTour
{
public:
	_ns1__StopPresetTour *ns1__StopPresetTour;	/* optional element of type ns1:StopPresetTour */
};
#endif

#ifndef SOAP_TYPE___ns3__StartPatternRecording
#define SOAP_TYPE___ns3__StartPatternRecording (232)
/* Operation wrapper: */
struct __ns3__StartPatternRecording
{
public:
	_ns1__StartPatternRecording *ns1__StartPatternRecording;	/* optional element of type ns1:StartPatternRecording */
};
#endif

#ifndef SOAP_TYPE___ns3__StopPatternRecording
#define SOAP_TYPE___ns3__StopPatternRecording (234)
/* Operation wrapper: */
struct __ns3__StopPatternRecording
{
public:
	_ns1__StopPatternRecording *ns1__StopPatternRecording;	/* optional element of type ns1:StopPatternRecording */
};
#endif

#ifndef SOAP_TYPE___ns3__PlayRecordedPattern
#define SOAP_TYPE___ns3__PlayRecordedPattern (236)
/* Operation wrapper: */
struct __ns3__PlayRecordedPattern
{
public:
	_ns1__PlayRecordedPattern *ns1__PlayRecordedPattern;	/* optional element of type ns1:PlayRecordedPattern */
};
#endif

#ifndef SOAP_TYPE___ns3__StopRecordedPattern
#define SOAP_TYPE___ns3__StopRecordedPattern (238)
/* Operation wrapper: */
struct __ns3__StopRecordedPattern
{
public:
	_ns1__StopRecordedPattern *ns1__StopRecordedPattern;	/* optional element of type ns1:StopRecordedPattern */
};
#endif

#ifndef SOAP_TYPE___ns3__GetPTZConfiguration
#define SOAP_TYPE___ns3__GetPTZConfiguration (240)
/* Operation wrapper: */
struct __ns3__GetPTZConfiguration
{
public:
	_ns1__GetPTZConfiguration *ns1__GetPTZConfiguration;	/* optional element of type ns1:GetPTZConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns3__SetPTZConfiguration
#define SOAP_TYPE___ns3__SetPTZConfiguration (242)
/* Operation wrapper: */
struct __ns3__SetPTZConfiguration
{
public:
	_ns1__SetPTZConfiguration *ns1__SetPTZConfiguration;	/* optional element of type ns1:SetPTZConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns3__GetPTZPort
#define SOAP_TYPE___ns3__GetPTZPort (244)
/* Operation wrapper: */
struct __ns3__GetPTZPort
{
public:
	_ns1__GetPTZPort *ns1__GetPTZPort;	/* optional element of type ns1:GetPTZPort */
};
#endif

#ifndef SOAP_TYPE___ns3__SetPTZPort
#define SOAP_TYPE___ns3__SetPTZPort (246)
/* Operation wrapper: */
struct __ns3__SetPTZPort
{
public:
	_ns1__SetPTZPort *ns1__SetPTZPort;	/* optional element of type ns1:SetPTZPort */
};
#endif

#ifndef SOAP_TYPE___ns3__PTZByPass
#define SOAP_TYPE___ns3__PTZByPass (248)
/* Operation wrapper: */
struct __ns3__PTZByPass
{
public:
	_ns1__PTZByPass *ns1__PTZByPass;	/* optional element of type ns1:PTZByPass */
};
#endif

#ifndef SOAP_TYPE___ns3__OSDMenu
#define SOAP_TYPE___ns3__OSDMenu (250)
/* Operation wrapper: */
struct __ns3__OSDMenu
{
public:
	_ns1__OSDMenu *ns1__OSDMenu;	/* optional element of type ns1:OSDMenu */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (251)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (252)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (254)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (257)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (258)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
