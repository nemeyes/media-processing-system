/* soapC.cpp
   Generated by gSOAP 2.7.13 from lge_lw9424_soapapi.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "gsoap/soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.13 2013-05-12 10:23:41 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__OSD_USCOREMENU_USCORET:
		return soap_in_ns1__OSD_USCOREMENU_USCORET(soap, NULL, NULL, "ns1:OSD_MENU_T");
	case SOAP_TYPE_ns1__PARITY_USCORET:
		return soap_in_ns1__PARITY_USCORET(soap, NULL, NULL, "ns1:PARITY_T");
	case SOAP_TYPE_ns1__PortConfig_USCORET:
		return soap_in_ns1__PortConfig_USCORET(soap, NULL, NULL, "ns1:PortConfig_T");
	case SOAP_TYPE_ns1__Preset_USCORET:
		return soap_in_ns1__Preset_USCORET(soap, NULL, NULL, "ns1:Preset_T");
	case SOAP_TYPE_ns1__ArrayOfPreset_USCORET:
		return soap_in_ns1__ArrayOfPreset_USCORET(soap, NULL, NULL, "ns1:ArrayOfPreset_T");
	case SOAP_TYPE_ns1__Parameter_USCORET:
		return soap_in_ns1__Parameter_USCORET(soap, NULL, NULL, "ns1:Parameter_T");
	case SOAP_TYPE_ns1__ArrayOfParameter_USCORET:
		return soap_in_ns1__ArrayOfParameter_USCORET(soap, NULL, NULL, "ns1:ArrayOfParameter_T");
	case SOAP_TYPE_ns1__IntRange_USCORET:
		return soap_in_ns1__IntRange_USCORET(soap, NULL, NULL, "ns1:IntRange_T");
	case SOAP_TYPE_ns1__PTZProtocol_USCORET:
		return soap_in_ns1__PTZProtocol_USCORET(soap, NULL, NULL, "ns1:PTZProtocol_T");
	case SOAP_TYPE_ns1__ArrayOfString:
		return soap_in_ns1__ArrayOfString(soap, NULL, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTo_ns1__OSDMenuResponse:
		return soap_in_PointerTo_ns1__OSDMenuResponse(soap, NULL, NULL, "ns1:OSDMenuResponse");
	case SOAP_TYPE_PointerTo_ns1__OSDMenu:
		return soap_in_PointerTo_ns1__OSDMenu(soap, NULL, NULL, "ns1:OSDMenu");
	case SOAP_TYPE_PointerTo_ns1__PTZByPassResponse:
		return soap_in_PointerTo_ns1__PTZByPassResponse(soap, NULL, NULL, "ns1:PTZByPassResponse");
	case SOAP_TYPE_PointerTo_ns1__PTZByPass:
		return soap_in_PointerTo_ns1__PTZByPass(soap, NULL, NULL, "ns1:PTZByPass");
	case SOAP_TYPE_PointerTo_ns1__SetPTZPortResponse:
		return soap_in_PointerTo_ns1__SetPTZPortResponse(soap, NULL, NULL, "ns1:SetPTZPortResponse");
	case SOAP_TYPE_PointerTo_ns1__SetPTZPort:
		return soap_in_PointerTo_ns1__SetPTZPort(soap, NULL, NULL, "ns1:SetPTZPort");
	case SOAP_TYPE_PointerTo_ns1__GetPTZPortResponse:
		return soap_in_PointerTo_ns1__GetPTZPortResponse(soap, NULL, NULL, "ns1:GetPTZPortResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPTZPort:
		return soap_in_PointerTo_ns1__GetPTZPort(soap, NULL, NULL, "ns1:GetPTZPort");
	case SOAP_TYPE_PointerTo_ns1__SetPTZConfigurationResponse:
		return soap_in_PointerTo_ns1__SetPTZConfigurationResponse(soap, NULL, NULL, "ns1:SetPTZConfigurationResponse");
	case SOAP_TYPE_PointerTo_ns1__SetPTZConfiguration:
		return soap_in_PointerTo_ns1__SetPTZConfiguration(soap, NULL, NULL, "ns1:SetPTZConfiguration");
	case SOAP_TYPE_PointerTo_ns1__GetPTZConfigurationResponse:
		return soap_in_PointerTo_ns1__GetPTZConfigurationResponse(soap, NULL, NULL, "ns1:GetPTZConfigurationResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPTZConfiguration:
		return soap_in_PointerTo_ns1__GetPTZConfiguration(soap, NULL, NULL, "ns1:GetPTZConfiguration");
	case SOAP_TYPE_PointerTo_ns1__StopRecordedPatternResponse:
		return soap_in_PointerTo_ns1__StopRecordedPatternResponse(soap, NULL, NULL, "ns1:StopRecordedPatternResponse");
	case SOAP_TYPE_PointerTo_ns1__StopRecordedPattern:
		return soap_in_PointerTo_ns1__StopRecordedPattern(soap, NULL, NULL, "ns1:StopRecordedPattern");
	case SOAP_TYPE_PointerTo_ns1__PlayRecordedPatternResponse:
		return soap_in_PointerTo_ns1__PlayRecordedPatternResponse(soap, NULL, NULL, "ns1:PlayRecordedPatternResponse");
	case SOAP_TYPE_PointerTo_ns1__PlayRecordedPattern:
		return soap_in_PointerTo_ns1__PlayRecordedPattern(soap, NULL, NULL, "ns1:PlayRecordedPattern");
	case SOAP_TYPE_PointerTo_ns1__StopPatternRecordingResponse:
		return soap_in_PointerTo_ns1__StopPatternRecordingResponse(soap, NULL, NULL, "ns1:StopPatternRecordingResponse");
	case SOAP_TYPE_PointerTo_ns1__StopPatternRecording:
		return soap_in_PointerTo_ns1__StopPatternRecording(soap, NULL, NULL, "ns1:StopPatternRecording");
	case SOAP_TYPE_PointerTo_ns1__StartPatternRecordingResponse:
		return soap_in_PointerTo_ns1__StartPatternRecordingResponse(soap, NULL, NULL, "ns1:StartPatternRecordingResponse");
	case SOAP_TYPE_PointerTo_ns1__StartPatternRecording:
		return soap_in_PointerTo_ns1__StartPatternRecording(soap, NULL, NULL, "ns1:StartPatternRecording");
	case SOAP_TYPE_PointerTo_ns1__StopPresetTourResponse:
		return soap_in_PointerTo_ns1__StopPresetTourResponse(soap, NULL, NULL, "ns1:StopPresetTourResponse");
	case SOAP_TYPE_PointerTo_ns1__StopPresetTour:
		return soap_in_PointerTo_ns1__StopPresetTour(soap, NULL, NULL, "ns1:StopPresetTour");
	case SOAP_TYPE_PointerTo_ns1__PlayPresetTourResponse:
		return soap_in_PointerTo_ns1__PlayPresetTourResponse(soap, NULL, NULL, "ns1:PlayPresetTourResponse");
	case SOAP_TYPE_PointerTo_ns1__PlayPresetTour:
		return soap_in_PointerTo_ns1__PlayPresetTour(soap, NULL, NULL, "ns1:PlayPresetTour");
	case SOAP_TYPE_PointerTo_ns1__SetPresetTourResponse:
		return soap_in_PointerTo_ns1__SetPresetTourResponse(soap, NULL, NULL, "ns1:SetPresetTourResponse");
	case SOAP_TYPE_PointerTo_ns1__SetPresetTour:
		return soap_in_PointerTo_ns1__SetPresetTour(soap, NULL, NULL, "ns1:SetPresetTour");
	case SOAP_TYPE_PointerTo_ns1__GetPresetTourResponse:
		return soap_in_PointerTo_ns1__GetPresetTourResponse(soap, NULL, NULL, "ns1:GetPresetTourResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPresetTour:
		return soap_in_PointerTo_ns1__GetPresetTour(soap, NULL, NULL, "ns1:GetPresetTour");
	case SOAP_TYPE_PointerTo_ns1__RemovePresetResponse:
		return soap_in_PointerTo_ns1__RemovePresetResponse(soap, NULL, NULL, "ns1:RemovePresetResponse");
	case SOAP_TYPE_PointerTo_ns1__RemovePreset:
		return soap_in_PointerTo_ns1__RemovePreset(soap, NULL, NULL, "ns1:RemovePreset");
	case SOAP_TYPE_PointerTo_ns1__GotoPresetResponse:
		return soap_in_PointerTo_ns1__GotoPresetResponse(soap, NULL, NULL, "ns1:GotoPresetResponse");
	case SOAP_TYPE_PointerTo_ns1__GotoPreset:
		return soap_in_PointerTo_ns1__GotoPreset(soap, NULL, NULL, "ns1:GotoPreset");
	case SOAP_TYPE_PointerTo_ns1__AddPresetResponse:
		return soap_in_PointerTo_ns1__AddPresetResponse(soap, NULL, NULL, "ns1:AddPresetResponse");
	case SOAP_TYPE_PointerTo_ns1__AddPreset:
		return soap_in_PointerTo_ns1__AddPreset(soap, NULL, NULL, "ns1:AddPreset");
	case SOAP_TYPE_PointerTo_ns1__GetPresetListResponse:
		return soap_in_PointerTo_ns1__GetPresetListResponse(soap, NULL, NULL, "ns1:GetPresetListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPresetList:
		return soap_in_PointerTo_ns1__GetPresetList(soap, NULL, NULL, "ns1:GetPresetList");
	case SOAP_TYPE_PointerTo_ns1__StopResponse:
		return soap_in_PointerTo_ns1__StopResponse(soap, NULL, NULL, "ns1:StopResponse");
	case SOAP_TYPE_PointerTo_ns1__Stop:
		return soap_in_PointerTo_ns1__Stop(soap, NULL, NULL, "ns1:Stop");
	case SOAP_TYPE_PointerTo_ns1__ControlPTZResponse:
		return soap_in_PointerTo_ns1__ControlPTZResponse(soap, NULL, NULL, "ns1:ControlPTZResponse");
	case SOAP_TYPE_PointerTo_ns1__ControlPTZ:
		return soap_in_PointerTo_ns1__ControlPTZ(soap, NULL, NULL, "ns1:ControlPTZ");
	case SOAP_TYPE_PointerTo_ns1__GetPTZCommandListResponse:
		return soap_in_PointerTo_ns1__GetPTZCommandListResponse(soap, NULL, NULL, "ns1:GetPTZCommandListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPTZCommandList:
		return soap_in_PointerTo_ns1__GetPTZCommandList(soap, NULL, NULL, "ns1:GetPTZCommandList");
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocolInfoResponse:
		return soap_in_PointerTo_ns1__GetPTZProtocolInfoResponse(soap, NULL, NULL, "ns1:GetPTZProtocolInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocolInfo:
		return soap_in_PointerTo_ns1__GetPTZProtocolInfo(soap, NULL, NULL, "ns1:GetPTZProtocolInfo");
	case SOAP_TYPE_PointerTo_ns1__RemovePTZProtocolResponse:
		return soap_in_PointerTo_ns1__RemovePTZProtocolResponse(soap, NULL, NULL, "ns1:RemovePTZProtocolResponse");
	case SOAP_TYPE_PointerTo_ns1__RemovePTZProtocol:
		return soap_in_PointerTo_ns1__RemovePTZProtocol(soap, NULL, NULL, "ns1:RemovePTZProtocol");
	case SOAP_TYPE_PointerTo_ns1__AddPTZProtocolResponse:
		return soap_in_PointerTo_ns1__AddPTZProtocolResponse(soap, NULL, NULL, "ns1:AddPTZProtocolResponse");
	case SOAP_TYPE_PointerTo_ns1__AddPTZProtocol:
		return soap_in_PointerTo_ns1__AddPTZProtocol(soap, NULL, NULL, "ns1:AddPTZProtocol");
	case SOAP_TYPE_PointerTo_ns1__SetPTZProtocolResponse:
		return soap_in_PointerTo_ns1__SetPTZProtocolResponse(soap, NULL, NULL, "ns1:SetPTZProtocolResponse");
	case SOAP_TYPE_PointerTo_ns1__SetPTZProtocol:
		return soap_in_PointerTo_ns1__SetPTZProtocol(soap, NULL, NULL, "ns1:SetPTZProtocol");
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocolResponse:
		return soap_in_PointerTo_ns1__GetPTZProtocolResponse(soap, NULL, NULL, "ns1:GetPTZProtocolResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocol:
		return soap_in_PointerTo_ns1__GetPTZProtocol(soap, NULL, NULL, "ns1:GetPTZProtocol");
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocolListResponse:
		return soap_in_PointerTo_ns1__GetPTZProtocolListResponse(soap, NULL, NULL, "ns1:GetPTZProtocolListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocolList:
		return soap_in_PointerTo_ns1__GetPTZProtocolList(soap, NULL, NULL, "ns1:GetPTZProtocolList");
	case SOAP_TYPE_PointerTons1__PortConfig_USCORET:
		return soap_in_PointerTons1__PortConfig_USCORET(soap, NULL, NULL, "ns1:PortConfig_T");
	case SOAP_TYPE_PointerTons1__ArrayOfPreset_USCORET:
		return soap_in_PointerTons1__ArrayOfPreset_USCORET(soap, NULL, NULL, "ns1:ArrayOfPreset_T");
	case SOAP_TYPE_PointerTons1__ArrayOfParameter_USCORET:
		return soap_in_PointerTons1__ArrayOfParameter_USCORET(soap, NULL, NULL, "ns1:ArrayOfParameter_T");
	case SOAP_TYPE_PointerTons1__PTZProtocol_USCORET:
		return soap_in_PointerTons1__PTZProtocol_USCORET(soap, NULL, NULL, "ns1:PTZProtocol_T");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_in_PointerTons1__ArrayOfString(soap, NULL, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerToPointerTons1__Preset_USCORET:
		return soap_in_PointerToPointerTons1__Preset_USCORET(soap, NULL, NULL, "ns1:Preset_T");
	case SOAP_TYPE_PointerTons1__Preset_USCORET:
		return soap_in_PointerTons1__Preset_USCORET(soap, NULL, NULL, "ns1:Preset_T");
	case SOAP_TYPE_PointerToPointerTons1__Parameter_USCORET:
		return soap_in_PointerToPointerTons1__Parameter_USCORET(soap, NULL, NULL, "ns1:Parameter_T");
	case SOAP_TYPE_PointerTons1__Parameter_USCORET:
		return soap_in_PointerTons1__Parameter_USCORET(soap, NULL, NULL, "ns1:Parameter_T");
	case SOAP_TYPE_PointerTons1__IntRange_USCORET:
		return soap_in_PointerTons1__IntRange_USCORET(soap, NULL, NULL, "ns1:IntRange_T");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:PortConfig_T"))
		{	*type = SOAP_TYPE_ns1__PortConfig_USCORET;
			return soap_in_ns1__PortConfig_USCORET(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Preset_T"))
		{	*type = SOAP_TYPE_ns1__Preset_USCORET;
			return soap_in_ns1__Preset_USCORET(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfPreset_T"))
		{	*type = SOAP_TYPE_ns1__ArrayOfPreset_USCORET;
			return soap_in_ns1__ArrayOfPreset_USCORET(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Parameter_T"))
		{	*type = SOAP_TYPE_ns1__Parameter_USCORET;
			return soap_in_ns1__Parameter_USCORET(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfParameter_T"))
		{	*type = SOAP_TYPE_ns1__ArrayOfParameter_USCORET;
			return soap_in_ns1__ArrayOfParameter_USCORET(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:IntRange_T"))
		{	*type = SOAP_TYPE_ns1__IntRange_USCORET;
			return soap_in_ns1__IntRange_USCORET(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PTZProtocol_T"))
		{	*type = SOAP_TYPE_ns1__PTZProtocol_USCORET;
			return soap_in_ns1__PTZProtocol_USCORET(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfString"))
		{	*type = SOAP_TYPE_ns1__ArrayOfString;
			return soap_in_ns1__ArrayOfString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OSD_MENU_T"))
		{	*type = SOAP_TYPE_ns1__OSD_USCOREMENU_USCORET;
			return soap_in_ns1__OSD_USCOREMENU_USCORET(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PARITY_T"))
		{	*type = SOAP_TYPE_ns1__PARITY_USCORET;
			return soap_in_ns1__PARITY_USCORET(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:OSDMenuResponse"))
		{	*type = SOAP_TYPE__ns1__OSDMenuResponse;
			return soap_in__ns1__OSDMenuResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OSDMenu"))
		{	*type = SOAP_TYPE__ns1__OSDMenu;
			return soap_in__ns1__OSDMenu(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PTZByPassResponse"))
		{	*type = SOAP_TYPE__ns1__PTZByPassResponse;
			return soap_in__ns1__PTZByPassResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PTZByPass"))
		{	*type = SOAP_TYPE__ns1__PTZByPass;
			return soap_in__ns1__PTZByPass(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetPTZPortResponse"))
		{	*type = SOAP_TYPE__ns1__SetPTZPortResponse;
			return soap_in__ns1__SetPTZPortResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetPTZPort"))
		{	*type = SOAP_TYPE__ns1__SetPTZPort;
			return soap_in__ns1__SetPTZPort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPTZPortResponse"))
		{	*type = SOAP_TYPE__ns1__GetPTZPortResponse;
			return soap_in__ns1__GetPTZPortResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPTZPort"))
		{	*type = SOAP_TYPE__ns1__GetPTZPort;
			return soap_in__ns1__GetPTZPort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetPTZConfigurationResponse"))
		{	*type = SOAP_TYPE__ns1__SetPTZConfigurationResponse;
			return soap_in__ns1__SetPTZConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetPTZConfiguration"))
		{	*type = SOAP_TYPE__ns1__SetPTZConfiguration;
			return soap_in__ns1__SetPTZConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPTZConfigurationResponse"))
		{	*type = SOAP_TYPE__ns1__GetPTZConfigurationResponse;
			return soap_in__ns1__GetPTZConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPTZConfiguration"))
		{	*type = SOAP_TYPE__ns1__GetPTZConfiguration;
			return soap_in__ns1__GetPTZConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopRecordedPatternResponse"))
		{	*type = SOAP_TYPE__ns1__StopRecordedPatternResponse;
			return soap_in__ns1__StopRecordedPatternResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopRecordedPattern"))
		{	*type = SOAP_TYPE__ns1__StopRecordedPattern;
			return soap_in__ns1__StopRecordedPattern(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PlayRecordedPatternResponse"))
		{	*type = SOAP_TYPE__ns1__PlayRecordedPatternResponse;
			return soap_in__ns1__PlayRecordedPatternResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PlayRecordedPattern"))
		{	*type = SOAP_TYPE__ns1__PlayRecordedPattern;
			return soap_in__ns1__PlayRecordedPattern(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopPatternRecordingResponse"))
		{	*type = SOAP_TYPE__ns1__StopPatternRecordingResponse;
			return soap_in__ns1__StopPatternRecordingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopPatternRecording"))
		{	*type = SOAP_TYPE__ns1__StopPatternRecording;
			return soap_in__ns1__StopPatternRecording(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StartPatternRecordingResponse"))
		{	*type = SOAP_TYPE__ns1__StartPatternRecordingResponse;
			return soap_in__ns1__StartPatternRecordingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StartPatternRecording"))
		{	*type = SOAP_TYPE__ns1__StartPatternRecording;
			return soap_in__ns1__StartPatternRecording(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopPresetTourResponse"))
		{	*type = SOAP_TYPE__ns1__StopPresetTourResponse;
			return soap_in__ns1__StopPresetTourResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopPresetTour"))
		{	*type = SOAP_TYPE__ns1__StopPresetTour;
			return soap_in__ns1__StopPresetTour(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PlayPresetTourResponse"))
		{	*type = SOAP_TYPE__ns1__PlayPresetTourResponse;
			return soap_in__ns1__PlayPresetTourResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PlayPresetTour"))
		{	*type = SOAP_TYPE__ns1__PlayPresetTour;
			return soap_in__ns1__PlayPresetTour(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetPresetTourResponse"))
		{	*type = SOAP_TYPE__ns1__SetPresetTourResponse;
			return soap_in__ns1__SetPresetTourResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetPresetTour"))
		{	*type = SOAP_TYPE__ns1__SetPresetTour;
			return soap_in__ns1__SetPresetTour(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPresetTourResponse"))
		{	*type = SOAP_TYPE__ns1__GetPresetTourResponse;
			return soap_in__ns1__GetPresetTourResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPresetTour"))
		{	*type = SOAP_TYPE__ns1__GetPresetTour;
			return soap_in__ns1__GetPresetTour(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemovePresetResponse"))
		{	*type = SOAP_TYPE__ns1__RemovePresetResponse;
			return soap_in__ns1__RemovePresetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemovePreset"))
		{	*type = SOAP_TYPE__ns1__RemovePreset;
			return soap_in__ns1__RemovePreset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GotoPresetResponse"))
		{	*type = SOAP_TYPE__ns1__GotoPresetResponse;
			return soap_in__ns1__GotoPresetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GotoPreset"))
		{	*type = SOAP_TYPE__ns1__GotoPreset;
			return soap_in__ns1__GotoPreset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddPresetResponse"))
		{	*type = SOAP_TYPE__ns1__AddPresetResponse;
			return soap_in__ns1__AddPresetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddPreset"))
		{	*type = SOAP_TYPE__ns1__AddPreset;
			return soap_in__ns1__AddPreset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPresetListResponse"))
		{	*type = SOAP_TYPE__ns1__GetPresetListResponse;
			return soap_in__ns1__GetPresetListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPresetList"))
		{	*type = SOAP_TYPE__ns1__GetPresetList;
			return soap_in__ns1__GetPresetList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopResponse"))
		{	*type = SOAP_TYPE__ns1__StopResponse;
			return soap_in__ns1__StopResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Stop"))
		{	*type = SOAP_TYPE__ns1__Stop;
			return soap_in__ns1__Stop(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ControlPTZResponse"))
		{	*type = SOAP_TYPE__ns1__ControlPTZResponse;
			return soap_in__ns1__ControlPTZResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ControlPTZ"))
		{	*type = SOAP_TYPE__ns1__ControlPTZ;
			return soap_in__ns1__ControlPTZ(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPTZCommandListResponse"))
		{	*type = SOAP_TYPE__ns1__GetPTZCommandListResponse;
			return soap_in__ns1__GetPTZCommandListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPTZCommandList"))
		{	*type = SOAP_TYPE__ns1__GetPTZCommandList;
			return soap_in__ns1__GetPTZCommandList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPTZProtocolInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetPTZProtocolInfoResponse;
			return soap_in__ns1__GetPTZProtocolInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPTZProtocolInfo"))
		{	*type = SOAP_TYPE__ns1__GetPTZProtocolInfo;
			return soap_in__ns1__GetPTZProtocolInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemovePTZProtocolResponse"))
		{	*type = SOAP_TYPE__ns1__RemovePTZProtocolResponse;
			return soap_in__ns1__RemovePTZProtocolResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemovePTZProtocol"))
		{	*type = SOAP_TYPE__ns1__RemovePTZProtocol;
			return soap_in__ns1__RemovePTZProtocol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddPTZProtocolResponse"))
		{	*type = SOAP_TYPE__ns1__AddPTZProtocolResponse;
			return soap_in__ns1__AddPTZProtocolResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddPTZProtocol"))
		{	*type = SOAP_TYPE__ns1__AddPTZProtocol;
			return soap_in__ns1__AddPTZProtocol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetPTZProtocolResponse"))
		{	*type = SOAP_TYPE__ns1__SetPTZProtocolResponse;
			return soap_in__ns1__SetPTZProtocolResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetPTZProtocol"))
		{	*type = SOAP_TYPE__ns1__SetPTZProtocol;
			return soap_in__ns1__SetPTZProtocol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPTZProtocolResponse"))
		{	*type = SOAP_TYPE__ns1__GetPTZProtocolResponse;
			return soap_in__ns1__GetPTZProtocolResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPTZProtocol"))
		{	*type = SOAP_TYPE__ns1__GetPTZProtocol;
			return soap_in__ns1__GetPTZProtocol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPTZProtocolListResponse"))
		{	*type = SOAP_TYPE__ns1__GetPTZProtocolListResponse;
			return soap_in__ns1__GetPTZProtocolListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPTZProtocolList"))
		{	*type = SOAP_TYPE__ns1__GetPTZProtocolList;
			return soap_in__ns1__GetPTZProtocolList(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__OSD_USCOREMENU_USCORET:
		return soap_out_ns1__OSD_USCOREMENU_USCORET(soap, tag, id, (const enum ns1__OSD_USCOREMENU_USCORET *)ptr, "ns1:OSD_MENU_T");
	case SOAP_TYPE_ns1__PARITY_USCORET:
		return soap_out_ns1__PARITY_USCORET(soap, tag, id, (const enum ns1__PARITY_USCORET *)ptr, "ns1:PARITY_T");
	case SOAP_TYPE__ns1__OSDMenuResponse:
		return ((_ns1__OSDMenuResponse *)ptr)->soap_out(soap, "ns1:OSDMenuResponse", id, NULL);
	case SOAP_TYPE__ns1__OSDMenu:
		return ((_ns1__OSDMenu *)ptr)->soap_out(soap, "ns1:OSDMenu", id, NULL);
	case SOAP_TYPE__ns1__PTZByPassResponse:
		return ((_ns1__PTZByPassResponse *)ptr)->soap_out(soap, "ns1:PTZByPassResponse", id, NULL);
	case SOAP_TYPE__ns1__PTZByPass:
		return ((_ns1__PTZByPass *)ptr)->soap_out(soap, "ns1:PTZByPass", id, NULL);
	case SOAP_TYPE__ns1__SetPTZPortResponse:
		return ((_ns1__SetPTZPortResponse *)ptr)->soap_out(soap, "ns1:SetPTZPortResponse", id, NULL);
	case SOAP_TYPE__ns1__SetPTZPort:
		return ((_ns1__SetPTZPort *)ptr)->soap_out(soap, "ns1:SetPTZPort", id, NULL);
	case SOAP_TYPE__ns1__GetPTZPortResponse:
		return ((_ns1__GetPTZPortResponse *)ptr)->soap_out(soap, "ns1:GetPTZPortResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPTZPort:
		return ((_ns1__GetPTZPort *)ptr)->soap_out(soap, "ns1:GetPTZPort", id, NULL);
	case SOAP_TYPE__ns1__SetPTZConfigurationResponse:
		return ((_ns1__SetPTZConfigurationResponse *)ptr)->soap_out(soap, "ns1:SetPTZConfigurationResponse", id, NULL);
	case SOAP_TYPE__ns1__SetPTZConfiguration:
		return ((_ns1__SetPTZConfiguration *)ptr)->soap_out(soap, "ns1:SetPTZConfiguration", id, NULL);
	case SOAP_TYPE__ns1__GetPTZConfigurationResponse:
		return ((_ns1__GetPTZConfigurationResponse *)ptr)->soap_out(soap, "ns1:GetPTZConfigurationResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPTZConfiguration:
		return ((_ns1__GetPTZConfiguration *)ptr)->soap_out(soap, "ns1:GetPTZConfiguration", id, NULL);
	case SOAP_TYPE__ns1__StopRecordedPatternResponse:
		return ((_ns1__StopRecordedPatternResponse *)ptr)->soap_out(soap, "ns1:StopRecordedPatternResponse", id, NULL);
	case SOAP_TYPE__ns1__StopRecordedPattern:
		return ((_ns1__StopRecordedPattern *)ptr)->soap_out(soap, "ns1:StopRecordedPattern", id, NULL);
	case SOAP_TYPE__ns1__PlayRecordedPatternResponse:
		return ((_ns1__PlayRecordedPatternResponse *)ptr)->soap_out(soap, "ns1:PlayRecordedPatternResponse", id, NULL);
	case SOAP_TYPE__ns1__PlayRecordedPattern:
		return ((_ns1__PlayRecordedPattern *)ptr)->soap_out(soap, "ns1:PlayRecordedPattern", id, NULL);
	case SOAP_TYPE__ns1__StopPatternRecordingResponse:
		return ((_ns1__StopPatternRecordingResponse *)ptr)->soap_out(soap, "ns1:StopPatternRecordingResponse", id, NULL);
	case SOAP_TYPE__ns1__StopPatternRecording:
		return ((_ns1__StopPatternRecording *)ptr)->soap_out(soap, "ns1:StopPatternRecording", id, NULL);
	case SOAP_TYPE__ns1__StartPatternRecordingResponse:
		return ((_ns1__StartPatternRecordingResponse *)ptr)->soap_out(soap, "ns1:StartPatternRecordingResponse", id, NULL);
	case SOAP_TYPE__ns1__StartPatternRecording:
		return ((_ns1__StartPatternRecording *)ptr)->soap_out(soap, "ns1:StartPatternRecording", id, NULL);
	case SOAP_TYPE__ns1__StopPresetTourResponse:
		return ((_ns1__StopPresetTourResponse *)ptr)->soap_out(soap, "ns1:StopPresetTourResponse", id, NULL);
	case SOAP_TYPE__ns1__StopPresetTour:
		return ((_ns1__StopPresetTour *)ptr)->soap_out(soap, "ns1:StopPresetTour", id, NULL);
	case SOAP_TYPE__ns1__PlayPresetTourResponse:
		return ((_ns1__PlayPresetTourResponse *)ptr)->soap_out(soap, "ns1:PlayPresetTourResponse", id, NULL);
	case SOAP_TYPE__ns1__PlayPresetTour:
		return ((_ns1__PlayPresetTour *)ptr)->soap_out(soap, "ns1:PlayPresetTour", id, NULL);
	case SOAP_TYPE__ns1__SetPresetTourResponse:
		return ((_ns1__SetPresetTourResponse *)ptr)->soap_out(soap, "ns1:SetPresetTourResponse", id, NULL);
	case SOAP_TYPE__ns1__SetPresetTour:
		return ((_ns1__SetPresetTour *)ptr)->soap_out(soap, "ns1:SetPresetTour", id, NULL);
	case SOAP_TYPE__ns1__GetPresetTourResponse:
		return ((_ns1__GetPresetTourResponse *)ptr)->soap_out(soap, "ns1:GetPresetTourResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPresetTour:
		return ((_ns1__GetPresetTour *)ptr)->soap_out(soap, "ns1:GetPresetTour", id, NULL);
	case SOAP_TYPE__ns1__RemovePresetResponse:
		return ((_ns1__RemovePresetResponse *)ptr)->soap_out(soap, "ns1:RemovePresetResponse", id, NULL);
	case SOAP_TYPE__ns1__RemovePreset:
		return ((_ns1__RemovePreset *)ptr)->soap_out(soap, "ns1:RemovePreset", id, NULL);
	case SOAP_TYPE__ns1__GotoPresetResponse:
		return ((_ns1__GotoPresetResponse *)ptr)->soap_out(soap, "ns1:GotoPresetResponse", id, NULL);
	case SOAP_TYPE__ns1__GotoPreset:
		return ((_ns1__GotoPreset *)ptr)->soap_out(soap, "ns1:GotoPreset", id, NULL);
	case SOAP_TYPE__ns1__AddPresetResponse:
		return ((_ns1__AddPresetResponse *)ptr)->soap_out(soap, "ns1:AddPresetResponse", id, NULL);
	case SOAP_TYPE__ns1__AddPreset:
		return ((_ns1__AddPreset *)ptr)->soap_out(soap, "ns1:AddPreset", id, NULL);
	case SOAP_TYPE__ns1__GetPresetListResponse:
		return ((_ns1__GetPresetListResponse *)ptr)->soap_out(soap, "ns1:GetPresetListResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPresetList:
		return ((_ns1__GetPresetList *)ptr)->soap_out(soap, "ns1:GetPresetList", id, NULL);
	case SOAP_TYPE__ns1__StopResponse:
		return ((_ns1__StopResponse *)ptr)->soap_out(soap, "ns1:StopResponse", id, NULL);
	case SOAP_TYPE__ns1__Stop:
		return ((_ns1__Stop *)ptr)->soap_out(soap, "ns1:Stop", id, NULL);
	case SOAP_TYPE__ns1__ControlPTZResponse:
		return ((_ns1__ControlPTZResponse *)ptr)->soap_out(soap, "ns1:ControlPTZResponse", id, NULL);
	case SOAP_TYPE__ns1__ControlPTZ:
		return ((_ns1__ControlPTZ *)ptr)->soap_out(soap, "ns1:ControlPTZ", id, NULL);
	case SOAP_TYPE__ns1__GetPTZCommandListResponse:
		return ((_ns1__GetPTZCommandListResponse *)ptr)->soap_out(soap, "ns1:GetPTZCommandListResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPTZCommandList:
		return ((_ns1__GetPTZCommandList *)ptr)->soap_out(soap, "ns1:GetPTZCommandList", id, NULL);
	case SOAP_TYPE__ns1__GetPTZProtocolInfoResponse:
		return ((_ns1__GetPTZProtocolInfoResponse *)ptr)->soap_out(soap, "ns1:GetPTZProtocolInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPTZProtocolInfo:
		return ((_ns1__GetPTZProtocolInfo *)ptr)->soap_out(soap, "ns1:GetPTZProtocolInfo", id, NULL);
	case SOAP_TYPE__ns1__RemovePTZProtocolResponse:
		return ((_ns1__RemovePTZProtocolResponse *)ptr)->soap_out(soap, "ns1:RemovePTZProtocolResponse", id, NULL);
	case SOAP_TYPE__ns1__RemovePTZProtocol:
		return ((_ns1__RemovePTZProtocol *)ptr)->soap_out(soap, "ns1:RemovePTZProtocol", id, NULL);
	case SOAP_TYPE__ns1__AddPTZProtocolResponse:
		return ((_ns1__AddPTZProtocolResponse *)ptr)->soap_out(soap, "ns1:AddPTZProtocolResponse", id, NULL);
	case SOAP_TYPE__ns1__AddPTZProtocol:
		return ((_ns1__AddPTZProtocol *)ptr)->soap_out(soap, "ns1:AddPTZProtocol", id, NULL);
	case SOAP_TYPE__ns1__SetPTZProtocolResponse:
		return ((_ns1__SetPTZProtocolResponse *)ptr)->soap_out(soap, "ns1:SetPTZProtocolResponse", id, NULL);
	case SOAP_TYPE__ns1__SetPTZProtocol:
		return ((_ns1__SetPTZProtocol *)ptr)->soap_out(soap, "ns1:SetPTZProtocol", id, NULL);
	case SOAP_TYPE__ns1__GetPTZProtocolResponse:
		return ((_ns1__GetPTZProtocolResponse *)ptr)->soap_out(soap, "ns1:GetPTZProtocolResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPTZProtocol:
		return ((_ns1__GetPTZProtocol *)ptr)->soap_out(soap, "ns1:GetPTZProtocol", id, NULL);
	case SOAP_TYPE__ns1__GetPTZProtocolListResponse:
		return ((_ns1__GetPTZProtocolListResponse *)ptr)->soap_out(soap, "ns1:GetPTZProtocolListResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPTZProtocolList:
		return ((_ns1__GetPTZProtocolList *)ptr)->soap_out(soap, "ns1:GetPTZProtocolList", id, NULL);
	case SOAP_TYPE_ns1__PortConfig_USCORET:
		return ((ns1__PortConfig_USCORET *)ptr)->soap_out(soap, tag, id, "ns1:PortConfig_T");
	case SOAP_TYPE_ns1__Preset_USCORET:
		return ((ns1__Preset_USCORET *)ptr)->soap_out(soap, tag, id, "ns1:Preset_T");
	case SOAP_TYPE_ns1__ArrayOfPreset_USCORET:
		return ((ns1__ArrayOfPreset_USCORET *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfPreset_T");
	case SOAP_TYPE_ns1__Parameter_USCORET:
		return ((ns1__Parameter_USCORET *)ptr)->soap_out(soap, tag, id, "ns1:Parameter_T");
	case SOAP_TYPE_ns1__ArrayOfParameter_USCORET:
		return ((ns1__ArrayOfParameter_USCORET *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfParameter_T");
	case SOAP_TYPE_ns1__IntRange_USCORET:
		return ((ns1__IntRange_USCORET *)ptr)->soap_out(soap, tag, id, "ns1:IntRange_T");
	case SOAP_TYPE_ns1__PTZProtocol_USCORET:
		return ((ns1__PTZProtocol_USCORET *)ptr)->soap_out(soap, tag, id, "ns1:PTZProtocol_T");
	case SOAP_TYPE_ns1__ArrayOfString:
		return ((ns1__ArrayOfString *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerTo_ns1__OSDMenuResponse:
		return soap_out_PointerTo_ns1__OSDMenuResponse(soap, tag, id, (_ns1__OSDMenuResponse *const*)ptr, "ns1:OSDMenuResponse");
	case SOAP_TYPE_PointerTo_ns1__OSDMenu:
		return soap_out_PointerTo_ns1__OSDMenu(soap, tag, id, (_ns1__OSDMenu *const*)ptr, "ns1:OSDMenu");
	case SOAP_TYPE_PointerTo_ns1__PTZByPassResponse:
		return soap_out_PointerTo_ns1__PTZByPassResponse(soap, tag, id, (_ns1__PTZByPassResponse *const*)ptr, "ns1:PTZByPassResponse");
	case SOAP_TYPE_PointerTo_ns1__PTZByPass:
		return soap_out_PointerTo_ns1__PTZByPass(soap, tag, id, (_ns1__PTZByPass *const*)ptr, "ns1:PTZByPass");
	case SOAP_TYPE_PointerTo_ns1__SetPTZPortResponse:
		return soap_out_PointerTo_ns1__SetPTZPortResponse(soap, tag, id, (_ns1__SetPTZPortResponse *const*)ptr, "ns1:SetPTZPortResponse");
	case SOAP_TYPE_PointerTo_ns1__SetPTZPort:
		return soap_out_PointerTo_ns1__SetPTZPort(soap, tag, id, (_ns1__SetPTZPort *const*)ptr, "ns1:SetPTZPort");
	case SOAP_TYPE_PointerTo_ns1__GetPTZPortResponse:
		return soap_out_PointerTo_ns1__GetPTZPortResponse(soap, tag, id, (_ns1__GetPTZPortResponse *const*)ptr, "ns1:GetPTZPortResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPTZPort:
		return soap_out_PointerTo_ns1__GetPTZPort(soap, tag, id, (_ns1__GetPTZPort *const*)ptr, "ns1:GetPTZPort");
	case SOAP_TYPE_PointerTo_ns1__SetPTZConfigurationResponse:
		return soap_out_PointerTo_ns1__SetPTZConfigurationResponse(soap, tag, id, (_ns1__SetPTZConfigurationResponse *const*)ptr, "ns1:SetPTZConfigurationResponse");
	case SOAP_TYPE_PointerTo_ns1__SetPTZConfiguration:
		return soap_out_PointerTo_ns1__SetPTZConfiguration(soap, tag, id, (_ns1__SetPTZConfiguration *const*)ptr, "ns1:SetPTZConfiguration");
	case SOAP_TYPE_PointerTo_ns1__GetPTZConfigurationResponse:
		return soap_out_PointerTo_ns1__GetPTZConfigurationResponse(soap, tag, id, (_ns1__GetPTZConfigurationResponse *const*)ptr, "ns1:GetPTZConfigurationResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPTZConfiguration:
		return soap_out_PointerTo_ns1__GetPTZConfiguration(soap, tag, id, (_ns1__GetPTZConfiguration *const*)ptr, "ns1:GetPTZConfiguration");
	case SOAP_TYPE_PointerTo_ns1__StopRecordedPatternResponse:
		return soap_out_PointerTo_ns1__StopRecordedPatternResponse(soap, tag, id, (_ns1__StopRecordedPatternResponse *const*)ptr, "ns1:StopRecordedPatternResponse");
	case SOAP_TYPE_PointerTo_ns1__StopRecordedPattern:
		return soap_out_PointerTo_ns1__StopRecordedPattern(soap, tag, id, (_ns1__StopRecordedPattern *const*)ptr, "ns1:StopRecordedPattern");
	case SOAP_TYPE_PointerTo_ns1__PlayRecordedPatternResponse:
		return soap_out_PointerTo_ns1__PlayRecordedPatternResponse(soap, tag, id, (_ns1__PlayRecordedPatternResponse *const*)ptr, "ns1:PlayRecordedPatternResponse");
	case SOAP_TYPE_PointerTo_ns1__PlayRecordedPattern:
		return soap_out_PointerTo_ns1__PlayRecordedPattern(soap, tag, id, (_ns1__PlayRecordedPattern *const*)ptr, "ns1:PlayRecordedPattern");
	case SOAP_TYPE_PointerTo_ns1__StopPatternRecordingResponse:
		return soap_out_PointerTo_ns1__StopPatternRecordingResponse(soap, tag, id, (_ns1__StopPatternRecordingResponse *const*)ptr, "ns1:StopPatternRecordingResponse");
	case SOAP_TYPE_PointerTo_ns1__StopPatternRecording:
		return soap_out_PointerTo_ns1__StopPatternRecording(soap, tag, id, (_ns1__StopPatternRecording *const*)ptr, "ns1:StopPatternRecording");
	case SOAP_TYPE_PointerTo_ns1__StartPatternRecordingResponse:
		return soap_out_PointerTo_ns1__StartPatternRecordingResponse(soap, tag, id, (_ns1__StartPatternRecordingResponse *const*)ptr, "ns1:StartPatternRecordingResponse");
	case SOAP_TYPE_PointerTo_ns1__StartPatternRecording:
		return soap_out_PointerTo_ns1__StartPatternRecording(soap, tag, id, (_ns1__StartPatternRecording *const*)ptr, "ns1:StartPatternRecording");
	case SOAP_TYPE_PointerTo_ns1__StopPresetTourResponse:
		return soap_out_PointerTo_ns1__StopPresetTourResponse(soap, tag, id, (_ns1__StopPresetTourResponse *const*)ptr, "ns1:StopPresetTourResponse");
	case SOAP_TYPE_PointerTo_ns1__StopPresetTour:
		return soap_out_PointerTo_ns1__StopPresetTour(soap, tag, id, (_ns1__StopPresetTour *const*)ptr, "ns1:StopPresetTour");
	case SOAP_TYPE_PointerTo_ns1__PlayPresetTourResponse:
		return soap_out_PointerTo_ns1__PlayPresetTourResponse(soap, tag, id, (_ns1__PlayPresetTourResponse *const*)ptr, "ns1:PlayPresetTourResponse");
	case SOAP_TYPE_PointerTo_ns1__PlayPresetTour:
		return soap_out_PointerTo_ns1__PlayPresetTour(soap, tag, id, (_ns1__PlayPresetTour *const*)ptr, "ns1:PlayPresetTour");
	case SOAP_TYPE_PointerTo_ns1__SetPresetTourResponse:
		return soap_out_PointerTo_ns1__SetPresetTourResponse(soap, tag, id, (_ns1__SetPresetTourResponse *const*)ptr, "ns1:SetPresetTourResponse");
	case SOAP_TYPE_PointerTo_ns1__SetPresetTour:
		return soap_out_PointerTo_ns1__SetPresetTour(soap, tag, id, (_ns1__SetPresetTour *const*)ptr, "ns1:SetPresetTour");
	case SOAP_TYPE_PointerTo_ns1__GetPresetTourResponse:
		return soap_out_PointerTo_ns1__GetPresetTourResponse(soap, tag, id, (_ns1__GetPresetTourResponse *const*)ptr, "ns1:GetPresetTourResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPresetTour:
		return soap_out_PointerTo_ns1__GetPresetTour(soap, tag, id, (_ns1__GetPresetTour *const*)ptr, "ns1:GetPresetTour");
	case SOAP_TYPE_PointerTo_ns1__RemovePresetResponse:
		return soap_out_PointerTo_ns1__RemovePresetResponse(soap, tag, id, (_ns1__RemovePresetResponse *const*)ptr, "ns1:RemovePresetResponse");
	case SOAP_TYPE_PointerTo_ns1__RemovePreset:
		return soap_out_PointerTo_ns1__RemovePreset(soap, tag, id, (_ns1__RemovePreset *const*)ptr, "ns1:RemovePreset");
	case SOAP_TYPE_PointerTo_ns1__GotoPresetResponse:
		return soap_out_PointerTo_ns1__GotoPresetResponse(soap, tag, id, (_ns1__GotoPresetResponse *const*)ptr, "ns1:GotoPresetResponse");
	case SOAP_TYPE_PointerTo_ns1__GotoPreset:
		return soap_out_PointerTo_ns1__GotoPreset(soap, tag, id, (_ns1__GotoPreset *const*)ptr, "ns1:GotoPreset");
	case SOAP_TYPE_PointerTo_ns1__AddPresetResponse:
		return soap_out_PointerTo_ns1__AddPresetResponse(soap, tag, id, (_ns1__AddPresetResponse *const*)ptr, "ns1:AddPresetResponse");
	case SOAP_TYPE_PointerTo_ns1__AddPreset:
		return soap_out_PointerTo_ns1__AddPreset(soap, tag, id, (_ns1__AddPreset *const*)ptr, "ns1:AddPreset");
	case SOAP_TYPE_PointerTo_ns1__GetPresetListResponse:
		return soap_out_PointerTo_ns1__GetPresetListResponse(soap, tag, id, (_ns1__GetPresetListResponse *const*)ptr, "ns1:GetPresetListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPresetList:
		return soap_out_PointerTo_ns1__GetPresetList(soap, tag, id, (_ns1__GetPresetList *const*)ptr, "ns1:GetPresetList");
	case SOAP_TYPE_PointerTo_ns1__StopResponse:
		return soap_out_PointerTo_ns1__StopResponse(soap, tag, id, (_ns1__StopResponse *const*)ptr, "ns1:StopResponse");
	case SOAP_TYPE_PointerTo_ns1__Stop:
		return soap_out_PointerTo_ns1__Stop(soap, tag, id, (_ns1__Stop *const*)ptr, "ns1:Stop");
	case SOAP_TYPE_PointerTo_ns1__ControlPTZResponse:
		return soap_out_PointerTo_ns1__ControlPTZResponse(soap, tag, id, (_ns1__ControlPTZResponse *const*)ptr, "ns1:ControlPTZResponse");
	case SOAP_TYPE_PointerTo_ns1__ControlPTZ:
		return soap_out_PointerTo_ns1__ControlPTZ(soap, tag, id, (_ns1__ControlPTZ *const*)ptr, "ns1:ControlPTZ");
	case SOAP_TYPE_PointerTo_ns1__GetPTZCommandListResponse:
		return soap_out_PointerTo_ns1__GetPTZCommandListResponse(soap, tag, id, (_ns1__GetPTZCommandListResponse *const*)ptr, "ns1:GetPTZCommandListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPTZCommandList:
		return soap_out_PointerTo_ns1__GetPTZCommandList(soap, tag, id, (_ns1__GetPTZCommandList *const*)ptr, "ns1:GetPTZCommandList");
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocolInfoResponse:
		return soap_out_PointerTo_ns1__GetPTZProtocolInfoResponse(soap, tag, id, (_ns1__GetPTZProtocolInfoResponse *const*)ptr, "ns1:GetPTZProtocolInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocolInfo:
		return soap_out_PointerTo_ns1__GetPTZProtocolInfo(soap, tag, id, (_ns1__GetPTZProtocolInfo *const*)ptr, "ns1:GetPTZProtocolInfo");
	case SOAP_TYPE_PointerTo_ns1__RemovePTZProtocolResponse:
		return soap_out_PointerTo_ns1__RemovePTZProtocolResponse(soap, tag, id, (_ns1__RemovePTZProtocolResponse *const*)ptr, "ns1:RemovePTZProtocolResponse");
	case SOAP_TYPE_PointerTo_ns1__RemovePTZProtocol:
		return soap_out_PointerTo_ns1__RemovePTZProtocol(soap, tag, id, (_ns1__RemovePTZProtocol *const*)ptr, "ns1:RemovePTZProtocol");
	case SOAP_TYPE_PointerTo_ns1__AddPTZProtocolResponse:
		return soap_out_PointerTo_ns1__AddPTZProtocolResponse(soap, tag, id, (_ns1__AddPTZProtocolResponse *const*)ptr, "ns1:AddPTZProtocolResponse");
	case SOAP_TYPE_PointerTo_ns1__AddPTZProtocol:
		return soap_out_PointerTo_ns1__AddPTZProtocol(soap, tag, id, (_ns1__AddPTZProtocol *const*)ptr, "ns1:AddPTZProtocol");
	case SOAP_TYPE_PointerTo_ns1__SetPTZProtocolResponse:
		return soap_out_PointerTo_ns1__SetPTZProtocolResponse(soap, tag, id, (_ns1__SetPTZProtocolResponse *const*)ptr, "ns1:SetPTZProtocolResponse");
	case SOAP_TYPE_PointerTo_ns1__SetPTZProtocol:
		return soap_out_PointerTo_ns1__SetPTZProtocol(soap, tag, id, (_ns1__SetPTZProtocol *const*)ptr, "ns1:SetPTZProtocol");
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocolResponse:
		return soap_out_PointerTo_ns1__GetPTZProtocolResponse(soap, tag, id, (_ns1__GetPTZProtocolResponse *const*)ptr, "ns1:GetPTZProtocolResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocol:
		return soap_out_PointerTo_ns1__GetPTZProtocol(soap, tag, id, (_ns1__GetPTZProtocol *const*)ptr, "ns1:GetPTZProtocol");
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocolListResponse:
		return soap_out_PointerTo_ns1__GetPTZProtocolListResponse(soap, tag, id, (_ns1__GetPTZProtocolListResponse *const*)ptr, "ns1:GetPTZProtocolListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocolList:
		return soap_out_PointerTo_ns1__GetPTZProtocolList(soap, tag, id, (_ns1__GetPTZProtocolList *const*)ptr, "ns1:GetPTZProtocolList");
	case SOAP_TYPE_PointerTons1__PortConfig_USCORET:
		return soap_out_PointerTons1__PortConfig_USCORET(soap, tag, id, (ns1__PortConfig_USCORET *const*)ptr, "ns1:PortConfig_T");
	case SOAP_TYPE_PointerTons1__ArrayOfPreset_USCORET:
		return soap_out_PointerTons1__ArrayOfPreset_USCORET(soap, tag, id, (ns1__ArrayOfPreset_USCORET *const*)ptr, "ns1:ArrayOfPreset_T");
	case SOAP_TYPE_PointerTons1__ArrayOfParameter_USCORET:
		return soap_out_PointerTons1__ArrayOfParameter_USCORET(soap, tag, id, (ns1__ArrayOfParameter_USCORET *const*)ptr, "ns1:ArrayOfParameter_T");
	case SOAP_TYPE_PointerTons1__PTZProtocol_USCORET:
		return soap_out_PointerTons1__PTZProtocol_USCORET(soap, tag, id, (ns1__PTZProtocol_USCORET *const*)ptr, "ns1:PTZProtocol_T");
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		return soap_out_PointerTons1__ArrayOfString(soap, tag, id, (ns1__ArrayOfString *const*)ptr, "ns1:ArrayOfString");
	case SOAP_TYPE_PointerToPointerTons1__Preset_USCORET:
		return soap_out_PointerToPointerTons1__Preset_USCORET(soap, tag, id, (ns1__Preset_USCORET **const*)ptr, "ns1:Preset_T");
	case SOAP_TYPE_PointerTons1__Preset_USCORET:
		return soap_out_PointerTons1__Preset_USCORET(soap, tag, id, (ns1__Preset_USCORET *const*)ptr, "ns1:Preset_T");
	case SOAP_TYPE_PointerToPointerTons1__Parameter_USCORET:
		return soap_out_PointerToPointerTons1__Parameter_USCORET(soap, tag, id, (ns1__Parameter_USCORET **const*)ptr, "ns1:Parameter_T");
	case SOAP_TYPE_PointerTons1__Parameter_USCORET:
		return soap_out_PointerTons1__Parameter_USCORET(soap, tag, id, (ns1__Parameter_USCORET *const*)ptr, "ns1:Parameter_T");
	case SOAP_TYPE_PointerTons1__IntRange_USCORET:
		return soap_out_PointerTons1__IntRange_USCORET(soap, tag, id, (ns1__IntRange_USCORET *const*)ptr, "ns1:IntRange_T");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__OSDMenuResponse:
		((_ns1__OSDMenuResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OSDMenu:
		((_ns1__OSDMenu *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PTZByPassResponse:
		((_ns1__PTZByPassResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PTZByPass:
		((_ns1__PTZByPass *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetPTZPortResponse:
		((_ns1__SetPTZPortResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetPTZPort:
		((_ns1__SetPTZPort *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPTZPortResponse:
		((_ns1__GetPTZPortResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPTZPort:
		((_ns1__GetPTZPort *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetPTZConfigurationResponse:
		((_ns1__SetPTZConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetPTZConfiguration:
		((_ns1__SetPTZConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPTZConfigurationResponse:
		((_ns1__GetPTZConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPTZConfiguration:
		((_ns1__GetPTZConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StopRecordedPatternResponse:
		((_ns1__StopRecordedPatternResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StopRecordedPattern:
		((_ns1__StopRecordedPattern *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PlayRecordedPatternResponse:
		((_ns1__PlayRecordedPatternResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PlayRecordedPattern:
		((_ns1__PlayRecordedPattern *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StopPatternRecordingResponse:
		((_ns1__StopPatternRecordingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StopPatternRecording:
		((_ns1__StopPatternRecording *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StartPatternRecordingResponse:
		((_ns1__StartPatternRecordingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StartPatternRecording:
		((_ns1__StartPatternRecording *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StopPresetTourResponse:
		((_ns1__StopPresetTourResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StopPresetTour:
		((_ns1__StopPresetTour *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PlayPresetTourResponse:
		((_ns1__PlayPresetTourResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PlayPresetTour:
		((_ns1__PlayPresetTour *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetPresetTourResponse:
		((_ns1__SetPresetTourResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetPresetTour:
		((_ns1__SetPresetTour *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPresetTourResponse:
		((_ns1__GetPresetTourResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPresetTour:
		((_ns1__GetPresetTour *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemovePresetResponse:
		((_ns1__RemovePresetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemovePreset:
		((_ns1__RemovePreset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GotoPresetResponse:
		((_ns1__GotoPresetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GotoPreset:
		((_ns1__GotoPreset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddPresetResponse:
		((_ns1__AddPresetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddPreset:
		((_ns1__AddPreset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPresetListResponse:
		((_ns1__GetPresetListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPresetList:
		((_ns1__GetPresetList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StopResponse:
		((_ns1__StopResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Stop:
		((_ns1__Stop *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ControlPTZResponse:
		((_ns1__ControlPTZResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ControlPTZ:
		((_ns1__ControlPTZ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPTZCommandListResponse:
		((_ns1__GetPTZCommandListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPTZCommandList:
		((_ns1__GetPTZCommandList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPTZProtocolInfoResponse:
		((_ns1__GetPTZProtocolInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPTZProtocolInfo:
		((_ns1__GetPTZProtocolInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemovePTZProtocolResponse:
		((_ns1__RemovePTZProtocolResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemovePTZProtocol:
		((_ns1__RemovePTZProtocol *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddPTZProtocolResponse:
		((_ns1__AddPTZProtocolResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddPTZProtocol:
		((_ns1__AddPTZProtocol *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetPTZProtocolResponse:
		((_ns1__SetPTZProtocolResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetPTZProtocol:
		((_ns1__SetPTZProtocol *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPTZProtocolResponse:
		((_ns1__GetPTZProtocolResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPTZProtocol:
		((_ns1__GetPTZProtocol *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPTZProtocolListResponse:
		((_ns1__GetPTZProtocolListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPTZProtocolList:
		((_ns1__GetPTZProtocolList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PortConfig_USCORET:
		((ns1__PortConfig_USCORET *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Preset_USCORET:
		((ns1__Preset_USCORET *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfPreset_USCORET:
		((ns1__ArrayOfPreset_USCORET *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Parameter_USCORET:
		((ns1__Parameter_USCORET *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfParameter_USCORET:
		((ns1__ArrayOfParameter_USCORET *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__IntRange_USCORET:
		((ns1__IntRange_USCORET *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PTZProtocol_USCORET:
		((ns1__PTZProtocol_USCORET *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		((ns1__ArrayOfString *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns3__OSDMenu:
		soap_serialize___ns3__OSDMenu(soap, (const struct __ns3__OSDMenu *)ptr);
		break;
	case SOAP_TYPE___ns3__PTZByPass:
		soap_serialize___ns3__PTZByPass(soap, (const struct __ns3__PTZByPass *)ptr);
		break;
	case SOAP_TYPE___ns3__SetPTZPort:
		soap_serialize___ns3__SetPTZPort(soap, (const struct __ns3__SetPTZPort *)ptr);
		break;
	case SOAP_TYPE___ns3__GetPTZPort:
		soap_serialize___ns3__GetPTZPort(soap, (const struct __ns3__GetPTZPort *)ptr);
		break;
	case SOAP_TYPE___ns3__SetPTZConfiguration:
		soap_serialize___ns3__SetPTZConfiguration(soap, (const struct __ns3__SetPTZConfiguration *)ptr);
		break;
	case SOAP_TYPE___ns3__GetPTZConfiguration:
		soap_serialize___ns3__GetPTZConfiguration(soap, (const struct __ns3__GetPTZConfiguration *)ptr);
		break;
	case SOAP_TYPE___ns3__StopRecordedPattern:
		soap_serialize___ns3__StopRecordedPattern(soap, (const struct __ns3__StopRecordedPattern *)ptr);
		break;
	case SOAP_TYPE___ns3__PlayRecordedPattern:
		soap_serialize___ns3__PlayRecordedPattern(soap, (const struct __ns3__PlayRecordedPattern *)ptr);
		break;
	case SOAP_TYPE___ns3__StopPatternRecording:
		soap_serialize___ns3__StopPatternRecording(soap, (const struct __ns3__StopPatternRecording *)ptr);
		break;
	case SOAP_TYPE___ns3__StartPatternRecording:
		soap_serialize___ns3__StartPatternRecording(soap, (const struct __ns3__StartPatternRecording *)ptr);
		break;
	case SOAP_TYPE___ns3__StopPresetTour:
		soap_serialize___ns3__StopPresetTour(soap, (const struct __ns3__StopPresetTour *)ptr);
		break;
	case SOAP_TYPE___ns3__PlayPresetTour:
		soap_serialize___ns3__PlayPresetTour(soap, (const struct __ns3__PlayPresetTour *)ptr);
		break;
	case SOAP_TYPE___ns3__SetPresetTour:
		soap_serialize___ns3__SetPresetTour(soap, (const struct __ns3__SetPresetTour *)ptr);
		break;
	case SOAP_TYPE___ns3__GetPresetTour:
		soap_serialize___ns3__GetPresetTour(soap, (const struct __ns3__GetPresetTour *)ptr);
		break;
	case SOAP_TYPE___ns3__RemovePreset:
		soap_serialize___ns3__RemovePreset(soap, (const struct __ns3__RemovePreset *)ptr);
		break;
	case SOAP_TYPE___ns3__GotoPreset:
		soap_serialize___ns3__GotoPreset(soap, (const struct __ns3__GotoPreset *)ptr);
		break;
	case SOAP_TYPE___ns3__AddPreset:
		soap_serialize___ns3__AddPreset(soap, (const struct __ns3__AddPreset *)ptr);
		break;
	case SOAP_TYPE___ns3__GetPresetList:
		soap_serialize___ns3__GetPresetList(soap, (const struct __ns3__GetPresetList *)ptr);
		break;
	case SOAP_TYPE___ns3__Stop:
		soap_serialize___ns3__Stop(soap, (const struct __ns3__Stop *)ptr);
		break;
	case SOAP_TYPE___ns3__ControlPTZ:
		soap_serialize___ns3__ControlPTZ(soap, (const struct __ns3__ControlPTZ *)ptr);
		break;
	case SOAP_TYPE___ns3__GetPTZCommandList:
		soap_serialize___ns3__GetPTZCommandList(soap, (const struct __ns3__GetPTZCommandList *)ptr);
		break;
	case SOAP_TYPE___ns3__GetPTZProtocolInfo:
		soap_serialize___ns3__GetPTZProtocolInfo(soap, (const struct __ns3__GetPTZProtocolInfo *)ptr);
		break;
	case SOAP_TYPE___ns3__RemovePTZProtocol:
		soap_serialize___ns3__RemovePTZProtocol(soap, (const struct __ns3__RemovePTZProtocol *)ptr);
		break;
	case SOAP_TYPE___ns3__AddPTZProtocol:
		soap_serialize___ns3__AddPTZProtocol(soap, (const struct __ns3__AddPTZProtocol *)ptr);
		break;
	case SOAP_TYPE___ns3__SetPTZProtocol:
		soap_serialize___ns3__SetPTZProtocol(soap, (const struct __ns3__SetPTZProtocol *)ptr);
		break;
	case SOAP_TYPE___ns3__GetPTZProtocol:
		soap_serialize___ns3__GetPTZProtocol(soap, (const struct __ns3__GetPTZProtocol *)ptr);
		break;
	case SOAP_TYPE___ns3__GetPTZProtocolList:
		soap_serialize___ns3__GetPTZProtocolList(soap, (const struct __ns3__GetPTZProtocolList *)ptr);
		break;
	case SOAP_TYPE___ns2__OSDMenu:
		soap_serialize___ns2__OSDMenu(soap, (const struct __ns2__OSDMenu *)ptr);
		break;
	case SOAP_TYPE___ns2__PTZByPass:
		soap_serialize___ns2__PTZByPass(soap, (const struct __ns2__PTZByPass *)ptr);
		break;
	case SOAP_TYPE___ns2__SetPTZPort:
		soap_serialize___ns2__SetPTZPort(soap, (const struct __ns2__SetPTZPort *)ptr);
		break;
	case SOAP_TYPE___ns2__GetPTZPort:
		soap_serialize___ns2__GetPTZPort(soap, (const struct __ns2__GetPTZPort *)ptr);
		break;
	case SOAP_TYPE___ns2__SetPTZConfiguration:
		soap_serialize___ns2__SetPTZConfiguration(soap, (const struct __ns2__SetPTZConfiguration *)ptr);
		break;
	case SOAP_TYPE___ns2__GetPTZConfiguration:
		soap_serialize___ns2__GetPTZConfiguration(soap, (const struct __ns2__GetPTZConfiguration *)ptr);
		break;
	case SOAP_TYPE___ns2__StopRecordedPattern:
		soap_serialize___ns2__StopRecordedPattern(soap, (const struct __ns2__StopRecordedPattern *)ptr);
		break;
	case SOAP_TYPE___ns2__PlayRecordedPattern:
		soap_serialize___ns2__PlayRecordedPattern(soap, (const struct __ns2__PlayRecordedPattern *)ptr);
		break;
	case SOAP_TYPE___ns2__StopPatternRecording:
		soap_serialize___ns2__StopPatternRecording(soap, (const struct __ns2__StopPatternRecording *)ptr);
		break;
	case SOAP_TYPE___ns2__StartPatternRecording:
		soap_serialize___ns2__StartPatternRecording(soap, (const struct __ns2__StartPatternRecording *)ptr);
		break;
	case SOAP_TYPE___ns2__StopPresetTour:
		soap_serialize___ns2__StopPresetTour(soap, (const struct __ns2__StopPresetTour *)ptr);
		break;
	case SOAP_TYPE___ns2__PlayPresetTour:
		soap_serialize___ns2__PlayPresetTour(soap, (const struct __ns2__PlayPresetTour *)ptr);
		break;
	case SOAP_TYPE___ns2__SetPresetTour:
		soap_serialize___ns2__SetPresetTour(soap, (const struct __ns2__SetPresetTour *)ptr);
		break;
	case SOAP_TYPE___ns2__GetPresetTour:
		soap_serialize___ns2__GetPresetTour(soap, (const struct __ns2__GetPresetTour *)ptr);
		break;
	case SOAP_TYPE___ns2__RemovePreset:
		soap_serialize___ns2__RemovePreset(soap, (const struct __ns2__RemovePreset *)ptr);
		break;
	case SOAP_TYPE___ns2__GotoPreset:
		soap_serialize___ns2__GotoPreset(soap, (const struct __ns2__GotoPreset *)ptr);
		break;
	case SOAP_TYPE___ns2__AddPreset:
		soap_serialize___ns2__AddPreset(soap, (const struct __ns2__AddPreset *)ptr);
		break;
	case SOAP_TYPE___ns2__GetPresetList:
		soap_serialize___ns2__GetPresetList(soap, (const struct __ns2__GetPresetList *)ptr);
		break;
	case SOAP_TYPE___ns2__Stop:
		soap_serialize___ns2__Stop(soap, (const struct __ns2__Stop *)ptr);
		break;
	case SOAP_TYPE___ns2__ControlPTZ:
		soap_serialize___ns2__ControlPTZ(soap, (const struct __ns2__ControlPTZ *)ptr);
		break;
	case SOAP_TYPE___ns2__GetPTZCommandList:
		soap_serialize___ns2__GetPTZCommandList(soap, (const struct __ns2__GetPTZCommandList *)ptr);
		break;
	case SOAP_TYPE___ns2__GetPTZProtocolInfo:
		soap_serialize___ns2__GetPTZProtocolInfo(soap, (const struct __ns2__GetPTZProtocolInfo *)ptr);
		break;
	case SOAP_TYPE___ns2__RemovePTZProtocol:
		soap_serialize___ns2__RemovePTZProtocol(soap, (const struct __ns2__RemovePTZProtocol *)ptr);
		break;
	case SOAP_TYPE___ns2__AddPTZProtocol:
		soap_serialize___ns2__AddPTZProtocol(soap, (const struct __ns2__AddPTZProtocol *)ptr);
		break;
	case SOAP_TYPE___ns2__SetPTZProtocol:
		soap_serialize___ns2__SetPTZProtocol(soap, (const struct __ns2__SetPTZProtocol *)ptr);
		break;
	case SOAP_TYPE___ns2__GetPTZProtocol:
		soap_serialize___ns2__GetPTZProtocol(soap, (const struct __ns2__GetPTZProtocol *)ptr);
		break;
	case SOAP_TYPE___ns2__GetPTZProtocolList:
		soap_serialize___ns2__GetPTZProtocolList(soap, (const struct __ns2__GetPTZProtocolList *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OSDMenuResponse:
		soap_serialize_PointerTo_ns1__OSDMenuResponse(soap, (_ns1__OSDMenuResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OSDMenu:
		soap_serialize_PointerTo_ns1__OSDMenu(soap, (_ns1__OSDMenu *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PTZByPassResponse:
		soap_serialize_PointerTo_ns1__PTZByPassResponse(soap, (_ns1__PTZByPassResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PTZByPass:
		soap_serialize_PointerTo_ns1__PTZByPass(soap, (_ns1__PTZByPass *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetPTZPortResponse:
		soap_serialize_PointerTo_ns1__SetPTZPortResponse(soap, (_ns1__SetPTZPortResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetPTZPort:
		soap_serialize_PointerTo_ns1__SetPTZPort(soap, (_ns1__SetPTZPort *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPTZPortResponse:
		soap_serialize_PointerTo_ns1__GetPTZPortResponse(soap, (_ns1__GetPTZPortResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPTZPort:
		soap_serialize_PointerTo_ns1__GetPTZPort(soap, (_ns1__GetPTZPort *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetPTZConfigurationResponse:
		soap_serialize_PointerTo_ns1__SetPTZConfigurationResponse(soap, (_ns1__SetPTZConfigurationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetPTZConfiguration:
		soap_serialize_PointerTo_ns1__SetPTZConfiguration(soap, (_ns1__SetPTZConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPTZConfigurationResponse:
		soap_serialize_PointerTo_ns1__GetPTZConfigurationResponse(soap, (_ns1__GetPTZConfigurationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPTZConfiguration:
		soap_serialize_PointerTo_ns1__GetPTZConfiguration(soap, (_ns1__GetPTZConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StopRecordedPatternResponse:
		soap_serialize_PointerTo_ns1__StopRecordedPatternResponse(soap, (_ns1__StopRecordedPatternResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StopRecordedPattern:
		soap_serialize_PointerTo_ns1__StopRecordedPattern(soap, (_ns1__StopRecordedPattern *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PlayRecordedPatternResponse:
		soap_serialize_PointerTo_ns1__PlayRecordedPatternResponse(soap, (_ns1__PlayRecordedPatternResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PlayRecordedPattern:
		soap_serialize_PointerTo_ns1__PlayRecordedPattern(soap, (_ns1__PlayRecordedPattern *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StopPatternRecordingResponse:
		soap_serialize_PointerTo_ns1__StopPatternRecordingResponse(soap, (_ns1__StopPatternRecordingResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StopPatternRecording:
		soap_serialize_PointerTo_ns1__StopPatternRecording(soap, (_ns1__StopPatternRecording *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StartPatternRecordingResponse:
		soap_serialize_PointerTo_ns1__StartPatternRecordingResponse(soap, (_ns1__StartPatternRecordingResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StartPatternRecording:
		soap_serialize_PointerTo_ns1__StartPatternRecording(soap, (_ns1__StartPatternRecording *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StopPresetTourResponse:
		soap_serialize_PointerTo_ns1__StopPresetTourResponse(soap, (_ns1__StopPresetTourResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StopPresetTour:
		soap_serialize_PointerTo_ns1__StopPresetTour(soap, (_ns1__StopPresetTour *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PlayPresetTourResponse:
		soap_serialize_PointerTo_ns1__PlayPresetTourResponse(soap, (_ns1__PlayPresetTourResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PlayPresetTour:
		soap_serialize_PointerTo_ns1__PlayPresetTour(soap, (_ns1__PlayPresetTour *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetPresetTourResponse:
		soap_serialize_PointerTo_ns1__SetPresetTourResponse(soap, (_ns1__SetPresetTourResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetPresetTour:
		soap_serialize_PointerTo_ns1__SetPresetTour(soap, (_ns1__SetPresetTour *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPresetTourResponse:
		soap_serialize_PointerTo_ns1__GetPresetTourResponse(soap, (_ns1__GetPresetTourResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPresetTour:
		soap_serialize_PointerTo_ns1__GetPresetTour(soap, (_ns1__GetPresetTour *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RemovePresetResponse:
		soap_serialize_PointerTo_ns1__RemovePresetResponse(soap, (_ns1__RemovePresetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RemovePreset:
		soap_serialize_PointerTo_ns1__RemovePreset(soap, (_ns1__RemovePreset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GotoPresetResponse:
		soap_serialize_PointerTo_ns1__GotoPresetResponse(soap, (_ns1__GotoPresetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GotoPreset:
		soap_serialize_PointerTo_ns1__GotoPreset(soap, (_ns1__GotoPreset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddPresetResponse:
		soap_serialize_PointerTo_ns1__AddPresetResponse(soap, (_ns1__AddPresetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddPreset:
		soap_serialize_PointerTo_ns1__AddPreset(soap, (_ns1__AddPreset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPresetListResponse:
		soap_serialize_PointerTo_ns1__GetPresetListResponse(soap, (_ns1__GetPresetListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPresetList:
		soap_serialize_PointerTo_ns1__GetPresetList(soap, (_ns1__GetPresetList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StopResponse:
		soap_serialize_PointerTo_ns1__StopResponse(soap, (_ns1__StopResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Stop:
		soap_serialize_PointerTo_ns1__Stop(soap, (_ns1__Stop *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ControlPTZResponse:
		soap_serialize_PointerTo_ns1__ControlPTZResponse(soap, (_ns1__ControlPTZResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ControlPTZ:
		soap_serialize_PointerTo_ns1__ControlPTZ(soap, (_ns1__ControlPTZ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPTZCommandListResponse:
		soap_serialize_PointerTo_ns1__GetPTZCommandListResponse(soap, (_ns1__GetPTZCommandListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPTZCommandList:
		soap_serialize_PointerTo_ns1__GetPTZCommandList(soap, (_ns1__GetPTZCommandList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocolInfoResponse:
		soap_serialize_PointerTo_ns1__GetPTZProtocolInfoResponse(soap, (_ns1__GetPTZProtocolInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocolInfo:
		soap_serialize_PointerTo_ns1__GetPTZProtocolInfo(soap, (_ns1__GetPTZProtocolInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RemovePTZProtocolResponse:
		soap_serialize_PointerTo_ns1__RemovePTZProtocolResponse(soap, (_ns1__RemovePTZProtocolResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RemovePTZProtocol:
		soap_serialize_PointerTo_ns1__RemovePTZProtocol(soap, (_ns1__RemovePTZProtocol *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddPTZProtocolResponse:
		soap_serialize_PointerTo_ns1__AddPTZProtocolResponse(soap, (_ns1__AddPTZProtocolResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddPTZProtocol:
		soap_serialize_PointerTo_ns1__AddPTZProtocol(soap, (_ns1__AddPTZProtocol *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetPTZProtocolResponse:
		soap_serialize_PointerTo_ns1__SetPTZProtocolResponse(soap, (_ns1__SetPTZProtocolResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetPTZProtocol:
		soap_serialize_PointerTo_ns1__SetPTZProtocol(soap, (_ns1__SetPTZProtocol *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocolResponse:
		soap_serialize_PointerTo_ns1__GetPTZProtocolResponse(soap, (_ns1__GetPTZProtocolResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocol:
		soap_serialize_PointerTo_ns1__GetPTZProtocol(soap, (_ns1__GetPTZProtocol *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocolListResponse:
		soap_serialize_PointerTo_ns1__GetPTZProtocolListResponse(soap, (_ns1__GetPTZProtocolListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPTZProtocolList:
		soap_serialize_PointerTo_ns1__GetPTZProtocolList(soap, (_ns1__GetPTZProtocolList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PortConfig_USCORET:
		soap_serialize_PointerTons1__PortConfig_USCORET(soap, (ns1__PortConfig_USCORET *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfPreset_USCORET:
		soap_serialize_PointerTons1__ArrayOfPreset_USCORET(soap, (ns1__ArrayOfPreset_USCORET *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfParameter_USCORET:
		soap_serialize_PointerTons1__ArrayOfParameter_USCORET(soap, (ns1__ArrayOfParameter_USCORET *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PTZProtocol_USCORET:
		soap_serialize_PointerTons1__PTZProtocol_USCORET(soap, (ns1__PTZProtocol_USCORET *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfString:
		soap_serialize_PointerTons1__ArrayOfString(soap, (ns1__ArrayOfString *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Preset_USCORET:
		soap_serialize_PointerToPointerTons1__Preset_USCORET(soap, (ns1__Preset_USCORET **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Preset_USCORET:
		soap_serialize_PointerTons1__Preset_USCORET(soap, (ns1__Preset_USCORET *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Parameter_USCORET:
		soap_serialize_PointerToPointerTons1__Parameter_USCORET(soap, (ns1__Parameter_USCORET **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Parameter_USCORET:
		soap_serialize_PointerTons1__Parameter_USCORET(soap, (ns1__Parameter_USCORET *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__IntRange_USCORET:
		soap_serialize_PointerTons1__IntRange_USCORET(soap, (ns1__IntRange_USCORET *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_ns1__ArrayOfString:
		return (void*)soap_instantiate_ns1__ArrayOfString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PTZProtocol_USCORET:
		return (void*)soap_instantiate_ns1__PTZProtocol_USCORET(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__IntRange_USCORET:
		return (void*)soap_instantiate_ns1__IntRange_USCORET(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfParameter_USCORET:
		return (void*)soap_instantiate_ns1__ArrayOfParameter_USCORET(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Parameter_USCORET:
		return (void*)soap_instantiate_ns1__Parameter_USCORET(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfPreset_USCORET:
		return (void*)soap_instantiate_ns1__ArrayOfPreset_USCORET(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Preset_USCORET:
		return (void*)soap_instantiate_ns1__Preset_USCORET(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PortConfig_USCORET:
		return (void*)soap_instantiate_ns1__PortConfig_USCORET(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPTZProtocolList:
		return (void*)soap_instantiate__ns1__GetPTZProtocolList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPTZProtocolListResponse:
		return (void*)soap_instantiate__ns1__GetPTZProtocolListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPTZProtocol:
		return (void*)soap_instantiate__ns1__GetPTZProtocol(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPTZProtocolResponse:
		return (void*)soap_instantiate__ns1__GetPTZProtocolResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetPTZProtocol:
		return (void*)soap_instantiate__ns1__SetPTZProtocol(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetPTZProtocolResponse:
		return (void*)soap_instantiate__ns1__SetPTZProtocolResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddPTZProtocol:
		return (void*)soap_instantiate__ns1__AddPTZProtocol(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddPTZProtocolResponse:
		return (void*)soap_instantiate__ns1__AddPTZProtocolResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemovePTZProtocol:
		return (void*)soap_instantiate__ns1__RemovePTZProtocol(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemovePTZProtocolResponse:
		return (void*)soap_instantiate__ns1__RemovePTZProtocolResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPTZProtocolInfo:
		return (void*)soap_instantiate__ns1__GetPTZProtocolInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPTZProtocolInfoResponse:
		return (void*)soap_instantiate__ns1__GetPTZProtocolInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPTZCommandList:
		return (void*)soap_instantiate__ns1__GetPTZCommandList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPTZCommandListResponse:
		return (void*)soap_instantiate__ns1__GetPTZCommandListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ControlPTZ:
		return (void*)soap_instantiate__ns1__ControlPTZ(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ControlPTZResponse:
		return (void*)soap_instantiate__ns1__ControlPTZResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Stop:
		return (void*)soap_instantiate__ns1__Stop(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StopResponse:
		return (void*)soap_instantiate__ns1__StopResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPresetList:
		return (void*)soap_instantiate__ns1__GetPresetList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPresetListResponse:
		return (void*)soap_instantiate__ns1__GetPresetListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddPreset:
		return (void*)soap_instantiate__ns1__AddPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddPresetResponse:
		return (void*)soap_instantiate__ns1__AddPresetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GotoPreset:
		return (void*)soap_instantiate__ns1__GotoPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GotoPresetResponse:
		return (void*)soap_instantiate__ns1__GotoPresetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemovePreset:
		return (void*)soap_instantiate__ns1__RemovePreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemovePresetResponse:
		return (void*)soap_instantiate__ns1__RemovePresetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPresetTour:
		return (void*)soap_instantiate__ns1__GetPresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPresetTourResponse:
		return (void*)soap_instantiate__ns1__GetPresetTourResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetPresetTour:
		return (void*)soap_instantiate__ns1__SetPresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetPresetTourResponse:
		return (void*)soap_instantiate__ns1__SetPresetTourResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PlayPresetTour:
		return (void*)soap_instantiate__ns1__PlayPresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PlayPresetTourResponse:
		return (void*)soap_instantiate__ns1__PlayPresetTourResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StopPresetTour:
		return (void*)soap_instantiate__ns1__StopPresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StopPresetTourResponse:
		return (void*)soap_instantiate__ns1__StopPresetTourResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StartPatternRecording:
		return (void*)soap_instantiate__ns1__StartPatternRecording(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StartPatternRecordingResponse:
		return (void*)soap_instantiate__ns1__StartPatternRecordingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StopPatternRecording:
		return (void*)soap_instantiate__ns1__StopPatternRecording(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StopPatternRecordingResponse:
		return (void*)soap_instantiate__ns1__StopPatternRecordingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PlayRecordedPattern:
		return (void*)soap_instantiate__ns1__PlayRecordedPattern(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PlayRecordedPatternResponse:
		return (void*)soap_instantiate__ns1__PlayRecordedPatternResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StopRecordedPattern:
		return (void*)soap_instantiate__ns1__StopRecordedPattern(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StopRecordedPatternResponse:
		return (void*)soap_instantiate__ns1__StopRecordedPatternResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPTZConfiguration:
		return (void*)soap_instantiate__ns1__GetPTZConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPTZConfigurationResponse:
		return (void*)soap_instantiate__ns1__GetPTZConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetPTZConfiguration:
		return (void*)soap_instantiate__ns1__SetPTZConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetPTZConfigurationResponse:
		return (void*)soap_instantiate__ns1__SetPTZConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPTZPort:
		return (void*)soap_instantiate__ns1__GetPTZPort(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPTZPortResponse:
		return (void*)soap_instantiate__ns1__GetPTZPortResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetPTZPort:
		return (void*)soap_instantiate__ns1__SetPTZPort(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetPTZPortResponse:
		return (void*)soap_instantiate__ns1__SetPTZPortResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PTZByPass:
		return (void*)soap_instantiate__ns1__PTZByPass(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PTZByPassResponse:
		return (void*)soap_instantiate__ns1__PTZByPassResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OSDMenu:
		return (void*)soap_instantiate__ns1__OSDMenu(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OSDMenuResponse:
		return (void*)soap_instantiate__ns1__OSDMenuResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetPTZProtocolList:
		return (void*)soap_instantiate___ns2__GetPTZProtocolList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetPTZProtocol:
		return (void*)soap_instantiate___ns2__GetPTZProtocol(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__SetPTZProtocol:
		return (void*)soap_instantiate___ns2__SetPTZProtocol(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__AddPTZProtocol:
		return (void*)soap_instantiate___ns2__AddPTZProtocol(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__RemovePTZProtocol:
		return (void*)soap_instantiate___ns2__RemovePTZProtocol(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetPTZProtocolInfo:
		return (void*)soap_instantiate___ns2__GetPTZProtocolInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetPTZCommandList:
		return (void*)soap_instantiate___ns2__GetPTZCommandList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__ControlPTZ:
		return (void*)soap_instantiate___ns2__ControlPTZ(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__Stop:
		return (void*)soap_instantiate___ns2__Stop(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetPresetList:
		return (void*)soap_instantiate___ns2__GetPresetList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__AddPreset:
		return (void*)soap_instantiate___ns2__AddPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GotoPreset:
		return (void*)soap_instantiate___ns2__GotoPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__RemovePreset:
		return (void*)soap_instantiate___ns2__RemovePreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetPresetTour:
		return (void*)soap_instantiate___ns2__GetPresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__SetPresetTour:
		return (void*)soap_instantiate___ns2__SetPresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__PlayPresetTour:
		return (void*)soap_instantiate___ns2__PlayPresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__StopPresetTour:
		return (void*)soap_instantiate___ns2__StopPresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__StartPatternRecording:
		return (void*)soap_instantiate___ns2__StartPatternRecording(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__StopPatternRecording:
		return (void*)soap_instantiate___ns2__StopPatternRecording(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__PlayRecordedPattern:
		return (void*)soap_instantiate___ns2__PlayRecordedPattern(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__StopRecordedPattern:
		return (void*)soap_instantiate___ns2__StopRecordedPattern(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetPTZConfiguration:
		return (void*)soap_instantiate___ns2__GetPTZConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__SetPTZConfiguration:
		return (void*)soap_instantiate___ns2__SetPTZConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetPTZPort:
		return (void*)soap_instantiate___ns2__GetPTZPort(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__SetPTZPort:
		return (void*)soap_instantiate___ns2__SetPTZPort(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__PTZByPass:
		return (void*)soap_instantiate___ns2__PTZByPass(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__OSDMenu:
		return (void*)soap_instantiate___ns2__OSDMenu(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetPTZProtocolList:
		return (void*)soap_instantiate___ns3__GetPTZProtocolList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetPTZProtocol:
		return (void*)soap_instantiate___ns3__GetPTZProtocol(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__SetPTZProtocol:
		return (void*)soap_instantiate___ns3__SetPTZProtocol(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__AddPTZProtocol:
		return (void*)soap_instantiate___ns3__AddPTZProtocol(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__RemovePTZProtocol:
		return (void*)soap_instantiate___ns3__RemovePTZProtocol(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetPTZProtocolInfo:
		return (void*)soap_instantiate___ns3__GetPTZProtocolInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetPTZCommandList:
		return (void*)soap_instantiate___ns3__GetPTZCommandList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__ControlPTZ:
		return (void*)soap_instantiate___ns3__ControlPTZ(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__Stop:
		return (void*)soap_instantiate___ns3__Stop(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetPresetList:
		return (void*)soap_instantiate___ns3__GetPresetList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__AddPreset:
		return (void*)soap_instantiate___ns3__AddPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GotoPreset:
		return (void*)soap_instantiate___ns3__GotoPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__RemovePreset:
		return (void*)soap_instantiate___ns3__RemovePreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetPresetTour:
		return (void*)soap_instantiate___ns3__GetPresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__SetPresetTour:
		return (void*)soap_instantiate___ns3__SetPresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__PlayPresetTour:
		return (void*)soap_instantiate___ns3__PlayPresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__StopPresetTour:
		return (void*)soap_instantiate___ns3__StopPresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__StartPatternRecording:
		return (void*)soap_instantiate___ns3__StartPatternRecording(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__StopPatternRecording:
		return (void*)soap_instantiate___ns3__StopPatternRecording(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__PlayRecordedPattern:
		return (void*)soap_instantiate___ns3__PlayRecordedPattern(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__StopRecordedPattern:
		return (void*)soap_instantiate___ns3__StopRecordedPattern(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetPTZConfiguration:
		return (void*)soap_instantiate___ns3__GetPTZConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__SetPTZConfiguration:
		return (void*)soap_instantiate___ns3__SetPTZConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__GetPTZPort:
		return (void*)soap_instantiate___ns3__GetPTZPort(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__SetPTZPort:
		return (void*)soap_instantiate___ns3__SetPTZPort(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__PTZByPass:
		return (void*)soap_instantiate___ns3__PTZByPass(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns3__OSDMenu:
		return (void*)soap_instantiate___ns3__OSDMenu(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns1__ArrayOfString:
		if (p->size < 0)
			delete (ns1__ArrayOfString*)p->ptr;
		else
			delete[] (ns1__ArrayOfString*)p->ptr;
		break;
	case SOAP_TYPE_ns1__PTZProtocol_USCORET:
		if (p->size < 0)
			delete (ns1__PTZProtocol_USCORET*)p->ptr;
		else
			delete[] (ns1__PTZProtocol_USCORET*)p->ptr;
		break;
	case SOAP_TYPE_ns1__IntRange_USCORET:
		if (p->size < 0)
			delete (ns1__IntRange_USCORET*)p->ptr;
		else
			delete[] (ns1__IntRange_USCORET*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfParameter_USCORET:
		if (p->size < 0)
			delete (ns1__ArrayOfParameter_USCORET*)p->ptr;
		else
			delete[] (ns1__ArrayOfParameter_USCORET*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Parameter_USCORET:
		if (p->size < 0)
			delete (ns1__Parameter_USCORET*)p->ptr;
		else
			delete[] (ns1__Parameter_USCORET*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfPreset_USCORET:
		if (p->size < 0)
			delete (ns1__ArrayOfPreset_USCORET*)p->ptr;
		else
			delete[] (ns1__ArrayOfPreset_USCORET*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Preset_USCORET:
		if (p->size < 0)
			delete (ns1__Preset_USCORET*)p->ptr;
		else
			delete[] (ns1__Preset_USCORET*)p->ptr;
		break;
	case SOAP_TYPE_ns1__PortConfig_USCORET:
		if (p->size < 0)
			delete (ns1__PortConfig_USCORET*)p->ptr;
		else
			delete[] (ns1__PortConfig_USCORET*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetPTZProtocolList:
		if (p->size < 0)
			delete (_ns1__GetPTZProtocolList*)p->ptr;
		else
			delete[] (_ns1__GetPTZProtocolList*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetPTZProtocolListResponse:
		if (p->size < 0)
			delete (_ns1__GetPTZProtocolListResponse*)p->ptr;
		else
			delete[] (_ns1__GetPTZProtocolListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetPTZProtocol:
		if (p->size < 0)
			delete (_ns1__GetPTZProtocol*)p->ptr;
		else
			delete[] (_ns1__GetPTZProtocol*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetPTZProtocolResponse:
		if (p->size < 0)
			delete (_ns1__GetPTZProtocolResponse*)p->ptr;
		else
			delete[] (_ns1__GetPTZProtocolResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__SetPTZProtocol:
		if (p->size < 0)
			delete (_ns1__SetPTZProtocol*)p->ptr;
		else
			delete[] (_ns1__SetPTZProtocol*)p->ptr;
		break;
	case SOAP_TYPE__ns1__SetPTZProtocolResponse:
		if (p->size < 0)
			delete (_ns1__SetPTZProtocolResponse*)p->ptr;
		else
			delete[] (_ns1__SetPTZProtocolResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__AddPTZProtocol:
		if (p->size < 0)
			delete (_ns1__AddPTZProtocol*)p->ptr;
		else
			delete[] (_ns1__AddPTZProtocol*)p->ptr;
		break;
	case SOAP_TYPE__ns1__AddPTZProtocolResponse:
		if (p->size < 0)
			delete (_ns1__AddPTZProtocolResponse*)p->ptr;
		else
			delete[] (_ns1__AddPTZProtocolResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__RemovePTZProtocol:
		if (p->size < 0)
			delete (_ns1__RemovePTZProtocol*)p->ptr;
		else
			delete[] (_ns1__RemovePTZProtocol*)p->ptr;
		break;
	case SOAP_TYPE__ns1__RemovePTZProtocolResponse:
		if (p->size < 0)
			delete (_ns1__RemovePTZProtocolResponse*)p->ptr;
		else
			delete[] (_ns1__RemovePTZProtocolResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetPTZProtocolInfo:
		if (p->size < 0)
			delete (_ns1__GetPTZProtocolInfo*)p->ptr;
		else
			delete[] (_ns1__GetPTZProtocolInfo*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetPTZProtocolInfoResponse:
		if (p->size < 0)
			delete (_ns1__GetPTZProtocolInfoResponse*)p->ptr;
		else
			delete[] (_ns1__GetPTZProtocolInfoResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetPTZCommandList:
		if (p->size < 0)
			delete (_ns1__GetPTZCommandList*)p->ptr;
		else
			delete[] (_ns1__GetPTZCommandList*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetPTZCommandListResponse:
		if (p->size < 0)
			delete (_ns1__GetPTZCommandListResponse*)p->ptr;
		else
			delete[] (_ns1__GetPTZCommandListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__ControlPTZ:
		if (p->size < 0)
			delete (_ns1__ControlPTZ*)p->ptr;
		else
			delete[] (_ns1__ControlPTZ*)p->ptr;
		break;
	case SOAP_TYPE__ns1__ControlPTZResponse:
		if (p->size < 0)
			delete (_ns1__ControlPTZResponse*)p->ptr;
		else
			delete[] (_ns1__ControlPTZResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__Stop:
		if (p->size < 0)
			delete (_ns1__Stop*)p->ptr;
		else
			delete[] (_ns1__Stop*)p->ptr;
		break;
	case SOAP_TYPE__ns1__StopResponse:
		if (p->size < 0)
			delete (_ns1__StopResponse*)p->ptr;
		else
			delete[] (_ns1__StopResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetPresetList:
		if (p->size < 0)
			delete (_ns1__GetPresetList*)p->ptr;
		else
			delete[] (_ns1__GetPresetList*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetPresetListResponse:
		if (p->size < 0)
			delete (_ns1__GetPresetListResponse*)p->ptr;
		else
			delete[] (_ns1__GetPresetListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__AddPreset:
		if (p->size < 0)
			delete (_ns1__AddPreset*)p->ptr;
		else
			delete[] (_ns1__AddPreset*)p->ptr;
		break;
	case SOAP_TYPE__ns1__AddPresetResponse:
		if (p->size < 0)
			delete (_ns1__AddPresetResponse*)p->ptr;
		else
			delete[] (_ns1__AddPresetResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GotoPreset:
		if (p->size < 0)
			delete (_ns1__GotoPreset*)p->ptr;
		else
			delete[] (_ns1__GotoPreset*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GotoPresetResponse:
		if (p->size < 0)
			delete (_ns1__GotoPresetResponse*)p->ptr;
		else
			delete[] (_ns1__GotoPresetResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__RemovePreset:
		if (p->size < 0)
			delete (_ns1__RemovePreset*)p->ptr;
		else
			delete[] (_ns1__RemovePreset*)p->ptr;
		break;
	case SOAP_TYPE__ns1__RemovePresetResponse:
		if (p->size < 0)
			delete (_ns1__RemovePresetResponse*)p->ptr;
		else
			delete[] (_ns1__RemovePresetResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetPresetTour:
		if (p->size < 0)
			delete (_ns1__GetPresetTour*)p->ptr;
		else
			delete[] (_ns1__GetPresetTour*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetPresetTourResponse:
		if (p->size < 0)
			delete (_ns1__GetPresetTourResponse*)p->ptr;
		else
			delete[] (_ns1__GetPresetTourResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__SetPresetTour:
		if (p->size < 0)
			delete (_ns1__SetPresetTour*)p->ptr;
		else
			delete[] (_ns1__SetPresetTour*)p->ptr;
		break;
	case SOAP_TYPE__ns1__SetPresetTourResponse:
		if (p->size < 0)
			delete (_ns1__SetPresetTourResponse*)p->ptr;
		else
			delete[] (_ns1__SetPresetTourResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__PlayPresetTour:
		if (p->size < 0)
			delete (_ns1__PlayPresetTour*)p->ptr;
		else
			delete[] (_ns1__PlayPresetTour*)p->ptr;
		break;
	case SOAP_TYPE__ns1__PlayPresetTourResponse:
		if (p->size < 0)
			delete (_ns1__PlayPresetTourResponse*)p->ptr;
		else
			delete[] (_ns1__PlayPresetTourResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__StopPresetTour:
		if (p->size < 0)
			delete (_ns1__StopPresetTour*)p->ptr;
		else
			delete[] (_ns1__StopPresetTour*)p->ptr;
		break;
	case SOAP_TYPE__ns1__StopPresetTourResponse:
		if (p->size < 0)
			delete (_ns1__StopPresetTourResponse*)p->ptr;
		else
			delete[] (_ns1__StopPresetTourResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__StartPatternRecording:
		if (p->size < 0)
			delete (_ns1__StartPatternRecording*)p->ptr;
		else
			delete[] (_ns1__StartPatternRecording*)p->ptr;
		break;
	case SOAP_TYPE__ns1__StartPatternRecordingResponse:
		if (p->size < 0)
			delete (_ns1__StartPatternRecordingResponse*)p->ptr;
		else
			delete[] (_ns1__StartPatternRecordingResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__StopPatternRecording:
		if (p->size < 0)
			delete (_ns1__StopPatternRecording*)p->ptr;
		else
			delete[] (_ns1__StopPatternRecording*)p->ptr;
		break;
	case SOAP_TYPE__ns1__StopPatternRecordingResponse:
		if (p->size < 0)
			delete (_ns1__StopPatternRecordingResponse*)p->ptr;
		else
			delete[] (_ns1__StopPatternRecordingResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__PlayRecordedPattern:
		if (p->size < 0)
			delete (_ns1__PlayRecordedPattern*)p->ptr;
		else
			delete[] (_ns1__PlayRecordedPattern*)p->ptr;
		break;
	case SOAP_TYPE__ns1__PlayRecordedPatternResponse:
		if (p->size < 0)
			delete (_ns1__PlayRecordedPatternResponse*)p->ptr;
		else
			delete[] (_ns1__PlayRecordedPatternResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__StopRecordedPattern:
		if (p->size < 0)
			delete (_ns1__StopRecordedPattern*)p->ptr;
		else
			delete[] (_ns1__StopRecordedPattern*)p->ptr;
		break;
	case SOAP_TYPE__ns1__StopRecordedPatternResponse:
		if (p->size < 0)
			delete (_ns1__StopRecordedPatternResponse*)p->ptr;
		else
			delete[] (_ns1__StopRecordedPatternResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetPTZConfiguration:
		if (p->size < 0)
			delete (_ns1__GetPTZConfiguration*)p->ptr;
		else
			delete[] (_ns1__GetPTZConfiguration*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetPTZConfigurationResponse:
		if (p->size < 0)
			delete (_ns1__GetPTZConfigurationResponse*)p->ptr;
		else
			delete[] (_ns1__GetPTZConfigurationResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__SetPTZConfiguration:
		if (p->size < 0)
			delete (_ns1__SetPTZConfiguration*)p->ptr;
		else
			delete[] (_ns1__SetPTZConfiguration*)p->ptr;
		break;
	case SOAP_TYPE__ns1__SetPTZConfigurationResponse:
		if (p->size < 0)
			delete (_ns1__SetPTZConfigurationResponse*)p->ptr;
		else
			delete[] (_ns1__SetPTZConfigurationResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetPTZPort:
		if (p->size < 0)
			delete (_ns1__GetPTZPort*)p->ptr;
		else
			delete[] (_ns1__GetPTZPort*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetPTZPortResponse:
		if (p->size < 0)
			delete (_ns1__GetPTZPortResponse*)p->ptr;
		else
			delete[] (_ns1__GetPTZPortResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__SetPTZPort:
		if (p->size < 0)
			delete (_ns1__SetPTZPort*)p->ptr;
		else
			delete[] (_ns1__SetPTZPort*)p->ptr;
		break;
	case SOAP_TYPE__ns1__SetPTZPortResponse:
		if (p->size < 0)
			delete (_ns1__SetPTZPortResponse*)p->ptr;
		else
			delete[] (_ns1__SetPTZPortResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__PTZByPass:
		if (p->size < 0)
			delete (_ns1__PTZByPass*)p->ptr;
		else
			delete[] (_ns1__PTZByPass*)p->ptr;
		break;
	case SOAP_TYPE__ns1__PTZByPassResponse:
		if (p->size < 0)
			delete (_ns1__PTZByPassResponse*)p->ptr;
		else
			delete[] (_ns1__PTZByPassResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__OSDMenu:
		if (p->size < 0)
			delete (_ns1__OSDMenu*)p->ptr;
		else
			delete[] (_ns1__OSDMenu*)p->ptr;
		break;
	case SOAP_TYPE__ns1__OSDMenuResponse:
		if (p->size < 0)
			delete (_ns1__OSDMenuResponse*)p->ptr;
		else
			delete[] (_ns1__OSDMenuResponse*)p->ptr;
		break;
	case SOAP_TYPE___ns2__GetPTZProtocolList:
		if (p->size < 0)
			delete (struct __ns2__GetPTZProtocolList*)p->ptr;
		else
			delete[] (struct __ns2__GetPTZProtocolList*)p->ptr;
		break;
	case SOAP_TYPE___ns2__GetPTZProtocol:
		if (p->size < 0)
			delete (struct __ns2__GetPTZProtocol*)p->ptr;
		else
			delete[] (struct __ns2__GetPTZProtocol*)p->ptr;
		break;
	case SOAP_TYPE___ns2__SetPTZProtocol:
		if (p->size < 0)
			delete (struct __ns2__SetPTZProtocol*)p->ptr;
		else
			delete[] (struct __ns2__SetPTZProtocol*)p->ptr;
		break;
	case SOAP_TYPE___ns2__AddPTZProtocol:
		if (p->size < 0)
			delete (struct __ns2__AddPTZProtocol*)p->ptr;
		else
			delete[] (struct __ns2__AddPTZProtocol*)p->ptr;
		break;
	case SOAP_TYPE___ns2__RemovePTZProtocol:
		if (p->size < 0)
			delete (struct __ns2__RemovePTZProtocol*)p->ptr;
		else
			delete[] (struct __ns2__RemovePTZProtocol*)p->ptr;
		break;
	case SOAP_TYPE___ns2__GetPTZProtocolInfo:
		if (p->size < 0)
			delete (struct __ns2__GetPTZProtocolInfo*)p->ptr;
		else
			delete[] (struct __ns2__GetPTZProtocolInfo*)p->ptr;
		break;
	case SOAP_TYPE___ns2__GetPTZCommandList:
		if (p->size < 0)
			delete (struct __ns2__GetPTZCommandList*)p->ptr;
		else
			delete[] (struct __ns2__GetPTZCommandList*)p->ptr;
		break;
	case SOAP_TYPE___ns2__ControlPTZ:
		if (p->size < 0)
			delete (struct __ns2__ControlPTZ*)p->ptr;
		else
			delete[] (struct __ns2__ControlPTZ*)p->ptr;
		break;
	case SOAP_TYPE___ns2__Stop:
		if (p->size < 0)
			delete (struct __ns2__Stop*)p->ptr;
		else
			delete[] (struct __ns2__Stop*)p->ptr;
		break;
	case SOAP_TYPE___ns2__GetPresetList:
		if (p->size < 0)
			delete (struct __ns2__GetPresetList*)p->ptr;
		else
			delete[] (struct __ns2__GetPresetList*)p->ptr;
		break;
	case SOAP_TYPE___ns2__AddPreset:
		if (p->size < 0)
			delete (struct __ns2__AddPreset*)p->ptr;
		else
			delete[] (struct __ns2__AddPreset*)p->ptr;
		break;
	case SOAP_TYPE___ns2__GotoPreset:
		if (p->size < 0)
			delete (struct __ns2__GotoPreset*)p->ptr;
		else
			delete[] (struct __ns2__GotoPreset*)p->ptr;
		break;
	case SOAP_TYPE___ns2__RemovePreset:
		if (p->size < 0)
			delete (struct __ns2__RemovePreset*)p->ptr;
		else
			delete[] (struct __ns2__RemovePreset*)p->ptr;
		break;
	case SOAP_TYPE___ns2__GetPresetTour:
		if (p->size < 0)
			delete (struct __ns2__GetPresetTour*)p->ptr;
		else
			delete[] (struct __ns2__GetPresetTour*)p->ptr;
		break;
	case SOAP_TYPE___ns2__SetPresetTour:
		if (p->size < 0)
			delete (struct __ns2__SetPresetTour*)p->ptr;
		else
			delete[] (struct __ns2__SetPresetTour*)p->ptr;
		break;
	case SOAP_TYPE___ns2__PlayPresetTour:
		if (p->size < 0)
			delete (struct __ns2__PlayPresetTour*)p->ptr;
		else
			delete[] (struct __ns2__PlayPresetTour*)p->ptr;
		break;
	case SOAP_TYPE___ns2__StopPresetTour:
		if (p->size < 0)
			delete (struct __ns2__StopPresetTour*)p->ptr;
		else
			delete[] (struct __ns2__StopPresetTour*)p->ptr;
		break;
	case SOAP_TYPE___ns2__StartPatternRecording:
		if (p->size < 0)
			delete (struct __ns2__StartPatternRecording*)p->ptr;
		else
			delete[] (struct __ns2__StartPatternRecording*)p->ptr;
		break;
	case SOAP_TYPE___ns2__StopPatternRecording:
		if (p->size < 0)
			delete (struct __ns2__StopPatternRecording*)p->ptr;
		else
			delete[] (struct __ns2__StopPatternRecording*)p->ptr;
		break;
	case SOAP_TYPE___ns2__PlayRecordedPattern:
		if (p->size < 0)
			delete (struct __ns2__PlayRecordedPattern*)p->ptr;
		else
			delete[] (struct __ns2__PlayRecordedPattern*)p->ptr;
		break;
	case SOAP_TYPE___ns2__StopRecordedPattern:
		if (p->size < 0)
			delete (struct __ns2__StopRecordedPattern*)p->ptr;
		else
			delete[] (struct __ns2__StopRecordedPattern*)p->ptr;
		break;
	case SOAP_TYPE___ns2__GetPTZConfiguration:
		if (p->size < 0)
			delete (struct __ns2__GetPTZConfiguration*)p->ptr;
		else
			delete[] (struct __ns2__GetPTZConfiguration*)p->ptr;
		break;
	case SOAP_TYPE___ns2__SetPTZConfiguration:
		if (p->size < 0)
			delete (struct __ns2__SetPTZConfiguration*)p->ptr;
		else
			delete[] (struct __ns2__SetPTZConfiguration*)p->ptr;
		break;
	case SOAP_TYPE___ns2__GetPTZPort:
		if (p->size < 0)
			delete (struct __ns2__GetPTZPort*)p->ptr;
		else
			delete[] (struct __ns2__GetPTZPort*)p->ptr;
		break;
	case SOAP_TYPE___ns2__SetPTZPort:
		if (p->size < 0)
			delete (struct __ns2__SetPTZPort*)p->ptr;
		else
			delete[] (struct __ns2__SetPTZPort*)p->ptr;
		break;
	case SOAP_TYPE___ns2__PTZByPass:
		if (p->size < 0)
			delete (struct __ns2__PTZByPass*)p->ptr;
		else
			delete[] (struct __ns2__PTZByPass*)p->ptr;
		break;
	case SOAP_TYPE___ns2__OSDMenu:
		if (p->size < 0)
			delete (struct __ns2__OSDMenu*)p->ptr;
		else
			delete[] (struct __ns2__OSDMenu*)p->ptr;
		break;
	case SOAP_TYPE___ns3__GetPTZProtocolList:
		if (p->size < 0)
			delete (struct __ns3__GetPTZProtocolList*)p->ptr;
		else
			delete[] (struct __ns3__GetPTZProtocolList*)p->ptr;
		break;
	case SOAP_TYPE___ns3__GetPTZProtocol:
		if (p->size < 0)
			delete (struct __ns3__GetPTZProtocol*)p->ptr;
		else
			delete[] (struct __ns3__GetPTZProtocol*)p->ptr;
		break;
	case SOAP_TYPE___ns3__SetPTZProtocol:
		if (p->size < 0)
			delete (struct __ns3__SetPTZProtocol*)p->ptr;
		else
			delete[] (struct __ns3__SetPTZProtocol*)p->ptr;
		break;
	case SOAP_TYPE___ns3__AddPTZProtocol:
		if (p->size < 0)
			delete (struct __ns3__AddPTZProtocol*)p->ptr;
		else
			delete[] (struct __ns3__AddPTZProtocol*)p->ptr;
		break;
	case SOAP_TYPE___ns3__RemovePTZProtocol:
		if (p->size < 0)
			delete (struct __ns3__RemovePTZProtocol*)p->ptr;
		else
			delete[] (struct __ns3__RemovePTZProtocol*)p->ptr;
		break;
	case SOAP_TYPE___ns3__GetPTZProtocolInfo:
		if (p->size < 0)
			delete (struct __ns3__GetPTZProtocolInfo*)p->ptr;
		else
			delete[] (struct __ns3__GetPTZProtocolInfo*)p->ptr;
		break;
	case SOAP_TYPE___ns3__GetPTZCommandList:
		if (p->size < 0)
			delete (struct __ns3__GetPTZCommandList*)p->ptr;
		else
			delete[] (struct __ns3__GetPTZCommandList*)p->ptr;
		break;
	case SOAP_TYPE___ns3__ControlPTZ:
		if (p->size < 0)
			delete (struct __ns3__ControlPTZ*)p->ptr;
		else
			delete[] (struct __ns3__ControlPTZ*)p->ptr;
		break;
	case SOAP_TYPE___ns3__Stop:
		if (p->size < 0)
			delete (struct __ns3__Stop*)p->ptr;
		else
			delete[] (struct __ns3__Stop*)p->ptr;
		break;
	case SOAP_TYPE___ns3__GetPresetList:
		if (p->size < 0)
			delete (struct __ns3__GetPresetList*)p->ptr;
		else
			delete[] (struct __ns3__GetPresetList*)p->ptr;
		break;
	case SOAP_TYPE___ns3__AddPreset:
		if (p->size < 0)
			delete (struct __ns3__AddPreset*)p->ptr;
		else
			delete[] (struct __ns3__AddPreset*)p->ptr;
		break;
	case SOAP_TYPE___ns3__GotoPreset:
		if (p->size < 0)
			delete (struct __ns3__GotoPreset*)p->ptr;
		else
			delete[] (struct __ns3__GotoPreset*)p->ptr;
		break;
	case SOAP_TYPE___ns3__RemovePreset:
		if (p->size < 0)
			delete (struct __ns3__RemovePreset*)p->ptr;
		else
			delete[] (struct __ns3__RemovePreset*)p->ptr;
		break;
	case SOAP_TYPE___ns3__GetPresetTour:
		if (p->size < 0)
			delete (struct __ns3__GetPresetTour*)p->ptr;
		else
			delete[] (struct __ns3__GetPresetTour*)p->ptr;
		break;
	case SOAP_TYPE___ns3__SetPresetTour:
		if (p->size < 0)
			delete (struct __ns3__SetPresetTour*)p->ptr;
		else
			delete[] (struct __ns3__SetPresetTour*)p->ptr;
		break;
	case SOAP_TYPE___ns3__PlayPresetTour:
		if (p->size < 0)
			delete (struct __ns3__PlayPresetTour*)p->ptr;
		else
			delete[] (struct __ns3__PlayPresetTour*)p->ptr;
		break;
	case SOAP_TYPE___ns3__StopPresetTour:
		if (p->size < 0)
			delete (struct __ns3__StopPresetTour*)p->ptr;
		else
			delete[] (struct __ns3__StopPresetTour*)p->ptr;
		break;
	case SOAP_TYPE___ns3__StartPatternRecording:
		if (p->size < 0)
			delete (struct __ns3__StartPatternRecording*)p->ptr;
		else
			delete[] (struct __ns3__StartPatternRecording*)p->ptr;
		break;
	case SOAP_TYPE___ns3__StopPatternRecording:
		if (p->size < 0)
			delete (struct __ns3__StopPatternRecording*)p->ptr;
		else
			delete[] (struct __ns3__StopPatternRecording*)p->ptr;
		break;
	case SOAP_TYPE___ns3__PlayRecordedPattern:
		if (p->size < 0)
			delete (struct __ns3__PlayRecordedPattern*)p->ptr;
		else
			delete[] (struct __ns3__PlayRecordedPattern*)p->ptr;
		break;
	case SOAP_TYPE___ns3__StopRecordedPattern:
		if (p->size < 0)
			delete (struct __ns3__StopRecordedPattern*)p->ptr;
		else
			delete[] (struct __ns3__StopRecordedPattern*)p->ptr;
		break;
	case SOAP_TYPE___ns3__GetPTZConfiguration:
		if (p->size < 0)
			delete (struct __ns3__GetPTZConfiguration*)p->ptr;
		else
			delete[] (struct __ns3__GetPTZConfiguration*)p->ptr;
		break;
	case SOAP_TYPE___ns3__SetPTZConfiguration:
		if (p->size < 0)
			delete (struct __ns3__SetPTZConfiguration*)p->ptr;
		else
			delete[] (struct __ns3__SetPTZConfiguration*)p->ptr;
		break;
	case SOAP_TYPE___ns3__GetPTZPort:
		if (p->size < 0)
			delete (struct __ns3__GetPTZPort*)p->ptr;
		else
			delete[] (struct __ns3__GetPTZPort*)p->ptr;
		break;
	case SOAP_TYPE___ns3__SetPTZPort:
		if (p->size < 0)
			delete (struct __ns3__SetPTZPort*)p->ptr;
		else
			delete[] (struct __ns3__SetPTZPort*)p->ptr;
		break;
	case SOAP_TYPE___ns3__PTZByPass:
		if (p->size < 0)
			delete (struct __ns3__PTZByPass*)p->ptr;
		else
			delete[] (struct __ns3__PTZByPass*)p->ptr;
		break;
	case SOAP_TYPE___ns3__OSDMenu:
		if (p->size < 0)
			delete (struct __ns3__OSDMenu*)p->ptr;
		else
			delete[] (struct __ns3__OSDMenu*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__OSD_USCOREMENU_USCORET(struct soap *soap, enum ns1__OSD_USCOREMENU_USCORET *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__OSD_USCOREMENU_USCORET
	*a = SOAP_DEFAULT_ns1__OSD_USCOREMENU_USCORET;
#else
	*a = (enum ns1__OSD_USCOREMENU_USCORET)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__OSD_USCOREMENU_USCORET(struct soap *soap, const enum ns1__OSD_USCOREMENU_USCORET *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__OSD_USCOREMENU_USCORET);
	if (soap_out_ns1__OSD_USCOREMENU_USCORET(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__OSD_USCOREMENU_USCORET[] =
{	{ (long)ns1__OSD_USCOREMENU_USCORET__OSD_USCOREMENU_USCOREOPEN, "OSD_MENU_OPEN" },
	{ (long)ns1__OSD_USCOREMENU_USCORET__OSD_USCOREMENU_USCORECLOSE, "OSD_MENU_CLOSE" },
	{ (long)ns1__OSD_USCOREMENU_USCORET__OSD_USCOREMENU_USCOREUP, "OSD_MENU_UP" },
	{ (long)ns1__OSD_USCOREMENU_USCORET__OSD_USCOREMENU_USCOREDOWN, "OSD_MENU_DOWN" },
	{ (long)ns1__OSD_USCOREMENU_USCORET__OSD_USCOREMENU_USCORELEFT, "OSD_MENU_LEFT" },
	{ (long)ns1__OSD_USCOREMENU_USCORET__OSD_USCOREMENU_USCORERIGHT, "OSD_MENU_RIGHT" },
	{ (long)ns1__OSD_USCOREMENU_USCORET__OSD_USCOREMENU_USCORESELECT, "OSD_MENU_SELECT" },
	{ (long)ns1__OSD_USCOREMENU_USCORET__OSD_USCOREMENU_USCOREBACK, "OSD_MENU_BACK" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__OSD_USCOREMENU_USCORET2s(struct soap *soap, enum ns1__OSD_USCOREMENU_USCORET n)
{	const char *s = soap_code_str(soap_codes_ns1__OSD_USCOREMENU_USCORET, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OSD_USCOREMENU_USCORET(struct soap *soap, const char *tag, int id, const enum ns1__OSD_USCOREMENU_USCORET *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OSD_USCOREMENU_USCORET), type) || soap_send(soap, soap_ns1__OSD_USCOREMENU_USCORET2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__OSD_USCOREMENU_USCORET * SOAP_FMAC4 soap_get_ns1__OSD_USCOREMENU_USCORET(struct soap *soap, enum ns1__OSD_USCOREMENU_USCORET *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OSD_USCOREMENU_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__OSD_USCOREMENU_USCORET(struct soap *soap, const char *s, enum ns1__OSD_USCOREMENU_USCORET *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__OSD_USCOREMENU_USCORET, s);
	if (map)
		*a = (enum ns1__OSD_USCOREMENU_USCORET)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 7)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__OSD_USCOREMENU_USCORET)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__OSD_USCOREMENU_USCORET * SOAP_FMAC4 soap_in_ns1__OSD_USCOREMENU_USCORET(struct soap *soap, const char *tag, enum ns1__OSD_USCOREMENU_USCORET *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__OSD_USCOREMENU_USCORET *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OSD_USCOREMENU_USCORET, sizeof(enum ns1__OSD_USCOREMENU_USCORET), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__OSD_USCOREMENU_USCORET(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__OSD_USCOREMENU_USCORET *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OSD_USCOREMENU_USCORET, 0, sizeof(enum ns1__OSD_USCOREMENU_USCORET), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PARITY_USCORET(struct soap *soap, enum ns1__PARITY_USCORET *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__PARITY_USCORET
	*a = SOAP_DEFAULT_ns1__PARITY_USCORET;
#else
	*a = (enum ns1__PARITY_USCORET)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PARITY_USCORET(struct soap *soap, const enum ns1__PARITY_USCORET *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PARITY_USCORET);
	if (soap_out_ns1__PARITY_USCORET(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__PARITY_USCORET[] =
{	{ (long)ns1__PARITY_USCORET__PARITY_USCORENONE, "PARITY_NONE" },
	{ (long)ns1__PARITY_USCORET__PARITY_USCOREEVEN, "PARITY_EVEN" },
	{ (long)ns1__PARITY_USCORET__PARITY_USCOREODD, "PARITY_ODD" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__PARITY_USCORET2s(struct soap *soap, enum ns1__PARITY_USCORET n)
{	const char *s = soap_code_str(soap_codes_ns1__PARITY_USCORET, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PARITY_USCORET(struct soap *soap, const char *tag, int id, const enum ns1__PARITY_USCORET *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PARITY_USCORET), type) || soap_send(soap, soap_ns1__PARITY_USCORET2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__PARITY_USCORET * SOAP_FMAC4 soap_get_ns1__PARITY_USCORET(struct soap *soap, enum ns1__PARITY_USCORET *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PARITY_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__PARITY_USCORET(struct soap *soap, const char *s, enum ns1__PARITY_USCORET *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__PARITY_USCORET, s);
	if (map)
		*a = (enum ns1__PARITY_USCORET)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__PARITY_USCORET)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__PARITY_USCORET * SOAP_FMAC4 soap_in_ns1__PARITY_USCORET(struct soap *soap, const char *tag, enum ns1__PARITY_USCORET *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__PARITY_USCORET *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PARITY_USCORET, sizeof(enum ns1__PARITY_USCORET), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__PARITY_USCORET(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__PARITY_USCORET *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PARITY_USCORET, 0, sizeof(enum ns1__PARITY_USCORET), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void _ns1__OSDMenuResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__OSDMenuResponse::OSDMenuResult);
	soap_default_int(soap, &this->_ns1__OSDMenuResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__OSDMenuResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__OSDMenuResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__OSDMenuResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__OSDMenuResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OSDMenuResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OSDMenuResponse(struct soap *soap, const char *tag, int id, const _ns1__OSDMenuResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OSDMenuResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OSDMenuResult");
	if (soap_out_bool(soap, "ns1:OSDMenuResult", -1, &(a->_ns1__OSDMenuResponse::OSDMenuResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__OSDMenuResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__OSDMenuResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OSDMenuResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OSDMenuResponse * SOAP_FMAC4 soap_get__ns1__OSDMenuResponse(struct soap *soap, _ns1__OSDMenuResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OSDMenuResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__OSDMenuResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OSDMenuResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OSDMenuResponse * SOAP_FMAC4 soap_in__ns1__OSDMenuResponse(struct soap *soap, const char *tag, _ns1__OSDMenuResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OSDMenuResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OSDMenuResponse, sizeof(_ns1__OSDMenuResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__OSDMenuResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__OSDMenuResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_OSDMenuResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSDMenuResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:OSDMenuResult", &(a->_ns1__OSDMenuResponse::OSDMenuResult), "xsd:boolean"))
				{	soap_flag_OSDMenuResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__OSDMenuResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:OSDMenuResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OSDMenuResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OSDMenuResponse, 0, sizeof(_ns1__OSDMenuResponse), 0, soap_copy__ns1__OSDMenuResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OSDMenuResult1 > 0 || soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__OSDMenuResponse * SOAP_FMAC4 soap_instantiate__ns1__OSDMenuResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OSDMenuResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__OSDMenuResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__OSDMenuResponse;
		if (size)
			*size = sizeof(_ns1__OSDMenuResponse);
		((_ns1__OSDMenuResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__OSDMenuResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__OSDMenuResponse);
		for (int i = 0; i < n; i++)
			((_ns1__OSDMenuResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__OSDMenuResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__OSDMenuResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__OSDMenuResponse %p -> %p\n", q, p));
	*(_ns1__OSDMenuResponse*)p = *(_ns1__OSDMenuResponse*)q;
}

void _ns1__OSDMenu::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__OSD_USCOREMENU_USCORET(soap, &this->_ns1__OSDMenu::osdMenu);
	/* transient soap skipped */
}

void _ns1__OSDMenu::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__OSDMenu::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__OSDMenu);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__OSDMenu::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OSDMenu(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OSDMenu(struct soap *soap, const char *tag, int id, const _ns1__OSDMenu *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OSDMenu), type))
		return soap->error;
	if (soap_out_ns1__OSD_USCOREMENU_USCORET(soap, "ns1:osdMenu", -1, &(a->_ns1__OSDMenu::osdMenu), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__OSDMenu::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OSDMenu(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OSDMenu * SOAP_FMAC4 soap_get__ns1__OSDMenu(struct soap *soap, _ns1__OSDMenu *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OSDMenu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__OSDMenu::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OSDMenu(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OSDMenu * SOAP_FMAC4 soap_in__ns1__OSDMenu(struct soap *soap, const char *tag, _ns1__OSDMenu *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OSDMenu *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OSDMenu, sizeof(_ns1__OSDMenu), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__OSDMenu)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__OSDMenu *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_osdMenu1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_osdMenu1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__OSD_USCOREMENU_USCORET(soap, "ns1:osdMenu", &(a->_ns1__OSDMenu::osdMenu), "ns1:OSD_MENU_T"))
				{	soap_flag_osdMenu1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OSDMenu *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OSDMenu, 0, sizeof(_ns1__OSDMenu), 0, soap_copy__ns1__OSDMenu);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_osdMenu1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__OSDMenu * SOAP_FMAC4 soap_instantiate__ns1__OSDMenu(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OSDMenu(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__OSDMenu, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__OSDMenu;
		if (size)
			*size = sizeof(_ns1__OSDMenu);
		((_ns1__OSDMenu*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__OSDMenu[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__OSDMenu);
		for (int i = 0; i < n; i++)
			((_ns1__OSDMenu*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__OSDMenu*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__OSDMenu(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__OSDMenu %p -> %p\n", q, p));
	*(_ns1__OSDMenu*)p = *(_ns1__OSDMenu*)q;
}

void _ns1__PTZByPassResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__PTZByPassResponse::PTZByPassResult);
	soap_default_int(soap, &this->_ns1__PTZByPassResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__PTZByPassResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__PTZByPassResponse::PTZByPassResult);
	/* transient soap skipped */
}

int _ns1__PTZByPassResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PTZByPassResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__PTZByPassResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PTZByPassResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PTZByPassResponse(struct soap *soap, const char *tag, int id, const _ns1__PTZByPassResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PTZByPassResponse), type))
		return soap->error;
	if (a->PTZByPassResult)
		soap_element_result(soap, "ns1:PTZByPassResult");
	if (soap_out_string(soap, "ns1:PTZByPassResult", -1, &(a->_ns1__PTZByPassResponse::PTZByPassResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__PTZByPassResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PTZByPassResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PTZByPassResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PTZByPassResponse * SOAP_FMAC4 soap_get__ns1__PTZByPassResponse(struct soap *soap, _ns1__PTZByPassResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PTZByPassResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__PTZByPassResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PTZByPassResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PTZByPassResponse * SOAP_FMAC4 soap_in__ns1__PTZByPassResponse(struct soap *soap, const char *tag, _ns1__PTZByPassResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PTZByPassResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PTZByPassResponse, sizeof(_ns1__PTZByPassResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PTZByPassResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PTZByPassResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PTZByPassResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZByPassResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:PTZByPassResult", &(a->_ns1__PTZByPassResponse::PTZByPassResult), "xsd:string"))
				{	soap_flag_PTZByPassResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__PTZByPassResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:PTZByPassResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PTZByPassResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PTZByPassResponse, 0, sizeof(_ns1__PTZByPassResponse), 0, soap_copy__ns1__PTZByPassResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__PTZByPassResponse * SOAP_FMAC4 soap_instantiate__ns1__PTZByPassResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PTZByPassResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PTZByPassResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__PTZByPassResponse;
		if (size)
			*size = sizeof(_ns1__PTZByPassResponse);
		((_ns1__PTZByPassResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__PTZByPassResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PTZByPassResponse);
		for (int i = 0; i < n; i++)
			((_ns1__PTZByPassResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PTZByPassResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PTZByPassResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PTZByPassResponse %p -> %p\n", q, p));
	*(_ns1__PTZByPassResponse*)p = *(_ns1__PTZByPassResponse*)q;
}

void _ns1__PTZByPass::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__PTZByPass::channel);
	soap_default_string(soap, &this->_ns1__PTZByPass::command);
	/* transient soap skipped */
}

void _ns1__PTZByPass::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__PTZByPass::command);
	/* transient soap skipped */
}

int _ns1__PTZByPass::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PTZByPass);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__PTZByPass::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PTZByPass(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PTZByPass(struct soap *soap, const char *tag, int id, const _ns1__PTZByPass *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PTZByPass), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__PTZByPass::channel), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:command", -1, &(a->_ns1__PTZByPass::command), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PTZByPass::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PTZByPass(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PTZByPass * SOAP_FMAC4 soap_get__ns1__PTZByPass(struct soap *soap, _ns1__PTZByPass *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PTZByPass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__PTZByPass::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PTZByPass(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PTZByPass * SOAP_FMAC4 soap_in__ns1__PTZByPass(struct soap *soap, const char *tag, _ns1__PTZByPass *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PTZByPass *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PTZByPass, sizeof(_ns1__PTZByPass), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PTZByPass)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PTZByPass *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	size_t soap_flag_command1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__PTZByPass::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			if (soap_flag_command1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:command", &(a->_ns1__PTZByPass::command), "xsd:string"))
				{	soap_flag_command1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PTZByPass *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PTZByPass, 0, sizeof(_ns1__PTZByPass), 0, soap_copy__ns1__PTZByPass);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__PTZByPass * SOAP_FMAC4 soap_instantiate__ns1__PTZByPass(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PTZByPass(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PTZByPass, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__PTZByPass;
		if (size)
			*size = sizeof(_ns1__PTZByPass);
		((_ns1__PTZByPass*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__PTZByPass[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PTZByPass);
		for (int i = 0; i < n; i++)
			((_ns1__PTZByPass*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PTZByPass*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PTZByPass(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PTZByPass %p -> %p\n", q, p));
	*(_ns1__PTZByPass*)p = *(_ns1__PTZByPass*)q;
}

void _ns1__SetPTZPortResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__SetPTZPortResponse::SetPTZPortResult);
	soap_default_int(soap, &this->_ns1__SetPTZPortResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__SetPTZPortResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__SetPTZPortResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetPTZPortResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__SetPTZPortResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetPTZPortResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetPTZPortResponse(struct soap *soap, const char *tag, int id, const _ns1__SetPTZPortResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetPTZPortResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:SetPTZPortResult");
	if (soap_out_bool(soap, "ns1:SetPTZPortResult", -1, &(a->_ns1__SetPTZPortResponse::SetPTZPortResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__SetPTZPortResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetPTZPortResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetPTZPortResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetPTZPortResponse * SOAP_FMAC4 soap_get__ns1__SetPTZPortResponse(struct soap *soap, _ns1__SetPTZPortResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetPTZPortResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__SetPTZPortResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetPTZPortResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetPTZPortResponse * SOAP_FMAC4 soap_in__ns1__SetPTZPortResponse(struct soap *soap, const char *tag, _ns1__SetPTZPortResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetPTZPortResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetPTZPortResponse, sizeof(_ns1__SetPTZPortResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetPTZPortResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetPTZPortResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SetPTZPortResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetPTZPortResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:SetPTZPortResult", &(a->_ns1__SetPTZPortResponse::SetPTZPortResult), "xsd:boolean"))
				{	soap_flag_SetPTZPortResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__SetPTZPortResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:SetPTZPortResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetPTZPortResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetPTZPortResponse, 0, sizeof(_ns1__SetPTZPortResponse), 0, soap_copy__ns1__SetPTZPortResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SetPTZPortResult1 > 0 || soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__SetPTZPortResponse * SOAP_FMAC4 soap_instantiate__ns1__SetPTZPortResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetPTZPortResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetPTZPortResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__SetPTZPortResponse;
		if (size)
			*size = sizeof(_ns1__SetPTZPortResponse);
		((_ns1__SetPTZPortResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__SetPTZPortResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SetPTZPortResponse);
		for (int i = 0; i < n; i++)
			((_ns1__SetPTZPortResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SetPTZPortResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetPTZPortResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetPTZPortResponse %p -> %p\n", q, p));
	*(_ns1__SetPTZPortResponse*)p = *(_ns1__SetPTZPortResponse*)q;
}

void _ns1__SetPTZPort::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__SetPTZPort::channel);
	this->_ns1__SetPTZPort::port = NULL;
	/* transient soap skipped */
}

void _ns1__SetPTZPort::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__PortConfig_USCORET(soap, &this->_ns1__SetPTZPort::port);
	/* transient soap skipped */
}

int _ns1__SetPTZPort::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetPTZPort);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__SetPTZPort::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetPTZPort(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetPTZPort(struct soap *soap, const char *tag, int id, const _ns1__SetPTZPort *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetPTZPort), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__SetPTZPort::channel), ""))
		return soap->error;
	if (soap_out_PointerTons1__PortConfig_USCORET(soap, "ns1:port", -1, &(a->_ns1__SetPTZPort::port), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetPTZPort::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetPTZPort(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetPTZPort * SOAP_FMAC4 soap_get__ns1__SetPTZPort(struct soap *soap, _ns1__SetPTZPort *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetPTZPort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__SetPTZPort::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetPTZPort(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetPTZPort * SOAP_FMAC4 soap_in__ns1__SetPTZPort(struct soap *soap, const char *tag, _ns1__SetPTZPort *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetPTZPort *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetPTZPort, sizeof(_ns1__SetPTZPort), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetPTZPort)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetPTZPort *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	size_t soap_flag_port1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__SetPTZPort::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			if (soap_flag_port1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PortConfig_USCORET(soap, "ns1:port", &(a->_ns1__SetPTZPort::port), "ns1:PortConfig_T"))
				{	soap_flag_port1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetPTZPort *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetPTZPort, 0, sizeof(_ns1__SetPTZPort), 0, soap_copy__ns1__SetPTZPort);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__SetPTZPort * SOAP_FMAC4 soap_instantiate__ns1__SetPTZPort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetPTZPort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetPTZPort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__SetPTZPort;
		if (size)
			*size = sizeof(_ns1__SetPTZPort);
		((_ns1__SetPTZPort*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__SetPTZPort[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SetPTZPort);
		for (int i = 0; i < n; i++)
			((_ns1__SetPTZPort*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SetPTZPort*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetPTZPort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetPTZPort %p -> %p\n", q, p));
	*(_ns1__SetPTZPort*)p = *(_ns1__SetPTZPort*)q;
}

void _ns1__GetPTZPortResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPTZPortResponse::GetPTZPortResult = NULL;
	soap_default_int(soap, &this->_ns1__GetPTZPortResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__GetPTZPortResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__PortConfig_USCORET(soap, &this->_ns1__GetPTZPortResponse::GetPTZPortResult);
	/* transient soap skipped */
}

int _ns1__GetPTZPortResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPTZPortResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetPTZPortResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPTZPortResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPTZPortResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPTZPortResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPTZPortResponse), type))
		return soap->error;
	if (a->GetPTZPortResult)
		soap_element_result(soap, "ns1:GetPTZPortResult");
	if (soap_out_PointerTons1__PortConfig_USCORET(soap, "ns1:GetPTZPortResult", -1, &(a->_ns1__GetPTZPortResponse::GetPTZPortResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__GetPTZPortResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPTZPortResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPTZPortResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPTZPortResponse * SOAP_FMAC4 soap_get__ns1__GetPTZPortResponse(struct soap *soap, _ns1__GetPTZPortResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPTZPortResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetPTZPortResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPTZPortResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPTZPortResponse * SOAP_FMAC4 soap_in__ns1__GetPTZPortResponse(struct soap *soap, const char *tag, _ns1__GetPTZPortResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPTZPortResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPTZPortResponse, sizeof(_ns1__GetPTZPortResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPTZPortResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPTZPortResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPTZPortResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPTZPortResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PortConfig_USCORET(soap, "ns1:GetPTZPortResult", &(a->_ns1__GetPTZPortResponse::GetPTZPortResult), "ns1:PortConfig_T"))
				{	soap_flag_GetPTZPortResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__GetPTZPortResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPTZPortResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPTZPortResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPTZPortResponse, 0, sizeof(_ns1__GetPTZPortResponse), 0, soap_copy__ns1__GetPTZPortResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetPTZPortResponse * SOAP_FMAC4 soap_instantiate__ns1__GetPTZPortResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPTZPortResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPTZPortResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetPTZPortResponse;
		if (size)
			*size = sizeof(_ns1__GetPTZPortResponse);
		((_ns1__GetPTZPortResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetPTZPortResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPTZPortResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPTZPortResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPTZPortResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPTZPortResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPTZPortResponse %p -> %p\n", q, p));
	*(_ns1__GetPTZPortResponse*)p = *(_ns1__GetPTZPortResponse*)q;
}

void _ns1__GetPTZPort::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetPTZPort::channel);
	/* transient soap skipped */
}

void _ns1__GetPTZPort::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__GetPTZPort::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPTZPort);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetPTZPort::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPTZPort(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPTZPort(struct soap *soap, const char *tag, int id, const _ns1__GetPTZPort *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPTZPort), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__GetPTZPort::channel), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPTZPort::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPTZPort(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPTZPort * SOAP_FMAC4 soap_get__ns1__GetPTZPort(struct soap *soap, _ns1__GetPTZPort *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPTZPort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetPTZPort::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPTZPort(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPTZPort * SOAP_FMAC4 soap_in__ns1__GetPTZPort(struct soap *soap, const char *tag, _ns1__GetPTZPort *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPTZPort *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPTZPort, sizeof(_ns1__GetPTZPort), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPTZPort)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPTZPort *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__GetPTZPort::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPTZPort *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPTZPort, 0, sizeof(_ns1__GetPTZPort), 0, soap_copy__ns1__GetPTZPort);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetPTZPort * SOAP_FMAC4 soap_instantiate__ns1__GetPTZPort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPTZPort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPTZPort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetPTZPort;
		if (size)
			*size = sizeof(_ns1__GetPTZPort);
		((_ns1__GetPTZPort*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetPTZPort[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPTZPort);
		for (int i = 0; i < n; i++)
			((_ns1__GetPTZPort*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPTZPort*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPTZPort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPTZPort %p -> %p\n", q, p));
	*(_ns1__GetPTZPort*)p = *(_ns1__GetPTZPort*)q;
}

void _ns1__SetPTZConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__SetPTZConfigurationResponse::SetPTZConfigurationResult);
	soap_default_int(soap, &this->_ns1__SetPTZConfigurationResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__SetPTZConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__SetPTZConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetPTZConfigurationResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__SetPTZConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetPTZConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetPTZConfigurationResponse(struct soap *soap, const char *tag, int id, const _ns1__SetPTZConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetPTZConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:SetPTZConfigurationResult");
	if (soap_out_bool(soap, "ns1:SetPTZConfigurationResult", -1, &(a->_ns1__SetPTZConfigurationResponse::SetPTZConfigurationResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__SetPTZConfigurationResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetPTZConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetPTZConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetPTZConfigurationResponse * SOAP_FMAC4 soap_get__ns1__SetPTZConfigurationResponse(struct soap *soap, _ns1__SetPTZConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetPTZConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__SetPTZConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetPTZConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetPTZConfigurationResponse * SOAP_FMAC4 soap_in__ns1__SetPTZConfigurationResponse(struct soap *soap, const char *tag, _ns1__SetPTZConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetPTZConfigurationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetPTZConfigurationResponse, sizeof(_ns1__SetPTZConfigurationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetPTZConfigurationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetPTZConfigurationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SetPTZConfigurationResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetPTZConfigurationResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:SetPTZConfigurationResult", &(a->_ns1__SetPTZConfigurationResponse::SetPTZConfigurationResult), "xsd:boolean"))
				{	soap_flag_SetPTZConfigurationResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__SetPTZConfigurationResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:SetPTZConfigurationResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetPTZConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetPTZConfigurationResponse, 0, sizeof(_ns1__SetPTZConfigurationResponse), 0, soap_copy__ns1__SetPTZConfigurationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SetPTZConfigurationResult1 > 0 || soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__SetPTZConfigurationResponse * SOAP_FMAC4 soap_instantiate__ns1__SetPTZConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetPTZConfigurationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetPTZConfigurationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__SetPTZConfigurationResponse;
		if (size)
			*size = sizeof(_ns1__SetPTZConfigurationResponse);
		((_ns1__SetPTZConfigurationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__SetPTZConfigurationResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SetPTZConfigurationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__SetPTZConfigurationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SetPTZConfigurationResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetPTZConfigurationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetPTZConfigurationResponse %p -> %p\n", q, p));
	*(_ns1__SetPTZConfigurationResponse*)p = *(_ns1__SetPTZConfigurationResponse*)q;
}

void _ns1__SetPTZConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__SetPTZConfiguration::channel);
	this->_ns1__SetPTZConfiguration::param = NULL;
	/* transient soap skipped */
}

void _ns1__SetPTZConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfParameter_USCORET(soap, &this->_ns1__SetPTZConfiguration::param);
	/* transient soap skipped */
}

int _ns1__SetPTZConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetPTZConfiguration);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__SetPTZConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetPTZConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetPTZConfiguration(struct soap *soap, const char *tag, int id, const _ns1__SetPTZConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetPTZConfiguration), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__SetPTZConfiguration::channel), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfParameter_USCORET(soap, "ns1:param", -1, &(a->_ns1__SetPTZConfiguration::param), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetPTZConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetPTZConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetPTZConfiguration * SOAP_FMAC4 soap_get__ns1__SetPTZConfiguration(struct soap *soap, _ns1__SetPTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetPTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__SetPTZConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetPTZConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetPTZConfiguration * SOAP_FMAC4 soap_in__ns1__SetPTZConfiguration(struct soap *soap, const char *tag, _ns1__SetPTZConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetPTZConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetPTZConfiguration, sizeof(_ns1__SetPTZConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetPTZConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetPTZConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	size_t soap_flag_param1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__SetPTZConfiguration::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			if (soap_flag_param1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfParameter_USCORET(soap, "ns1:param", &(a->_ns1__SetPTZConfiguration::param), "ns1:ArrayOfParameter_T"))
				{	soap_flag_param1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetPTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetPTZConfiguration, 0, sizeof(_ns1__SetPTZConfiguration), 0, soap_copy__ns1__SetPTZConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__SetPTZConfiguration * SOAP_FMAC4 soap_instantiate__ns1__SetPTZConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetPTZConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetPTZConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__SetPTZConfiguration;
		if (size)
			*size = sizeof(_ns1__SetPTZConfiguration);
		((_ns1__SetPTZConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__SetPTZConfiguration[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SetPTZConfiguration);
		for (int i = 0; i < n; i++)
			((_ns1__SetPTZConfiguration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SetPTZConfiguration*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetPTZConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetPTZConfiguration %p -> %p\n", q, p));
	*(_ns1__SetPTZConfiguration*)p = *(_ns1__SetPTZConfiguration*)q;
}

void _ns1__GetPTZConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPTZConfigurationResponse::GetPTZConfigurationResult = NULL;
	soap_default_int(soap, &this->_ns1__GetPTZConfigurationResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__GetPTZConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfParameter_USCORET(soap, &this->_ns1__GetPTZConfigurationResponse::GetPTZConfigurationResult);
	/* transient soap skipped */
}

int _ns1__GetPTZConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPTZConfigurationResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetPTZConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPTZConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPTZConfigurationResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPTZConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPTZConfigurationResponse), type))
		return soap->error;
	if (a->GetPTZConfigurationResult)
		soap_element_result(soap, "ns1:GetPTZConfigurationResult");
	if (soap_out_PointerTons1__ArrayOfParameter_USCORET(soap, "ns1:GetPTZConfigurationResult", -1, &(a->_ns1__GetPTZConfigurationResponse::GetPTZConfigurationResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__GetPTZConfigurationResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPTZConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPTZConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPTZConfigurationResponse * SOAP_FMAC4 soap_get__ns1__GetPTZConfigurationResponse(struct soap *soap, _ns1__GetPTZConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPTZConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetPTZConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPTZConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPTZConfigurationResponse * SOAP_FMAC4 soap_in__ns1__GetPTZConfigurationResponse(struct soap *soap, const char *tag, _ns1__GetPTZConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPTZConfigurationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPTZConfigurationResponse, sizeof(_ns1__GetPTZConfigurationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPTZConfigurationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPTZConfigurationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPTZConfigurationResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPTZConfigurationResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfParameter_USCORET(soap, "ns1:GetPTZConfigurationResult", &(a->_ns1__GetPTZConfigurationResponse::GetPTZConfigurationResult), "ns1:ArrayOfParameter_T"))
				{	soap_flag_GetPTZConfigurationResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__GetPTZConfigurationResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPTZConfigurationResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPTZConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPTZConfigurationResponse, 0, sizeof(_ns1__GetPTZConfigurationResponse), 0, soap_copy__ns1__GetPTZConfigurationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetPTZConfigurationResponse * SOAP_FMAC4 soap_instantiate__ns1__GetPTZConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPTZConfigurationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPTZConfigurationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetPTZConfigurationResponse;
		if (size)
			*size = sizeof(_ns1__GetPTZConfigurationResponse);
		((_ns1__GetPTZConfigurationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetPTZConfigurationResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPTZConfigurationResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPTZConfigurationResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPTZConfigurationResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPTZConfigurationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPTZConfigurationResponse %p -> %p\n", q, p));
	*(_ns1__GetPTZConfigurationResponse*)p = *(_ns1__GetPTZConfigurationResponse*)q;
}

void _ns1__GetPTZConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetPTZConfiguration::channel);
	/* transient soap skipped */
}

void _ns1__GetPTZConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__GetPTZConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPTZConfiguration);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetPTZConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPTZConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPTZConfiguration(struct soap *soap, const char *tag, int id, const _ns1__GetPTZConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPTZConfiguration), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__GetPTZConfiguration::channel), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPTZConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPTZConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPTZConfiguration * SOAP_FMAC4 soap_get__ns1__GetPTZConfiguration(struct soap *soap, _ns1__GetPTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetPTZConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPTZConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPTZConfiguration * SOAP_FMAC4 soap_in__ns1__GetPTZConfiguration(struct soap *soap, const char *tag, _ns1__GetPTZConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPTZConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPTZConfiguration, sizeof(_ns1__GetPTZConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPTZConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPTZConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__GetPTZConfiguration::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPTZConfiguration, 0, sizeof(_ns1__GetPTZConfiguration), 0, soap_copy__ns1__GetPTZConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetPTZConfiguration * SOAP_FMAC4 soap_instantiate__ns1__GetPTZConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPTZConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPTZConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetPTZConfiguration;
		if (size)
			*size = sizeof(_ns1__GetPTZConfiguration);
		((_ns1__GetPTZConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetPTZConfiguration[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPTZConfiguration);
		for (int i = 0; i < n; i++)
			((_ns1__GetPTZConfiguration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPTZConfiguration*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPTZConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPTZConfiguration %p -> %p\n", q, p));
	*(_ns1__GetPTZConfiguration*)p = *(_ns1__GetPTZConfiguration*)q;
}

void _ns1__StopRecordedPatternResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__StopRecordedPatternResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__StopRecordedPatternResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__StopRecordedPatternResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__StopRecordedPatternResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__StopRecordedPatternResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StopRecordedPatternResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StopRecordedPatternResponse(struct soap *soap, const char *tag, int id, const _ns1__StopRecordedPatternResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StopRecordedPatternResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:resultCode");
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__StopRecordedPatternResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__StopRecordedPatternResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StopRecordedPatternResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StopRecordedPatternResponse * SOAP_FMAC4 soap_get__ns1__StopRecordedPatternResponse(struct soap *soap, _ns1__StopRecordedPatternResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StopRecordedPatternResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__StopRecordedPatternResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StopRecordedPatternResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StopRecordedPatternResponse * SOAP_FMAC4 soap_in__ns1__StopRecordedPatternResponse(struct soap *soap, const char *tag, _ns1__StopRecordedPatternResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StopRecordedPatternResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StopRecordedPatternResponse, sizeof(_ns1__StopRecordedPatternResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__StopRecordedPatternResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__StopRecordedPatternResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__StopRecordedPatternResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:resultCode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__StopRecordedPatternResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StopRecordedPatternResponse, 0, sizeof(_ns1__StopRecordedPatternResponse), 0, soap_copy__ns1__StopRecordedPatternResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__StopRecordedPatternResponse * SOAP_FMAC4 soap_instantiate__ns1__StopRecordedPatternResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StopRecordedPatternResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__StopRecordedPatternResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__StopRecordedPatternResponse;
		if (size)
			*size = sizeof(_ns1__StopRecordedPatternResponse);
		((_ns1__StopRecordedPatternResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__StopRecordedPatternResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__StopRecordedPatternResponse);
		for (int i = 0; i < n; i++)
			((_ns1__StopRecordedPatternResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__StopRecordedPatternResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__StopRecordedPatternResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__StopRecordedPatternResponse %p -> %p\n", q, p));
	*(_ns1__StopRecordedPatternResponse*)p = *(_ns1__StopRecordedPatternResponse*)q;
}

void _ns1__StopRecordedPattern::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__StopRecordedPattern::channel);
	/* transient soap skipped */
}

void _ns1__StopRecordedPattern::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__StopRecordedPattern::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__StopRecordedPattern);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__StopRecordedPattern::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StopRecordedPattern(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StopRecordedPattern(struct soap *soap, const char *tag, int id, const _ns1__StopRecordedPattern *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StopRecordedPattern), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__StopRecordedPattern::channel), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__StopRecordedPattern::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StopRecordedPattern(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StopRecordedPattern * SOAP_FMAC4 soap_get__ns1__StopRecordedPattern(struct soap *soap, _ns1__StopRecordedPattern *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StopRecordedPattern(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__StopRecordedPattern::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StopRecordedPattern(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StopRecordedPattern * SOAP_FMAC4 soap_in__ns1__StopRecordedPattern(struct soap *soap, const char *tag, _ns1__StopRecordedPattern *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StopRecordedPattern *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StopRecordedPattern, sizeof(_ns1__StopRecordedPattern), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__StopRecordedPattern)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__StopRecordedPattern *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__StopRecordedPattern::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__StopRecordedPattern *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StopRecordedPattern, 0, sizeof(_ns1__StopRecordedPattern), 0, soap_copy__ns1__StopRecordedPattern);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__StopRecordedPattern * SOAP_FMAC4 soap_instantiate__ns1__StopRecordedPattern(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StopRecordedPattern(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__StopRecordedPattern, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__StopRecordedPattern;
		if (size)
			*size = sizeof(_ns1__StopRecordedPattern);
		((_ns1__StopRecordedPattern*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__StopRecordedPattern[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__StopRecordedPattern);
		for (int i = 0; i < n; i++)
			((_ns1__StopRecordedPattern*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__StopRecordedPattern*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__StopRecordedPattern(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__StopRecordedPattern %p -> %p\n", q, p));
	*(_ns1__StopRecordedPattern*)p = *(_ns1__StopRecordedPattern*)q;
}

void _ns1__PlayRecordedPatternResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__PlayRecordedPatternResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__PlayRecordedPatternResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__PlayRecordedPatternResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PlayRecordedPatternResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__PlayRecordedPatternResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PlayRecordedPatternResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PlayRecordedPatternResponse(struct soap *soap, const char *tag, int id, const _ns1__PlayRecordedPatternResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PlayRecordedPatternResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:resultCode");
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__PlayRecordedPatternResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PlayRecordedPatternResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PlayRecordedPatternResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PlayRecordedPatternResponse * SOAP_FMAC4 soap_get__ns1__PlayRecordedPatternResponse(struct soap *soap, _ns1__PlayRecordedPatternResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PlayRecordedPatternResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__PlayRecordedPatternResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PlayRecordedPatternResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PlayRecordedPatternResponse * SOAP_FMAC4 soap_in__ns1__PlayRecordedPatternResponse(struct soap *soap, const char *tag, _ns1__PlayRecordedPatternResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PlayRecordedPatternResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PlayRecordedPatternResponse, sizeof(_ns1__PlayRecordedPatternResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PlayRecordedPatternResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PlayRecordedPatternResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__PlayRecordedPatternResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:resultCode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PlayRecordedPatternResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PlayRecordedPatternResponse, 0, sizeof(_ns1__PlayRecordedPatternResponse), 0, soap_copy__ns1__PlayRecordedPatternResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__PlayRecordedPatternResponse * SOAP_FMAC4 soap_instantiate__ns1__PlayRecordedPatternResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PlayRecordedPatternResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PlayRecordedPatternResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__PlayRecordedPatternResponse;
		if (size)
			*size = sizeof(_ns1__PlayRecordedPatternResponse);
		((_ns1__PlayRecordedPatternResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__PlayRecordedPatternResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PlayRecordedPatternResponse);
		for (int i = 0; i < n; i++)
			((_ns1__PlayRecordedPatternResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PlayRecordedPatternResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PlayRecordedPatternResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PlayRecordedPatternResponse %p -> %p\n", q, p));
	*(_ns1__PlayRecordedPatternResponse*)p = *(_ns1__PlayRecordedPatternResponse*)q;
}

void _ns1__PlayRecordedPattern::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__PlayRecordedPattern::channel);
	/* transient soap skipped */
}

void _ns1__PlayRecordedPattern::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__PlayRecordedPattern::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PlayRecordedPattern);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__PlayRecordedPattern::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PlayRecordedPattern(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PlayRecordedPattern(struct soap *soap, const char *tag, int id, const _ns1__PlayRecordedPattern *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PlayRecordedPattern), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__PlayRecordedPattern::channel), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PlayRecordedPattern::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PlayRecordedPattern(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PlayRecordedPattern * SOAP_FMAC4 soap_get__ns1__PlayRecordedPattern(struct soap *soap, _ns1__PlayRecordedPattern *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PlayRecordedPattern(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__PlayRecordedPattern::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PlayRecordedPattern(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PlayRecordedPattern * SOAP_FMAC4 soap_in__ns1__PlayRecordedPattern(struct soap *soap, const char *tag, _ns1__PlayRecordedPattern *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PlayRecordedPattern *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PlayRecordedPattern, sizeof(_ns1__PlayRecordedPattern), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PlayRecordedPattern)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PlayRecordedPattern *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__PlayRecordedPattern::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PlayRecordedPattern *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PlayRecordedPattern, 0, sizeof(_ns1__PlayRecordedPattern), 0, soap_copy__ns1__PlayRecordedPattern);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__PlayRecordedPattern * SOAP_FMAC4 soap_instantiate__ns1__PlayRecordedPattern(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PlayRecordedPattern(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PlayRecordedPattern, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__PlayRecordedPattern;
		if (size)
			*size = sizeof(_ns1__PlayRecordedPattern);
		((_ns1__PlayRecordedPattern*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__PlayRecordedPattern[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PlayRecordedPattern);
		for (int i = 0; i < n; i++)
			((_ns1__PlayRecordedPattern*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PlayRecordedPattern*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PlayRecordedPattern(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PlayRecordedPattern %p -> %p\n", q, p));
	*(_ns1__PlayRecordedPattern*)p = *(_ns1__PlayRecordedPattern*)q;
}

void _ns1__StopPatternRecordingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__StopPatternRecordingResponse::StopPatternRecordingResult);
	soap_default_int(soap, &this->_ns1__StopPatternRecordingResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__StopPatternRecordingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__StopPatternRecordingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__StopPatternRecordingResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__StopPatternRecordingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StopPatternRecordingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StopPatternRecordingResponse(struct soap *soap, const char *tag, int id, const _ns1__StopPatternRecordingResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StopPatternRecordingResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:StopPatternRecordingResult");
	if (soap_out_bool(soap, "ns1:StopPatternRecordingResult", -1, &(a->_ns1__StopPatternRecordingResponse::StopPatternRecordingResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__StopPatternRecordingResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__StopPatternRecordingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StopPatternRecordingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StopPatternRecordingResponse * SOAP_FMAC4 soap_get__ns1__StopPatternRecordingResponse(struct soap *soap, _ns1__StopPatternRecordingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StopPatternRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__StopPatternRecordingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StopPatternRecordingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StopPatternRecordingResponse * SOAP_FMAC4 soap_in__ns1__StopPatternRecordingResponse(struct soap *soap, const char *tag, _ns1__StopPatternRecordingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StopPatternRecordingResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StopPatternRecordingResponse, sizeof(_ns1__StopPatternRecordingResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__StopPatternRecordingResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__StopPatternRecordingResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_StopPatternRecordingResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StopPatternRecordingResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:StopPatternRecordingResult", &(a->_ns1__StopPatternRecordingResponse::StopPatternRecordingResult), "xsd:boolean"))
				{	soap_flag_StopPatternRecordingResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__StopPatternRecordingResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:StopPatternRecordingResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__StopPatternRecordingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StopPatternRecordingResponse, 0, sizeof(_ns1__StopPatternRecordingResponse), 0, soap_copy__ns1__StopPatternRecordingResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StopPatternRecordingResult1 > 0 || soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__StopPatternRecordingResponse * SOAP_FMAC4 soap_instantiate__ns1__StopPatternRecordingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StopPatternRecordingResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__StopPatternRecordingResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__StopPatternRecordingResponse;
		if (size)
			*size = sizeof(_ns1__StopPatternRecordingResponse);
		((_ns1__StopPatternRecordingResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__StopPatternRecordingResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__StopPatternRecordingResponse);
		for (int i = 0; i < n; i++)
			((_ns1__StopPatternRecordingResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__StopPatternRecordingResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__StopPatternRecordingResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__StopPatternRecordingResponse %p -> %p\n", q, p));
	*(_ns1__StopPatternRecordingResponse*)p = *(_ns1__StopPatternRecordingResponse*)q;
}

void _ns1__StopPatternRecording::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__StopPatternRecording::channel);
	/* transient soap skipped */
}

void _ns1__StopPatternRecording::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__StopPatternRecording::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__StopPatternRecording);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__StopPatternRecording::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StopPatternRecording(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StopPatternRecording(struct soap *soap, const char *tag, int id, const _ns1__StopPatternRecording *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StopPatternRecording), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__StopPatternRecording::channel), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__StopPatternRecording::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StopPatternRecording(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StopPatternRecording * SOAP_FMAC4 soap_get__ns1__StopPatternRecording(struct soap *soap, _ns1__StopPatternRecording *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StopPatternRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__StopPatternRecording::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StopPatternRecording(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StopPatternRecording * SOAP_FMAC4 soap_in__ns1__StopPatternRecording(struct soap *soap, const char *tag, _ns1__StopPatternRecording *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StopPatternRecording *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StopPatternRecording, sizeof(_ns1__StopPatternRecording), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__StopPatternRecording)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__StopPatternRecording *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__StopPatternRecording::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__StopPatternRecording *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StopPatternRecording, 0, sizeof(_ns1__StopPatternRecording), 0, soap_copy__ns1__StopPatternRecording);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__StopPatternRecording * SOAP_FMAC4 soap_instantiate__ns1__StopPatternRecording(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StopPatternRecording(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__StopPatternRecording, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__StopPatternRecording;
		if (size)
			*size = sizeof(_ns1__StopPatternRecording);
		((_ns1__StopPatternRecording*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__StopPatternRecording[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__StopPatternRecording);
		for (int i = 0; i < n; i++)
			((_ns1__StopPatternRecording*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__StopPatternRecording*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__StopPatternRecording(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__StopPatternRecording %p -> %p\n", q, p));
	*(_ns1__StopPatternRecording*)p = *(_ns1__StopPatternRecording*)q;
}

void _ns1__StartPatternRecordingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__StartPatternRecordingResponse::StartPatternRecordingResult);
	soap_default_int(soap, &this->_ns1__StartPatternRecordingResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__StartPatternRecordingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__StartPatternRecordingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__StartPatternRecordingResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__StartPatternRecordingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StartPatternRecordingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StartPatternRecordingResponse(struct soap *soap, const char *tag, int id, const _ns1__StartPatternRecordingResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StartPatternRecordingResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:StartPatternRecordingResult");
	if (soap_out_bool(soap, "ns1:StartPatternRecordingResult", -1, &(a->_ns1__StartPatternRecordingResponse::StartPatternRecordingResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__StartPatternRecordingResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__StartPatternRecordingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StartPatternRecordingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StartPatternRecordingResponse * SOAP_FMAC4 soap_get__ns1__StartPatternRecordingResponse(struct soap *soap, _ns1__StartPatternRecordingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StartPatternRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__StartPatternRecordingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StartPatternRecordingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StartPatternRecordingResponse * SOAP_FMAC4 soap_in__ns1__StartPatternRecordingResponse(struct soap *soap, const char *tag, _ns1__StartPatternRecordingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StartPatternRecordingResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StartPatternRecordingResponse, sizeof(_ns1__StartPatternRecordingResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__StartPatternRecordingResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__StartPatternRecordingResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_StartPatternRecordingResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartPatternRecordingResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:StartPatternRecordingResult", &(a->_ns1__StartPatternRecordingResponse::StartPatternRecordingResult), "xsd:boolean"))
				{	soap_flag_StartPatternRecordingResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__StartPatternRecordingResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:StartPatternRecordingResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__StartPatternRecordingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StartPatternRecordingResponse, 0, sizeof(_ns1__StartPatternRecordingResponse), 0, soap_copy__ns1__StartPatternRecordingResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartPatternRecordingResult1 > 0 || soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__StartPatternRecordingResponse * SOAP_FMAC4 soap_instantiate__ns1__StartPatternRecordingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StartPatternRecordingResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__StartPatternRecordingResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__StartPatternRecordingResponse;
		if (size)
			*size = sizeof(_ns1__StartPatternRecordingResponse);
		((_ns1__StartPatternRecordingResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__StartPatternRecordingResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__StartPatternRecordingResponse);
		for (int i = 0; i < n; i++)
			((_ns1__StartPatternRecordingResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__StartPatternRecordingResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__StartPatternRecordingResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__StartPatternRecordingResponse %p -> %p\n", q, p));
	*(_ns1__StartPatternRecordingResponse*)p = *(_ns1__StartPatternRecordingResponse*)q;
}

void _ns1__StartPatternRecording::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__StartPatternRecording::channel);
	/* transient soap skipped */
}

void _ns1__StartPatternRecording::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__StartPatternRecording::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__StartPatternRecording);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__StartPatternRecording::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StartPatternRecording(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StartPatternRecording(struct soap *soap, const char *tag, int id, const _ns1__StartPatternRecording *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StartPatternRecording), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__StartPatternRecording::channel), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__StartPatternRecording::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StartPatternRecording(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StartPatternRecording * SOAP_FMAC4 soap_get__ns1__StartPatternRecording(struct soap *soap, _ns1__StartPatternRecording *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StartPatternRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__StartPatternRecording::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StartPatternRecording(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StartPatternRecording * SOAP_FMAC4 soap_in__ns1__StartPatternRecording(struct soap *soap, const char *tag, _ns1__StartPatternRecording *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StartPatternRecording *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StartPatternRecording, sizeof(_ns1__StartPatternRecording), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__StartPatternRecording)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__StartPatternRecording *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__StartPatternRecording::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__StartPatternRecording *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StartPatternRecording, 0, sizeof(_ns1__StartPatternRecording), 0, soap_copy__ns1__StartPatternRecording);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__StartPatternRecording * SOAP_FMAC4 soap_instantiate__ns1__StartPatternRecording(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StartPatternRecording(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__StartPatternRecording, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__StartPatternRecording;
		if (size)
			*size = sizeof(_ns1__StartPatternRecording);
		((_ns1__StartPatternRecording*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__StartPatternRecording[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__StartPatternRecording);
		for (int i = 0; i < n; i++)
			((_ns1__StartPatternRecording*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__StartPatternRecording*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__StartPatternRecording(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__StartPatternRecording %p -> %p\n", q, p));
	*(_ns1__StartPatternRecording*)p = *(_ns1__StartPatternRecording*)q;
}

void _ns1__StopPresetTourResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__StopPresetTourResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__StopPresetTourResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__StopPresetTourResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__StopPresetTourResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__StopPresetTourResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StopPresetTourResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StopPresetTourResponse(struct soap *soap, const char *tag, int id, const _ns1__StopPresetTourResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StopPresetTourResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:resultCode");
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__StopPresetTourResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__StopPresetTourResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StopPresetTourResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StopPresetTourResponse * SOAP_FMAC4 soap_get__ns1__StopPresetTourResponse(struct soap *soap, _ns1__StopPresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StopPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__StopPresetTourResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StopPresetTourResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StopPresetTourResponse * SOAP_FMAC4 soap_in__ns1__StopPresetTourResponse(struct soap *soap, const char *tag, _ns1__StopPresetTourResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StopPresetTourResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StopPresetTourResponse, sizeof(_ns1__StopPresetTourResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__StopPresetTourResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__StopPresetTourResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__StopPresetTourResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:resultCode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__StopPresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StopPresetTourResponse, 0, sizeof(_ns1__StopPresetTourResponse), 0, soap_copy__ns1__StopPresetTourResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__StopPresetTourResponse * SOAP_FMAC4 soap_instantiate__ns1__StopPresetTourResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StopPresetTourResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__StopPresetTourResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__StopPresetTourResponse;
		if (size)
			*size = sizeof(_ns1__StopPresetTourResponse);
		((_ns1__StopPresetTourResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__StopPresetTourResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__StopPresetTourResponse);
		for (int i = 0; i < n; i++)
			((_ns1__StopPresetTourResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__StopPresetTourResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__StopPresetTourResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__StopPresetTourResponse %p -> %p\n", q, p));
	*(_ns1__StopPresetTourResponse*)p = *(_ns1__StopPresetTourResponse*)q;
}

void _ns1__StopPresetTour::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__StopPresetTour::channel);
	/* transient soap skipped */
}

void _ns1__StopPresetTour::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__StopPresetTour::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__StopPresetTour);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__StopPresetTour::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StopPresetTour(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StopPresetTour(struct soap *soap, const char *tag, int id, const _ns1__StopPresetTour *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StopPresetTour), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__StopPresetTour::channel), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__StopPresetTour::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StopPresetTour(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StopPresetTour * SOAP_FMAC4 soap_get__ns1__StopPresetTour(struct soap *soap, _ns1__StopPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StopPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__StopPresetTour::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StopPresetTour(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StopPresetTour * SOAP_FMAC4 soap_in__ns1__StopPresetTour(struct soap *soap, const char *tag, _ns1__StopPresetTour *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StopPresetTour *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StopPresetTour, sizeof(_ns1__StopPresetTour), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__StopPresetTour)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__StopPresetTour *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__StopPresetTour::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__StopPresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StopPresetTour, 0, sizeof(_ns1__StopPresetTour), 0, soap_copy__ns1__StopPresetTour);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__StopPresetTour * SOAP_FMAC4 soap_instantiate__ns1__StopPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StopPresetTour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__StopPresetTour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__StopPresetTour;
		if (size)
			*size = sizeof(_ns1__StopPresetTour);
		((_ns1__StopPresetTour*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__StopPresetTour[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__StopPresetTour);
		for (int i = 0; i < n; i++)
			((_ns1__StopPresetTour*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__StopPresetTour*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__StopPresetTour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__StopPresetTour %p -> %p\n", q, p));
	*(_ns1__StopPresetTour*)p = *(_ns1__StopPresetTour*)q;
}

void _ns1__PlayPresetTourResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__PlayPresetTourResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__PlayPresetTourResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__PlayPresetTourResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PlayPresetTourResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__PlayPresetTourResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PlayPresetTourResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PlayPresetTourResponse(struct soap *soap, const char *tag, int id, const _ns1__PlayPresetTourResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PlayPresetTourResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:resultCode");
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__PlayPresetTourResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PlayPresetTourResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PlayPresetTourResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PlayPresetTourResponse * SOAP_FMAC4 soap_get__ns1__PlayPresetTourResponse(struct soap *soap, _ns1__PlayPresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PlayPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__PlayPresetTourResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PlayPresetTourResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PlayPresetTourResponse * SOAP_FMAC4 soap_in__ns1__PlayPresetTourResponse(struct soap *soap, const char *tag, _ns1__PlayPresetTourResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PlayPresetTourResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PlayPresetTourResponse, sizeof(_ns1__PlayPresetTourResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PlayPresetTourResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PlayPresetTourResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__PlayPresetTourResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:resultCode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PlayPresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PlayPresetTourResponse, 0, sizeof(_ns1__PlayPresetTourResponse), 0, soap_copy__ns1__PlayPresetTourResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__PlayPresetTourResponse * SOAP_FMAC4 soap_instantiate__ns1__PlayPresetTourResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PlayPresetTourResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PlayPresetTourResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__PlayPresetTourResponse;
		if (size)
			*size = sizeof(_ns1__PlayPresetTourResponse);
		((_ns1__PlayPresetTourResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__PlayPresetTourResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PlayPresetTourResponse);
		for (int i = 0; i < n; i++)
			((_ns1__PlayPresetTourResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PlayPresetTourResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PlayPresetTourResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PlayPresetTourResponse %p -> %p\n", q, p));
	*(_ns1__PlayPresetTourResponse*)p = *(_ns1__PlayPresetTourResponse*)q;
}

void _ns1__PlayPresetTour::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__PlayPresetTour::channel);
	/* transient soap skipped */
}

void _ns1__PlayPresetTour::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__PlayPresetTour::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PlayPresetTour);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__PlayPresetTour::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PlayPresetTour(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PlayPresetTour(struct soap *soap, const char *tag, int id, const _ns1__PlayPresetTour *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PlayPresetTour), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__PlayPresetTour::channel), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PlayPresetTour::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PlayPresetTour(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PlayPresetTour * SOAP_FMAC4 soap_get__ns1__PlayPresetTour(struct soap *soap, _ns1__PlayPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PlayPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__PlayPresetTour::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PlayPresetTour(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PlayPresetTour * SOAP_FMAC4 soap_in__ns1__PlayPresetTour(struct soap *soap, const char *tag, _ns1__PlayPresetTour *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PlayPresetTour *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PlayPresetTour, sizeof(_ns1__PlayPresetTour), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PlayPresetTour)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PlayPresetTour *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__PlayPresetTour::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PlayPresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PlayPresetTour, 0, sizeof(_ns1__PlayPresetTour), 0, soap_copy__ns1__PlayPresetTour);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__PlayPresetTour * SOAP_FMAC4 soap_instantiate__ns1__PlayPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PlayPresetTour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PlayPresetTour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__PlayPresetTour;
		if (size)
			*size = sizeof(_ns1__PlayPresetTour);
		((_ns1__PlayPresetTour*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__PlayPresetTour[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PlayPresetTour);
		for (int i = 0; i < n; i++)
			((_ns1__PlayPresetTour*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PlayPresetTour*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PlayPresetTour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PlayPresetTour %p -> %p\n", q, p));
	*(_ns1__PlayPresetTour*)p = *(_ns1__PlayPresetTour*)q;
}

void _ns1__SetPresetTourResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__SetPresetTourResponse::SetPresetTourResult);
	soap_default_int(soap, &this->_ns1__SetPresetTourResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__SetPresetTourResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__SetPresetTourResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetPresetTourResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__SetPresetTourResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetPresetTourResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetPresetTourResponse(struct soap *soap, const char *tag, int id, const _ns1__SetPresetTourResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetPresetTourResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:SetPresetTourResult");
	if (soap_out_bool(soap, "ns1:SetPresetTourResult", -1, &(a->_ns1__SetPresetTourResponse::SetPresetTourResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__SetPresetTourResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetPresetTourResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetPresetTourResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetPresetTourResponse * SOAP_FMAC4 soap_get__ns1__SetPresetTourResponse(struct soap *soap, _ns1__SetPresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__SetPresetTourResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetPresetTourResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetPresetTourResponse * SOAP_FMAC4 soap_in__ns1__SetPresetTourResponse(struct soap *soap, const char *tag, _ns1__SetPresetTourResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetPresetTourResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetPresetTourResponse, sizeof(_ns1__SetPresetTourResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetPresetTourResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetPresetTourResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SetPresetTourResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetPresetTourResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:SetPresetTourResult", &(a->_ns1__SetPresetTourResponse::SetPresetTourResult), "xsd:boolean"))
				{	soap_flag_SetPresetTourResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__SetPresetTourResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:SetPresetTourResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetPresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetPresetTourResponse, 0, sizeof(_ns1__SetPresetTourResponse), 0, soap_copy__ns1__SetPresetTourResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SetPresetTourResult1 > 0 || soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__SetPresetTourResponse * SOAP_FMAC4 soap_instantiate__ns1__SetPresetTourResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetPresetTourResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetPresetTourResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__SetPresetTourResponse;
		if (size)
			*size = sizeof(_ns1__SetPresetTourResponse);
		((_ns1__SetPresetTourResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__SetPresetTourResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SetPresetTourResponse);
		for (int i = 0; i < n; i++)
			((_ns1__SetPresetTourResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SetPresetTourResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetPresetTourResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetPresetTourResponse %p -> %p\n", q, p));
	*(_ns1__SetPresetTourResponse*)p = *(_ns1__SetPresetTourResponse*)q;
}

void _ns1__SetPresetTour::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__SetPresetTour::channel);
	this->_ns1__SetPresetTour::presetList = NULL;
	/* transient soap skipped */
}

void _ns1__SetPresetTour::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPreset_USCORET(soap, &this->_ns1__SetPresetTour::presetList);
	/* transient soap skipped */
}

int _ns1__SetPresetTour::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetPresetTour);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__SetPresetTour::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetPresetTour(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetPresetTour(struct soap *soap, const char *tag, int id, const _ns1__SetPresetTour *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetPresetTour), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__SetPresetTour::channel), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfPreset_USCORET(soap, "ns1:presetList", -1, &(a->_ns1__SetPresetTour::presetList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetPresetTour::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetPresetTour(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetPresetTour * SOAP_FMAC4 soap_get__ns1__SetPresetTour(struct soap *soap, _ns1__SetPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__SetPresetTour::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetPresetTour(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetPresetTour * SOAP_FMAC4 soap_in__ns1__SetPresetTour(struct soap *soap, const char *tag, _ns1__SetPresetTour *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetPresetTour *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetPresetTour, sizeof(_ns1__SetPresetTour), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetPresetTour)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetPresetTour *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	size_t soap_flag_presetList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__SetPresetTour::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			if (soap_flag_presetList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPreset_USCORET(soap, "ns1:presetList", &(a->_ns1__SetPresetTour::presetList), "ns1:ArrayOfPreset_T"))
				{	soap_flag_presetList1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetPresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetPresetTour, 0, sizeof(_ns1__SetPresetTour), 0, soap_copy__ns1__SetPresetTour);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__SetPresetTour * SOAP_FMAC4 soap_instantiate__ns1__SetPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetPresetTour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetPresetTour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__SetPresetTour;
		if (size)
			*size = sizeof(_ns1__SetPresetTour);
		((_ns1__SetPresetTour*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__SetPresetTour[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SetPresetTour);
		for (int i = 0; i < n; i++)
			((_ns1__SetPresetTour*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SetPresetTour*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetPresetTour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetPresetTour %p -> %p\n", q, p));
	*(_ns1__SetPresetTour*)p = *(_ns1__SetPresetTour*)q;
}

void _ns1__GetPresetTourResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPresetTourResponse::GetPresetTourResult = NULL;
	soap_default_int(soap, &this->_ns1__GetPresetTourResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__GetPresetTourResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPreset_USCORET(soap, &this->_ns1__GetPresetTourResponse::GetPresetTourResult);
	/* transient soap skipped */
}

int _ns1__GetPresetTourResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPresetTourResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetPresetTourResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPresetTourResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPresetTourResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPresetTourResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPresetTourResponse), type))
		return soap->error;
	if (a->GetPresetTourResult)
		soap_element_result(soap, "ns1:GetPresetTourResult");
	if (soap_out_PointerTons1__ArrayOfPreset_USCORET(soap, "ns1:GetPresetTourResult", -1, &(a->_ns1__GetPresetTourResponse::GetPresetTourResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__GetPresetTourResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPresetTourResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPresetTourResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPresetTourResponse * SOAP_FMAC4 soap_get__ns1__GetPresetTourResponse(struct soap *soap, _ns1__GetPresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetPresetTourResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPresetTourResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPresetTourResponse * SOAP_FMAC4 soap_in__ns1__GetPresetTourResponse(struct soap *soap, const char *tag, _ns1__GetPresetTourResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPresetTourResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPresetTourResponse, sizeof(_ns1__GetPresetTourResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPresetTourResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPresetTourResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPresetTourResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPresetTourResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPreset_USCORET(soap, "ns1:GetPresetTourResult", &(a->_ns1__GetPresetTourResponse::GetPresetTourResult), "ns1:ArrayOfPreset_T"))
				{	soap_flag_GetPresetTourResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__GetPresetTourResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPresetTourResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPresetTourResponse, 0, sizeof(_ns1__GetPresetTourResponse), 0, soap_copy__ns1__GetPresetTourResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetPresetTourResponse * SOAP_FMAC4 soap_instantiate__ns1__GetPresetTourResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPresetTourResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPresetTourResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetPresetTourResponse;
		if (size)
			*size = sizeof(_ns1__GetPresetTourResponse);
		((_ns1__GetPresetTourResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetPresetTourResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPresetTourResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPresetTourResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPresetTourResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPresetTourResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPresetTourResponse %p -> %p\n", q, p));
	*(_ns1__GetPresetTourResponse*)p = *(_ns1__GetPresetTourResponse*)q;
}

void _ns1__GetPresetTour::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetPresetTour::channel);
	/* transient soap skipped */
}

void _ns1__GetPresetTour::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__GetPresetTour::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPresetTour);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetPresetTour::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPresetTour(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPresetTour(struct soap *soap, const char *tag, int id, const _ns1__GetPresetTour *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPresetTour), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__GetPresetTour::channel), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPresetTour::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPresetTour(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPresetTour * SOAP_FMAC4 soap_get__ns1__GetPresetTour(struct soap *soap, _ns1__GetPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetPresetTour::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPresetTour(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPresetTour * SOAP_FMAC4 soap_in__ns1__GetPresetTour(struct soap *soap, const char *tag, _ns1__GetPresetTour *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPresetTour *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPresetTour, sizeof(_ns1__GetPresetTour), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPresetTour)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPresetTour *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__GetPresetTour::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPresetTour, 0, sizeof(_ns1__GetPresetTour), 0, soap_copy__ns1__GetPresetTour);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetPresetTour * SOAP_FMAC4 soap_instantiate__ns1__GetPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPresetTour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPresetTour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetPresetTour;
		if (size)
			*size = sizeof(_ns1__GetPresetTour);
		((_ns1__GetPresetTour*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetPresetTour[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPresetTour);
		for (int i = 0; i < n; i++)
			((_ns1__GetPresetTour*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPresetTour*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPresetTour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPresetTour %p -> %p\n", q, p));
	*(_ns1__GetPresetTour*)p = *(_ns1__GetPresetTour*)q;
}

void _ns1__RemovePresetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__RemovePresetResponse::RemovePresetResult);
	soap_default_int(soap, &this->_ns1__RemovePresetResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__RemovePresetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__RemovePresetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__RemovePresetResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__RemovePresetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemovePresetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemovePresetResponse(struct soap *soap, const char *tag, int id, const _ns1__RemovePresetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemovePresetResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:RemovePresetResult");
	if (soap_out_bool(soap, "ns1:RemovePresetResult", -1, &(a->_ns1__RemovePresetResponse::RemovePresetResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__RemovePresetResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemovePresetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemovePresetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemovePresetResponse * SOAP_FMAC4 soap_get__ns1__RemovePresetResponse(struct soap *soap, _ns1__RemovePresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemovePresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__RemovePresetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemovePresetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemovePresetResponse * SOAP_FMAC4 soap_in__ns1__RemovePresetResponse(struct soap *soap, const char *tag, _ns1__RemovePresetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemovePresetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemovePresetResponse, sizeof(_ns1__RemovePresetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__RemovePresetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__RemovePresetResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RemovePresetResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemovePresetResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:RemovePresetResult", &(a->_ns1__RemovePresetResponse::RemovePresetResult), "xsd:boolean"))
				{	soap_flag_RemovePresetResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__RemovePresetResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:RemovePresetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RemovePresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemovePresetResponse, 0, sizeof(_ns1__RemovePresetResponse), 0, soap_copy__ns1__RemovePresetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RemovePresetResult1 > 0 || soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__RemovePresetResponse * SOAP_FMAC4 soap_instantiate__ns1__RemovePresetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemovePresetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__RemovePresetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__RemovePresetResponse;
		if (size)
			*size = sizeof(_ns1__RemovePresetResponse);
		((_ns1__RemovePresetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__RemovePresetResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__RemovePresetResponse);
		for (int i = 0; i < n; i++)
			((_ns1__RemovePresetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__RemovePresetResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__RemovePresetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__RemovePresetResponse %p -> %p\n", q, p));
	*(_ns1__RemovePresetResponse*)p = *(_ns1__RemovePresetResponse*)q;
}

void _ns1__RemovePreset::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__RemovePreset::channel);
	soap_default_string(soap, &this->_ns1__RemovePreset::alias);
	/* transient soap skipped */
}

void _ns1__RemovePreset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__RemovePreset::alias);
	/* transient soap skipped */
}

int _ns1__RemovePreset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__RemovePreset);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__RemovePreset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemovePreset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemovePreset(struct soap *soap, const char *tag, int id, const _ns1__RemovePreset *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemovePreset), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__RemovePreset::channel), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:alias", -1, &(a->_ns1__RemovePreset::alias), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemovePreset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemovePreset(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemovePreset * SOAP_FMAC4 soap_get__ns1__RemovePreset(struct soap *soap, _ns1__RemovePreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemovePreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__RemovePreset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemovePreset(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemovePreset * SOAP_FMAC4 soap_in__ns1__RemovePreset(struct soap *soap, const char *tag, _ns1__RemovePreset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemovePreset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemovePreset, sizeof(_ns1__RemovePreset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__RemovePreset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__RemovePreset *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	size_t soap_flag_alias1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__RemovePreset::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			if (soap_flag_alias1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:alias", &(a->_ns1__RemovePreset::alias), "xsd:string"))
				{	soap_flag_alias1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RemovePreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemovePreset, 0, sizeof(_ns1__RemovePreset), 0, soap_copy__ns1__RemovePreset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__RemovePreset * SOAP_FMAC4 soap_instantiate__ns1__RemovePreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemovePreset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__RemovePreset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__RemovePreset;
		if (size)
			*size = sizeof(_ns1__RemovePreset);
		((_ns1__RemovePreset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__RemovePreset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__RemovePreset);
		for (int i = 0; i < n; i++)
			((_ns1__RemovePreset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__RemovePreset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__RemovePreset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__RemovePreset %p -> %p\n", q, p));
	*(_ns1__RemovePreset*)p = *(_ns1__RemovePreset*)q;
}

void _ns1__GotoPresetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GotoPresetResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__GotoPresetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__GotoPresetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GotoPresetResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GotoPresetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GotoPresetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GotoPresetResponse(struct soap *soap, const char *tag, int id, const _ns1__GotoPresetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GotoPresetResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:resultCode");
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__GotoPresetResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GotoPresetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GotoPresetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GotoPresetResponse * SOAP_FMAC4 soap_get__ns1__GotoPresetResponse(struct soap *soap, _ns1__GotoPresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GotoPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GotoPresetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GotoPresetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GotoPresetResponse * SOAP_FMAC4 soap_in__ns1__GotoPresetResponse(struct soap *soap, const char *tag, _ns1__GotoPresetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GotoPresetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GotoPresetResponse, sizeof(_ns1__GotoPresetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GotoPresetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GotoPresetResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__GotoPresetResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:resultCode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GotoPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GotoPresetResponse, 0, sizeof(_ns1__GotoPresetResponse), 0, soap_copy__ns1__GotoPresetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GotoPresetResponse * SOAP_FMAC4 soap_instantiate__ns1__GotoPresetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GotoPresetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GotoPresetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GotoPresetResponse;
		if (size)
			*size = sizeof(_ns1__GotoPresetResponse);
		((_ns1__GotoPresetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GotoPresetResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GotoPresetResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GotoPresetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GotoPresetResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GotoPresetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GotoPresetResponse %p -> %p\n", q, p));
	*(_ns1__GotoPresetResponse*)p = *(_ns1__GotoPresetResponse*)q;
}

void _ns1__GotoPreset::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GotoPreset::channel);
	soap_default_string(soap, &this->_ns1__GotoPreset::alias);
	/* transient soap skipped */
}

void _ns1__GotoPreset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GotoPreset::alias);
	/* transient soap skipped */
}

int _ns1__GotoPreset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GotoPreset);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GotoPreset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GotoPreset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GotoPreset(struct soap *soap, const char *tag, int id, const _ns1__GotoPreset *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GotoPreset), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__GotoPreset::channel), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:alias", -1, &(a->_ns1__GotoPreset::alias), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GotoPreset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GotoPreset(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GotoPreset * SOAP_FMAC4 soap_get__ns1__GotoPreset(struct soap *soap, _ns1__GotoPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GotoPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GotoPreset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GotoPreset(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GotoPreset * SOAP_FMAC4 soap_in__ns1__GotoPreset(struct soap *soap, const char *tag, _ns1__GotoPreset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GotoPreset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GotoPreset, sizeof(_ns1__GotoPreset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GotoPreset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GotoPreset *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	size_t soap_flag_alias1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__GotoPreset::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			if (soap_flag_alias1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:alias", &(a->_ns1__GotoPreset::alias), "xsd:string"))
				{	soap_flag_alias1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GotoPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GotoPreset, 0, sizeof(_ns1__GotoPreset), 0, soap_copy__ns1__GotoPreset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GotoPreset * SOAP_FMAC4 soap_instantiate__ns1__GotoPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GotoPreset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GotoPreset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GotoPreset;
		if (size)
			*size = sizeof(_ns1__GotoPreset);
		((_ns1__GotoPreset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GotoPreset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GotoPreset);
		for (int i = 0; i < n; i++)
			((_ns1__GotoPreset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GotoPreset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GotoPreset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GotoPreset %p -> %p\n", q, p));
	*(_ns1__GotoPreset*)p = *(_ns1__GotoPreset*)q;
}

void _ns1__AddPresetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__AddPresetResponse::AddPresetResult);
	soap_default_int(soap, &this->_ns1__AddPresetResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__AddPresetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__AddPresetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddPresetResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__AddPresetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddPresetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddPresetResponse(struct soap *soap, const char *tag, int id, const _ns1__AddPresetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddPresetResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:AddPresetResult");
	if (soap_out_bool(soap, "ns1:AddPresetResult", -1, &(a->_ns1__AddPresetResponse::AddPresetResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__AddPresetResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddPresetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddPresetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddPresetResponse * SOAP_FMAC4 soap_get__ns1__AddPresetResponse(struct soap *soap, _ns1__AddPresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__AddPresetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddPresetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddPresetResponse * SOAP_FMAC4 soap_in__ns1__AddPresetResponse(struct soap *soap, const char *tag, _ns1__AddPresetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddPresetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddPresetResponse, sizeof(_ns1__AddPresetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddPresetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddPresetResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AddPresetResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AddPresetResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:AddPresetResult", &(a->_ns1__AddPresetResponse::AddPresetResult), "xsd:boolean"))
				{	soap_flag_AddPresetResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__AddPresetResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:AddPresetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddPresetResponse, 0, sizeof(_ns1__AddPresetResponse), 0, soap_copy__ns1__AddPresetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AddPresetResult1 > 0 || soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__AddPresetResponse * SOAP_FMAC4 soap_instantiate__ns1__AddPresetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddPresetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddPresetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__AddPresetResponse;
		if (size)
			*size = sizeof(_ns1__AddPresetResponse);
		((_ns1__AddPresetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__AddPresetResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddPresetResponse);
		for (int i = 0; i < n; i++)
			((_ns1__AddPresetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddPresetResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddPresetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddPresetResponse %p -> %p\n", q, p));
	*(_ns1__AddPresetResponse*)p = *(_ns1__AddPresetResponse*)q;
}

void _ns1__AddPreset::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__AddPreset::channel);
	this->_ns1__AddPreset::preset = NULL;
	/* transient soap skipped */
}

void _ns1__AddPreset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Preset_USCORET(soap, &this->_ns1__AddPreset::preset);
	/* transient soap skipped */
}

int _ns1__AddPreset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddPreset);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__AddPreset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddPreset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddPreset(struct soap *soap, const char *tag, int id, const _ns1__AddPreset *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddPreset), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__AddPreset::channel), ""))
		return soap->error;
	if (soap_out_PointerTons1__Preset_USCORET(soap, "ns1:preset", -1, &(a->_ns1__AddPreset::preset), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddPreset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddPreset(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddPreset * SOAP_FMAC4 soap_get__ns1__AddPreset(struct soap *soap, _ns1__AddPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__AddPreset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddPreset(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddPreset * SOAP_FMAC4 soap_in__ns1__AddPreset(struct soap *soap, const char *tag, _ns1__AddPreset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddPreset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddPreset, sizeof(_ns1__AddPreset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddPreset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddPreset *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	size_t soap_flag_preset1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__AddPreset::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			if (soap_flag_preset1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Preset_USCORET(soap, "ns1:preset", &(a->_ns1__AddPreset::preset), "ns1:Preset_T"))
				{	soap_flag_preset1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddPreset, 0, sizeof(_ns1__AddPreset), 0, soap_copy__ns1__AddPreset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__AddPreset * SOAP_FMAC4 soap_instantiate__ns1__AddPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddPreset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddPreset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__AddPreset;
		if (size)
			*size = sizeof(_ns1__AddPreset);
		((_ns1__AddPreset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__AddPreset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddPreset);
		for (int i = 0; i < n; i++)
			((_ns1__AddPreset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddPreset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddPreset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddPreset %p -> %p\n", q, p));
	*(_ns1__AddPreset*)p = *(_ns1__AddPreset*)q;
}

void _ns1__GetPresetListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPresetListResponse::GetPresetListResult = NULL;
	soap_default_int(soap, &this->_ns1__GetPresetListResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__GetPresetListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPreset_USCORET(soap, &this->_ns1__GetPresetListResponse::GetPresetListResult);
	/* transient soap skipped */
}

int _ns1__GetPresetListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPresetListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetPresetListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPresetListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPresetListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPresetListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPresetListResponse), type))
		return soap->error;
	if (a->GetPresetListResult)
		soap_element_result(soap, "ns1:GetPresetListResult");
	if (soap_out_PointerTons1__ArrayOfPreset_USCORET(soap, "ns1:GetPresetListResult", -1, &(a->_ns1__GetPresetListResponse::GetPresetListResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__GetPresetListResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPresetListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPresetListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPresetListResponse * SOAP_FMAC4 soap_get__ns1__GetPresetListResponse(struct soap *soap, _ns1__GetPresetListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPresetListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetPresetListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPresetListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPresetListResponse * SOAP_FMAC4 soap_in__ns1__GetPresetListResponse(struct soap *soap, const char *tag, _ns1__GetPresetListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPresetListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPresetListResponse, sizeof(_ns1__GetPresetListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPresetListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPresetListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPresetListResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPresetListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPreset_USCORET(soap, "ns1:GetPresetListResult", &(a->_ns1__GetPresetListResponse::GetPresetListResult), "ns1:ArrayOfPreset_T"))
				{	soap_flag_GetPresetListResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__GetPresetListResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPresetListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPresetListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPresetListResponse, 0, sizeof(_ns1__GetPresetListResponse), 0, soap_copy__ns1__GetPresetListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetPresetListResponse * SOAP_FMAC4 soap_instantiate__ns1__GetPresetListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPresetListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPresetListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetPresetListResponse;
		if (size)
			*size = sizeof(_ns1__GetPresetListResponse);
		((_ns1__GetPresetListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetPresetListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPresetListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPresetListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPresetListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPresetListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPresetListResponse %p -> %p\n", q, p));
	*(_ns1__GetPresetListResponse*)p = *(_ns1__GetPresetListResponse*)q;
}

void _ns1__GetPresetList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetPresetList::channel);
	/* transient soap skipped */
}

void _ns1__GetPresetList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__GetPresetList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPresetList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetPresetList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPresetList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPresetList(struct soap *soap, const char *tag, int id, const _ns1__GetPresetList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPresetList), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__GetPresetList::channel), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPresetList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPresetList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPresetList * SOAP_FMAC4 soap_get__ns1__GetPresetList(struct soap *soap, _ns1__GetPresetList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPresetList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetPresetList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPresetList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPresetList * SOAP_FMAC4 soap_in__ns1__GetPresetList(struct soap *soap, const char *tag, _ns1__GetPresetList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPresetList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPresetList, sizeof(_ns1__GetPresetList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPresetList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPresetList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__GetPresetList::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPresetList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPresetList, 0, sizeof(_ns1__GetPresetList), 0, soap_copy__ns1__GetPresetList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetPresetList * SOAP_FMAC4 soap_instantiate__ns1__GetPresetList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPresetList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPresetList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetPresetList;
		if (size)
			*size = sizeof(_ns1__GetPresetList);
		((_ns1__GetPresetList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetPresetList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPresetList);
		for (int i = 0; i < n; i++)
			((_ns1__GetPresetList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPresetList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPresetList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPresetList %p -> %p\n", q, p));
	*(_ns1__GetPresetList*)p = *(_ns1__GetPresetList*)q;
}

void _ns1__StopResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__StopResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__StopResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__StopResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__StopResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__StopResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StopResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StopResponse(struct soap *soap, const char *tag, int id, const _ns1__StopResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StopResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:resultCode");
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__StopResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__StopResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StopResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StopResponse * SOAP_FMAC4 soap_get__ns1__StopResponse(struct soap *soap, _ns1__StopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__StopResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StopResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StopResponse * SOAP_FMAC4 soap_in__ns1__StopResponse(struct soap *soap, const char *tag, _ns1__StopResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StopResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StopResponse, sizeof(_ns1__StopResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__StopResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__StopResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__StopResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:resultCode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__StopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StopResponse, 0, sizeof(_ns1__StopResponse), 0, soap_copy__ns1__StopResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__StopResponse * SOAP_FMAC4 soap_instantiate__ns1__StopResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StopResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__StopResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__StopResponse;
		if (size)
			*size = sizeof(_ns1__StopResponse);
		((_ns1__StopResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__StopResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__StopResponse);
		for (int i = 0; i < n; i++)
			((_ns1__StopResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__StopResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__StopResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__StopResponse %p -> %p\n", q, p));
	*(_ns1__StopResponse*)p = *(_ns1__StopResponse*)q;
}

void _ns1__Stop::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__Stop::channel);
	this->_ns1__Stop::param = NULL;
	/* transient soap skipped */
}

void _ns1__Stop::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfParameter_USCORET(soap, &this->_ns1__Stop::param);
	/* transient soap skipped */
}

int _ns1__Stop::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__Stop);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__Stop::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Stop(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Stop(struct soap *soap, const char *tag, int id, const _ns1__Stop *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Stop), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__Stop::channel), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfParameter_USCORET(soap, "ns1:param", -1, &(a->_ns1__Stop::param), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__Stop::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Stop(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Stop * SOAP_FMAC4 soap_get__ns1__Stop(struct soap *soap, _ns1__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__Stop::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Stop(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Stop * SOAP_FMAC4 soap_in__ns1__Stop(struct soap *soap, const char *tag, _ns1__Stop *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Stop *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Stop, sizeof(_ns1__Stop), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__Stop)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__Stop *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	size_t soap_flag_param1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__Stop::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			if (soap_flag_param1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfParameter_USCORET(soap, "ns1:param", &(a->_ns1__Stop::param), "ns1:ArrayOfParameter_T"))
				{	soap_flag_param1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Stop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Stop, 0, sizeof(_ns1__Stop), 0, soap_copy__ns1__Stop);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__Stop * SOAP_FMAC4 soap_instantiate__ns1__Stop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Stop(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__Stop, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__Stop;
		if (size)
			*size = sizeof(_ns1__Stop);
		((_ns1__Stop*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__Stop[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__Stop);
		for (int i = 0; i < n; i++)
			((_ns1__Stop*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__Stop*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__Stop(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__Stop %p -> %p\n", q, p));
	*(_ns1__Stop*)p = *(_ns1__Stop*)q;
}

void _ns1__ControlPTZResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__ControlPTZResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__ControlPTZResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__ControlPTZResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__ControlPTZResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__ControlPTZResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ControlPTZResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ControlPTZResponse(struct soap *soap, const char *tag, int id, const _ns1__ControlPTZResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ControlPTZResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:resultCode");
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__ControlPTZResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__ControlPTZResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ControlPTZResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ControlPTZResponse * SOAP_FMAC4 soap_get__ns1__ControlPTZResponse(struct soap *soap, _ns1__ControlPTZResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ControlPTZResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__ControlPTZResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ControlPTZResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ControlPTZResponse * SOAP_FMAC4 soap_in__ns1__ControlPTZResponse(struct soap *soap, const char *tag, _ns1__ControlPTZResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ControlPTZResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ControlPTZResponse, sizeof(_ns1__ControlPTZResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__ControlPTZResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__ControlPTZResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__ControlPTZResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:resultCode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ControlPTZResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ControlPTZResponse, 0, sizeof(_ns1__ControlPTZResponse), 0, soap_copy__ns1__ControlPTZResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__ControlPTZResponse * SOAP_FMAC4 soap_instantiate__ns1__ControlPTZResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ControlPTZResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__ControlPTZResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__ControlPTZResponse;
		if (size)
			*size = sizeof(_ns1__ControlPTZResponse);
		((_ns1__ControlPTZResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__ControlPTZResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__ControlPTZResponse);
		for (int i = 0; i < n; i++)
			((_ns1__ControlPTZResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__ControlPTZResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__ControlPTZResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__ControlPTZResponse %p -> %p\n", q, p));
	*(_ns1__ControlPTZResponse*)p = *(_ns1__ControlPTZResponse*)q;
}

void _ns1__ControlPTZ::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__ControlPTZ::channel);
	this->_ns1__ControlPTZ::param = NULL;
	/* transient soap skipped */
}

void _ns1__ControlPTZ::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfParameter_USCORET(soap, &this->_ns1__ControlPTZ::param);
	/* transient soap skipped */
}

int _ns1__ControlPTZ::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__ControlPTZ);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__ControlPTZ::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ControlPTZ(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ControlPTZ(struct soap *soap, const char *tag, int id, const _ns1__ControlPTZ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ControlPTZ), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__ControlPTZ::channel), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfParameter_USCORET(soap, "ns1:param", -1, &(a->_ns1__ControlPTZ::param), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__ControlPTZ::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ControlPTZ(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ControlPTZ * SOAP_FMAC4 soap_get__ns1__ControlPTZ(struct soap *soap, _ns1__ControlPTZ *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ControlPTZ(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__ControlPTZ::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ControlPTZ(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ControlPTZ * SOAP_FMAC4 soap_in__ns1__ControlPTZ(struct soap *soap, const char *tag, _ns1__ControlPTZ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ControlPTZ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ControlPTZ, sizeof(_ns1__ControlPTZ), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__ControlPTZ)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__ControlPTZ *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	size_t soap_flag_param1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__ControlPTZ::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			if (soap_flag_param1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfParameter_USCORET(soap, "ns1:param", &(a->_ns1__ControlPTZ::param), "ns1:ArrayOfParameter_T"))
				{	soap_flag_param1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ControlPTZ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ControlPTZ, 0, sizeof(_ns1__ControlPTZ), 0, soap_copy__ns1__ControlPTZ);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__ControlPTZ * SOAP_FMAC4 soap_instantiate__ns1__ControlPTZ(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ControlPTZ(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__ControlPTZ, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__ControlPTZ;
		if (size)
			*size = sizeof(_ns1__ControlPTZ);
		((_ns1__ControlPTZ*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__ControlPTZ[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__ControlPTZ);
		for (int i = 0; i < n; i++)
			((_ns1__ControlPTZ*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__ControlPTZ*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__ControlPTZ(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__ControlPTZ %p -> %p\n", q, p));
	*(_ns1__ControlPTZ*)p = *(_ns1__ControlPTZ*)q;
}

void _ns1__GetPTZCommandListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPTZCommandListResponse::GetPTZCommandListResult = NULL;
	soap_default_int(soap, &this->_ns1__GetPTZCommandListResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__GetPTZCommandListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfParameter_USCORET(soap, &this->_ns1__GetPTZCommandListResponse::GetPTZCommandListResult);
	/* transient soap skipped */
}

int _ns1__GetPTZCommandListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPTZCommandListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetPTZCommandListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPTZCommandListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPTZCommandListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPTZCommandListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPTZCommandListResponse), type))
		return soap->error;
	if (a->GetPTZCommandListResult)
		soap_element_result(soap, "ns1:GetPTZCommandListResult");
	if (soap_out_PointerTons1__ArrayOfParameter_USCORET(soap, "ns1:GetPTZCommandListResult", -1, &(a->_ns1__GetPTZCommandListResponse::GetPTZCommandListResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__GetPTZCommandListResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPTZCommandListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPTZCommandListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPTZCommandListResponse * SOAP_FMAC4 soap_get__ns1__GetPTZCommandListResponse(struct soap *soap, _ns1__GetPTZCommandListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPTZCommandListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetPTZCommandListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPTZCommandListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPTZCommandListResponse * SOAP_FMAC4 soap_in__ns1__GetPTZCommandListResponse(struct soap *soap, const char *tag, _ns1__GetPTZCommandListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPTZCommandListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPTZCommandListResponse, sizeof(_ns1__GetPTZCommandListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPTZCommandListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPTZCommandListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPTZCommandListResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPTZCommandListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfParameter_USCORET(soap, "ns1:GetPTZCommandListResult", &(a->_ns1__GetPTZCommandListResponse::GetPTZCommandListResult), "ns1:ArrayOfParameter_T"))
				{	soap_flag_GetPTZCommandListResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__GetPTZCommandListResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPTZCommandListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPTZCommandListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPTZCommandListResponse, 0, sizeof(_ns1__GetPTZCommandListResponse), 0, soap_copy__ns1__GetPTZCommandListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetPTZCommandListResponse * SOAP_FMAC4 soap_instantiate__ns1__GetPTZCommandListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPTZCommandListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPTZCommandListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetPTZCommandListResponse;
		if (size)
			*size = sizeof(_ns1__GetPTZCommandListResponse);
		((_ns1__GetPTZCommandListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetPTZCommandListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPTZCommandListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPTZCommandListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPTZCommandListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPTZCommandListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPTZCommandListResponse %p -> %p\n", q, p));
	*(_ns1__GetPTZCommandListResponse*)p = *(_ns1__GetPTZCommandListResponse*)q;
}

void _ns1__GetPTZCommandList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPTZCommandList::protocolName);
	/* transient soap skipped */
}

void _ns1__GetPTZCommandList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPTZCommandList::protocolName);
	/* transient soap skipped */
}

int _ns1__GetPTZCommandList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPTZCommandList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetPTZCommandList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPTZCommandList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPTZCommandList(struct soap *soap, const char *tag, int id, const _ns1__GetPTZCommandList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPTZCommandList), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:protocolName", -1, &(a->_ns1__GetPTZCommandList::protocolName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPTZCommandList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPTZCommandList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPTZCommandList * SOAP_FMAC4 soap_get__ns1__GetPTZCommandList(struct soap *soap, _ns1__GetPTZCommandList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPTZCommandList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetPTZCommandList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPTZCommandList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPTZCommandList * SOAP_FMAC4 soap_in__ns1__GetPTZCommandList(struct soap *soap, const char *tag, _ns1__GetPTZCommandList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPTZCommandList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPTZCommandList, sizeof(_ns1__GetPTZCommandList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPTZCommandList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPTZCommandList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_protocolName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_protocolName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:protocolName", &(a->_ns1__GetPTZCommandList::protocolName), "xsd:string"))
				{	soap_flag_protocolName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPTZCommandList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPTZCommandList, 0, sizeof(_ns1__GetPTZCommandList), 0, soap_copy__ns1__GetPTZCommandList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetPTZCommandList * SOAP_FMAC4 soap_instantiate__ns1__GetPTZCommandList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPTZCommandList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPTZCommandList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetPTZCommandList;
		if (size)
			*size = sizeof(_ns1__GetPTZCommandList);
		((_ns1__GetPTZCommandList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetPTZCommandList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPTZCommandList);
		for (int i = 0; i < n; i++)
			((_ns1__GetPTZCommandList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPTZCommandList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPTZCommandList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPTZCommandList %p -> %p\n", q, p));
	*(_ns1__GetPTZCommandList*)p = *(_ns1__GetPTZCommandList*)q;
}

void _ns1__GetPTZProtocolInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPTZProtocolInfoResponse::GetPTZProtocolInfoResult = NULL;
	soap_default_int(soap, &this->_ns1__GetPTZProtocolInfoResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__GetPTZProtocolInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__PTZProtocol_USCORET(soap, &this->_ns1__GetPTZProtocolInfoResponse::GetPTZProtocolInfoResult);
	/* transient soap skipped */
}

int _ns1__GetPTZProtocolInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPTZProtocolInfoResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetPTZProtocolInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPTZProtocolInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPTZProtocolInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPTZProtocolInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPTZProtocolInfoResponse), type))
		return soap->error;
	if (a->GetPTZProtocolInfoResult)
		soap_element_result(soap, "ns1:GetPTZProtocolInfoResult");
	if (soap_out_PointerTons1__PTZProtocol_USCORET(soap, "ns1:GetPTZProtocolInfoResult", -1, &(a->_ns1__GetPTZProtocolInfoResponse::GetPTZProtocolInfoResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__GetPTZProtocolInfoResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPTZProtocolInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPTZProtocolInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocolInfoResponse * SOAP_FMAC4 soap_get__ns1__GetPTZProtocolInfoResponse(struct soap *soap, _ns1__GetPTZProtocolInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPTZProtocolInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetPTZProtocolInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPTZProtocolInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocolInfoResponse * SOAP_FMAC4 soap_in__ns1__GetPTZProtocolInfoResponse(struct soap *soap, const char *tag, _ns1__GetPTZProtocolInfoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPTZProtocolInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPTZProtocolInfoResponse, sizeof(_ns1__GetPTZProtocolInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPTZProtocolInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPTZProtocolInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPTZProtocolInfoResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPTZProtocolInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PTZProtocol_USCORET(soap, "ns1:GetPTZProtocolInfoResult", &(a->_ns1__GetPTZProtocolInfoResponse::GetPTZProtocolInfoResult), "ns1:PTZProtocol_T"))
				{	soap_flag_GetPTZProtocolInfoResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__GetPTZProtocolInfoResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPTZProtocolInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPTZProtocolInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPTZProtocolInfoResponse, 0, sizeof(_ns1__GetPTZProtocolInfoResponse), 0, soap_copy__ns1__GetPTZProtocolInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetPTZProtocolInfoResponse * SOAP_FMAC4 soap_instantiate__ns1__GetPTZProtocolInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPTZProtocolInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPTZProtocolInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetPTZProtocolInfoResponse;
		if (size)
			*size = sizeof(_ns1__GetPTZProtocolInfoResponse);
		((_ns1__GetPTZProtocolInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetPTZProtocolInfoResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPTZProtocolInfoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPTZProtocolInfoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPTZProtocolInfoResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPTZProtocolInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPTZProtocolInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetPTZProtocolInfoResponse*)p = *(_ns1__GetPTZProtocolInfoResponse*)q;
}

void _ns1__GetPTZProtocolInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPTZProtocolInfo::protocolName);
	/* transient soap skipped */
}

void _ns1__GetPTZProtocolInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPTZProtocolInfo::protocolName);
	/* transient soap skipped */
}

int _ns1__GetPTZProtocolInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPTZProtocolInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetPTZProtocolInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPTZProtocolInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPTZProtocolInfo(struct soap *soap, const char *tag, int id, const _ns1__GetPTZProtocolInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPTZProtocolInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:protocolName", -1, &(a->_ns1__GetPTZProtocolInfo::protocolName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPTZProtocolInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPTZProtocolInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocolInfo * SOAP_FMAC4 soap_get__ns1__GetPTZProtocolInfo(struct soap *soap, _ns1__GetPTZProtocolInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPTZProtocolInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetPTZProtocolInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPTZProtocolInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocolInfo * SOAP_FMAC4 soap_in__ns1__GetPTZProtocolInfo(struct soap *soap, const char *tag, _ns1__GetPTZProtocolInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPTZProtocolInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPTZProtocolInfo, sizeof(_ns1__GetPTZProtocolInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPTZProtocolInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPTZProtocolInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_protocolName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_protocolName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:protocolName", &(a->_ns1__GetPTZProtocolInfo::protocolName), "xsd:string"))
				{	soap_flag_protocolName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPTZProtocolInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPTZProtocolInfo, 0, sizeof(_ns1__GetPTZProtocolInfo), 0, soap_copy__ns1__GetPTZProtocolInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetPTZProtocolInfo * SOAP_FMAC4 soap_instantiate__ns1__GetPTZProtocolInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPTZProtocolInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPTZProtocolInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetPTZProtocolInfo;
		if (size)
			*size = sizeof(_ns1__GetPTZProtocolInfo);
		((_ns1__GetPTZProtocolInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetPTZProtocolInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPTZProtocolInfo);
		for (int i = 0; i < n; i++)
			((_ns1__GetPTZProtocolInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPTZProtocolInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPTZProtocolInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPTZProtocolInfo %p -> %p\n", q, p));
	*(_ns1__GetPTZProtocolInfo*)p = *(_ns1__GetPTZProtocolInfo*)q;
}

void _ns1__RemovePTZProtocolResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__RemovePTZProtocolResponse::RemovePTZProtocolResult);
	soap_default_int(soap, &this->_ns1__RemovePTZProtocolResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__RemovePTZProtocolResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__RemovePTZProtocolResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__RemovePTZProtocolResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__RemovePTZProtocolResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemovePTZProtocolResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemovePTZProtocolResponse(struct soap *soap, const char *tag, int id, const _ns1__RemovePTZProtocolResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemovePTZProtocolResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:RemovePTZProtocolResult");
	if (soap_out_bool(soap, "ns1:RemovePTZProtocolResult", -1, &(a->_ns1__RemovePTZProtocolResponse::RemovePTZProtocolResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__RemovePTZProtocolResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemovePTZProtocolResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemovePTZProtocolResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemovePTZProtocolResponse * SOAP_FMAC4 soap_get__ns1__RemovePTZProtocolResponse(struct soap *soap, _ns1__RemovePTZProtocolResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemovePTZProtocolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__RemovePTZProtocolResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemovePTZProtocolResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemovePTZProtocolResponse * SOAP_FMAC4 soap_in__ns1__RemovePTZProtocolResponse(struct soap *soap, const char *tag, _ns1__RemovePTZProtocolResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemovePTZProtocolResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemovePTZProtocolResponse, sizeof(_ns1__RemovePTZProtocolResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__RemovePTZProtocolResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__RemovePTZProtocolResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RemovePTZProtocolResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemovePTZProtocolResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:RemovePTZProtocolResult", &(a->_ns1__RemovePTZProtocolResponse::RemovePTZProtocolResult), "xsd:boolean"))
				{	soap_flag_RemovePTZProtocolResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__RemovePTZProtocolResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:RemovePTZProtocolResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RemovePTZProtocolResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemovePTZProtocolResponse, 0, sizeof(_ns1__RemovePTZProtocolResponse), 0, soap_copy__ns1__RemovePTZProtocolResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RemovePTZProtocolResult1 > 0 || soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__RemovePTZProtocolResponse * SOAP_FMAC4 soap_instantiate__ns1__RemovePTZProtocolResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemovePTZProtocolResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__RemovePTZProtocolResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__RemovePTZProtocolResponse;
		if (size)
			*size = sizeof(_ns1__RemovePTZProtocolResponse);
		((_ns1__RemovePTZProtocolResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__RemovePTZProtocolResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__RemovePTZProtocolResponse);
		for (int i = 0; i < n; i++)
			((_ns1__RemovePTZProtocolResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__RemovePTZProtocolResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__RemovePTZProtocolResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__RemovePTZProtocolResponse %p -> %p\n", q, p));
	*(_ns1__RemovePTZProtocolResponse*)p = *(_ns1__RemovePTZProtocolResponse*)q;
}

void _ns1__RemovePTZProtocol::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__RemovePTZProtocol::protocolName);
	/* transient soap skipped */
}

void _ns1__RemovePTZProtocol::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__RemovePTZProtocol::protocolName);
	/* transient soap skipped */
}

int _ns1__RemovePTZProtocol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__RemovePTZProtocol);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__RemovePTZProtocol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemovePTZProtocol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemovePTZProtocol(struct soap *soap, const char *tag, int id, const _ns1__RemovePTZProtocol *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemovePTZProtocol), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:protocolName", -1, &(a->_ns1__RemovePTZProtocol::protocolName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemovePTZProtocol::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemovePTZProtocol(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemovePTZProtocol * SOAP_FMAC4 soap_get__ns1__RemovePTZProtocol(struct soap *soap, _ns1__RemovePTZProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemovePTZProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__RemovePTZProtocol::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemovePTZProtocol(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemovePTZProtocol * SOAP_FMAC4 soap_in__ns1__RemovePTZProtocol(struct soap *soap, const char *tag, _ns1__RemovePTZProtocol *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemovePTZProtocol *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemovePTZProtocol, sizeof(_ns1__RemovePTZProtocol), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__RemovePTZProtocol)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__RemovePTZProtocol *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_protocolName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_protocolName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:protocolName", &(a->_ns1__RemovePTZProtocol::protocolName), "xsd:string"))
				{	soap_flag_protocolName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RemovePTZProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemovePTZProtocol, 0, sizeof(_ns1__RemovePTZProtocol), 0, soap_copy__ns1__RemovePTZProtocol);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__RemovePTZProtocol * SOAP_FMAC4 soap_instantiate__ns1__RemovePTZProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemovePTZProtocol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__RemovePTZProtocol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__RemovePTZProtocol;
		if (size)
			*size = sizeof(_ns1__RemovePTZProtocol);
		((_ns1__RemovePTZProtocol*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__RemovePTZProtocol[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__RemovePTZProtocol);
		for (int i = 0; i < n; i++)
			((_ns1__RemovePTZProtocol*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__RemovePTZProtocol*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__RemovePTZProtocol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__RemovePTZProtocol %p -> %p\n", q, p));
	*(_ns1__RemovePTZProtocol*)p = *(_ns1__RemovePTZProtocol*)q;
}

void _ns1__AddPTZProtocolResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__AddPTZProtocolResponse::AddPTZProtocolResult);
	soap_default_int(soap, &this->_ns1__AddPTZProtocolResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__AddPTZProtocolResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__AddPTZProtocolResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddPTZProtocolResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__AddPTZProtocolResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddPTZProtocolResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddPTZProtocolResponse(struct soap *soap, const char *tag, int id, const _ns1__AddPTZProtocolResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddPTZProtocolResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:AddPTZProtocolResult");
	if (soap_out_bool(soap, "ns1:AddPTZProtocolResult", -1, &(a->_ns1__AddPTZProtocolResponse::AddPTZProtocolResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__AddPTZProtocolResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddPTZProtocolResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddPTZProtocolResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddPTZProtocolResponse * SOAP_FMAC4 soap_get__ns1__AddPTZProtocolResponse(struct soap *soap, _ns1__AddPTZProtocolResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddPTZProtocolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__AddPTZProtocolResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddPTZProtocolResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddPTZProtocolResponse * SOAP_FMAC4 soap_in__ns1__AddPTZProtocolResponse(struct soap *soap, const char *tag, _ns1__AddPTZProtocolResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddPTZProtocolResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddPTZProtocolResponse, sizeof(_ns1__AddPTZProtocolResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddPTZProtocolResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddPTZProtocolResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AddPTZProtocolResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AddPTZProtocolResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:AddPTZProtocolResult", &(a->_ns1__AddPTZProtocolResponse::AddPTZProtocolResult), "xsd:boolean"))
				{	soap_flag_AddPTZProtocolResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__AddPTZProtocolResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:AddPTZProtocolResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddPTZProtocolResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddPTZProtocolResponse, 0, sizeof(_ns1__AddPTZProtocolResponse), 0, soap_copy__ns1__AddPTZProtocolResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AddPTZProtocolResult1 > 0 || soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__AddPTZProtocolResponse * SOAP_FMAC4 soap_instantiate__ns1__AddPTZProtocolResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddPTZProtocolResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddPTZProtocolResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__AddPTZProtocolResponse;
		if (size)
			*size = sizeof(_ns1__AddPTZProtocolResponse);
		((_ns1__AddPTZProtocolResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__AddPTZProtocolResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddPTZProtocolResponse);
		for (int i = 0; i < n; i++)
			((_ns1__AddPTZProtocolResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddPTZProtocolResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddPTZProtocolResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddPTZProtocolResponse %p -> %p\n", q, p));
	*(_ns1__AddPTZProtocolResponse*)p = *(_ns1__AddPTZProtocolResponse*)q;
}

void _ns1__AddPTZProtocol::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AddPTZProtocol::filename);
	/* transient soap skipped */
}

void _ns1__AddPTZProtocol::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__AddPTZProtocol::filename);
	/* transient soap skipped */
}

int _ns1__AddPTZProtocol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AddPTZProtocol);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__AddPTZProtocol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddPTZProtocol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddPTZProtocol(struct soap *soap, const char *tag, int id, const _ns1__AddPTZProtocol *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddPTZProtocol), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:filename", -1, &(a->_ns1__AddPTZProtocol::filename), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddPTZProtocol::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddPTZProtocol(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddPTZProtocol * SOAP_FMAC4 soap_get__ns1__AddPTZProtocol(struct soap *soap, _ns1__AddPTZProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddPTZProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__AddPTZProtocol::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddPTZProtocol(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddPTZProtocol * SOAP_FMAC4 soap_in__ns1__AddPTZProtocol(struct soap *soap, const char *tag, _ns1__AddPTZProtocol *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddPTZProtocol *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddPTZProtocol, sizeof(_ns1__AddPTZProtocol), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AddPTZProtocol)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AddPTZProtocol *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_filename1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_filename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:filename", &(a->_ns1__AddPTZProtocol::filename), "xsd:string"))
				{	soap_flag_filename1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AddPTZProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddPTZProtocol, 0, sizeof(_ns1__AddPTZProtocol), 0, soap_copy__ns1__AddPTZProtocol);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__AddPTZProtocol * SOAP_FMAC4 soap_instantiate__ns1__AddPTZProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddPTZProtocol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AddPTZProtocol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__AddPTZProtocol;
		if (size)
			*size = sizeof(_ns1__AddPTZProtocol);
		((_ns1__AddPTZProtocol*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__AddPTZProtocol[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__AddPTZProtocol);
		for (int i = 0; i < n; i++)
			((_ns1__AddPTZProtocol*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__AddPTZProtocol*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AddPTZProtocol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AddPTZProtocol %p -> %p\n", q, p));
	*(_ns1__AddPTZProtocol*)p = *(_ns1__AddPTZProtocol*)q;
}

void _ns1__SetPTZProtocolResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__SetPTZProtocolResponse::SetPTZProtocolResult);
	soap_default_int(soap, &this->_ns1__SetPTZProtocolResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__SetPTZProtocolResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__SetPTZProtocolResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetPTZProtocolResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__SetPTZProtocolResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetPTZProtocolResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetPTZProtocolResponse(struct soap *soap, const char *tag, int id, const _ns1__SetPTZProtocolResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetPTZProtocolResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:SetPTZProtocolResult");
	if (soap_out_bool(soap, "ns1:SetPTZProtocolResult", -1, &(a->_ns1__SetPTZProtocolResponse::SetPTZProtocolResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__SetPTZProtocolResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetPTZProtocolResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetPTZProtocolResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetPTZProtocolResponse * SOAP_FMAC4 soap_get__ns1__SetPTZProtocolResponse(struct soap *soap, _ns1__SetPTZProtocolResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetPTZProtocolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__SetPTZProtocolResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetPTZProtocolResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetPTZProtocolResponse * SOAP_FMAC4 soap_in__ns1__SetPTZProtocolResponse(struct soap *soap, const char *tag, _ns1__SetPTZProtocolResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetPTZProtocolResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetPTZProtocolResponse, sizeof(_ns1__SetPTZProtocolResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetPTZProtocolResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetPTZProtocolResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SetPTZProtocolResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetPTZProtocolResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:SetPTZProtocolResult", &(a->_ns1__SetPTZProtocolResponse::SetPTZProtocolResult), "xsd:boolean"))
				{	soap_flag_SetPTZProtocolResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__SetPTZProtocolResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:SetPTZProtocolResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetPTZProtocolResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetPTZProtocolResponse, 0, sizeof(_ns1__SetPTZProtocolResponse), 0, soap_copy__ns1__SetPTZProtocolResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SetPTZProtocolResult1 > 0 || soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__SetPTZProtocolResponse * SOAP_FMAC4 soap_instantiate__ns1__SetPTZProtocolResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetPTZProtocolResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetPTZProtocolResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__SetPTZProtocolResponse;
		if (size)
			*size = sizeof(_ns1__SetPTZProtocolResponse);
		((_ns1__SetPTZProtocolResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__SetPTZProtocolResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SetPTZProtocolResponse);
		for (int i = 0; i < n; i++)
			((_ns1__SetPTZProtocolResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SetPTZProtocolResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetPTZProtocolResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetPTZProtocolResponse %p -> %p\n", q, p));
	*(_ns1__SetPTZProtocolResponse*)p = *(_ns1__SetPTZProtocolResponse*)q;
}

void _ns1__SetPTZProtocol::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__SetPTZProtocol::channel);
	soap_default_string(soap, &this->_ns1__SetPTZProtocol::protocolName);
	/* transient soap skipped */
}

void _ns1__SetPTZProtocol::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__SetPTZProtocol::protocolName);
	/* transient soap skipped */
}

int _ns1__SetPTZProtocol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetPTZProtocol);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__SetPTZProtocol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetPTZProtocol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetPTZProtocol(struct soap *soap, const char *tag, int id, const _ns1__SetPTZProtocol *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetPTZProtocol), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__SetPTZProtocol::channel), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:protocolName", -1, &(a->_ns1__SetPTZProtocol::protocolName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetPTZProtocol::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetPTZProtocol(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetPTZProtocol * SOAP_FMAC4 soap_get__ns1__SetPTZProtocol(struct soap *soap, _ns1__SetPTZProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetPTZProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__SetPTZProtocol::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetPTZProtocol(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetPTZProtocol * SOAP_FMAC4 soap_in__ns1__SetPTZProtocol(struct soap *soap, const char *tag, _ns1__SetPTZProtocol *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetPTZProtocol *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetPTZProtocol, sizeof(_ns1__SetPTZProtocol), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetPTZProtocol)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetPTZProtocol *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	size_t soap_flag_protocolName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__SetPTZProtocol::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			if (soap_flag_protocolName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:protocolName", &(a->_ns1__SetPTZProtocol::protocolName), "xsd:string"))
				{	soap_flag_protocolName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetPTZProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetPTZProtocol, 0, sizeof(_ns1__SetPTZProtocol), 0, soap_copy__ns1__SetPTZProtocol);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__SetPTZProtocol * SOAP_FMAC4 soap_instantiate__ns1__SetPTZProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetPTZProtocol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetPTZProtocol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__SetPTZProtocol;
		if (size)
			*size = sizeof(_ns1__SetPTZProtocol);
		((_ns1__SetPTZProtocol*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__SetPTZProtocol[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SetPTZProtocol);
		for (int i = 0; i < n; i++)
			((_ns1__SetPTZProtocol*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SetPTZProtocol*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetPTZProtocol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetPTZProtocol %p -> %p\n", q, p));
	*(_ns1__SetPTZProtocol*)p = *(_ns1__SetPTZProtocol*)q;
}

void _ns1__GetPTZProtocolResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPTZProtocolResponse::GetPTZProtocolResult);
	soap_default_int(soap, &this->_ns1__GetPTZProtocolResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__GetPTZProtocolResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPTZProtocolResponse::GetPTZProtocolResult);
	/* transient soap skipped */
}

int _ns1__GetPTZProtocolResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPTZProtocolResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetPTZProtocolResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPTZProtocolResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPTZProtocolResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPTZProtocolResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPTZProtocolResponse), type))
		return soap->error;
	if (a->GetPTZProtocolResult)
		soap_element_result(soap, "ns1:GetPTZProtocolResult");
	if (soap_out_string(soap, "ns1:GetPTZProtocolResult", -1, &(a->_ns1__GetPTZProtocolResponse::GetPTZProtocolResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__GetPTZProtocolResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPTZProtocolResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPTZProtocolResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocolResponse * SOAP_FMAC4 soap_get__ns1__GetPTZProtocolResponse(struct soap *soap, _ns1__GetPTZProtocolResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPTZProtocolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetPTZProtocolResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPTZProtocolResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocolResponse * SOAP_FMAC4 soap_in__ns1__GetPTZProtocolResponse(struct soap *soap, const char *tag, _ns1__GetPTZProtocolResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPTZProtocolResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPTZProtocolResponse, sizeof(_ns1__GetPTZProtocolResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPTZProtocolResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPTZProtocolResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPTZProtocolResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPTZProtocolResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:GetPTZProtocolResult", &(a->_ns1__GetPTZProtocolResponse::GetPTZProtocolResult), "xsd:string"))
				{	soap_flag_GetPTZProtocolResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__GetPTZProtocolResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPTZProtocolResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPTZProtocolResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPTZProtocolResponse, 0, sizeof(_ns1__GetPTZProtocolResponse), 0, soap_copy__ns1__GetPTZProtocolResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetPTZProtocolResponse * SOAP_FMAC4 soap_instantiate__ns1__GetPTZProtocolResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPTZProtocolResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPTZProtocolResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetPTZProtocolResponse;
		if (size)
			*size = sizeof(_ns1__GetPTZProtocolResponse);
		((_ns1__GetPTZProtocolResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetPTZProtocolResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPTZProtocolResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPTZProtocolResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPTZProtocolResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPTZProtocolResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPTZProtocolResponse %p -> %p\n", q, p));
	*(_ns1__GetPTZProtocolResponse*)p = *(_ns1__GetPTZProtocolResponse*)q;
}

void _ns1__GetPTZProtocol::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetPTZProtocol::channel);
	/* transient soap skipped */
}

void _ns1__GetPTZProtocol::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__GetPTZProtocol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPTZProtocol);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetPTZProtocol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPTZProtocol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPTZProtocol(struct soap *soap, const char *tag, int id, const _ns1__GetPTZProtocol *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPTZProtocol), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:channel", -1, &(a->_ns1__GetPTZProtocol::channel), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPTZProtocol::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPTZProtocol(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocol * SOAP_FMAC4 soap_get__ns1__GetPTZProtocol(struct soap *soap, _ns1__GetPTZProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPTZProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetPTZProtocol::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPTZProtocol(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocol * SOAP_FMAC4 soap_in__ns1__GetPTZProtocol(struct soap *soap, const char *tag, _ns1__GetPTZProtocol *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPTZProtocol *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPTZProtocol, sizeof(_ns1__GetPTZProtocol), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPTZProtocol)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPTZProtocol *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_channel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:channel", &(a->_ns1__GetPTZProtocol::channel), "xsd:int"))
				{	soap_flag_channel1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPTZProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPTZProtocol, 0, sizeof(_ns1__GetPTZProtocol), 0, soap_copy__ns1__GetPTZProtocol);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_channel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetPTZProtocol * SOAP_FMAC4 soap_instantiate__ns1__GetPTZProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPTZProtocol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPTZProtocol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetPTZProtocol;
		if (size)
			*size = sizeof(_ns1__GetPTZProtocol);
		((_ns1__GetPTZProtocol*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetPTZProtocol[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPTZProtocol);
		for (int i = 0; i < n; i++)
			((_ns1__GetPTZProtocol*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPTZProtocol*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPTZProtocol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPTZProtocol %p -> %p\n", q, p));
	*(_ns1__GetPTZProtocol*)p = *(_ns1__GetPTZProtocol*)q;
}

void _ns1__GetPTZProtocolListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPTZProtocolListResponse::GetPTZProtocolListResult = NULL;
	soap_default_int(soap, &this->_ns1__GetPTZProtocolListResponse::resultCode);
	/* transient soap skipped */
}

void _ns1__GetPTZProtocolListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfString(soap, &this->_ns1__GetPTZProtocolListResponse::GetPTZProtocolListResult);
	/* transient soap skipped */
}

int _ns1__GetPTZProtocolListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPTZProtocolListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetPTZProtocolListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPTZProtocolListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPTZProtocolListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPTZProtocolListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPTZProtocolListResponse), type))
		return soap->error;
	if (a->GetPTZProtocolListResult)
		soap_element_result(soap, "ns1:GetPTZProtocolListResult");
	if (soap_out_PointerTons1__ArrayOfString(soap, "ns1:GetPTZProtocolListResult", -1, &(a->_ns1__GetPTZProtocolListResponse::GetPTZProtocolListResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:resultCode", -1, &(a->_ns1__GetPTZProtocolListResponse::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPTZProtocolListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPTZProtocolListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocolListResponse * SOAP_FMAC4 soap_get__ns1__GetPTZProtocolListResponse(struct soap *soap, _ns1__GetPTZProtocolListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPTZProtocolListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetPTZProtocolListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPTZProtocolListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocolListResponse * SOAP_FMAC4 soap_in__ns1__GetPTZProtocolListResponse(struct soap *soap, const char *tag, _ns1__GetPTZProtocolListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPTZProtocolListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPTZProtocolListResponse, sizeof(_ns1__GetPTZProtocolListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPTZProtocolListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPTZProtocolListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPTZProtocolListResult1 = 1;
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPTZProtocolListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfString(soap, "ns1:GetPTZProtocolListResult", &(a->_ns1__GetPTZProtocolListResponse::GetPTZProtocolListResult), "ns1:ArrayOfString"))
				{	soap_flag_GetPTZProtocolListResult1--;
					continue;
				}
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:resultCode", &(a->_ns1__GetPTZProtocolListResponse::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPTZProtocolListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPTZProtocolListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPTZProtocolListResponse, 0, sizeof(_ns1__GetPTZProtocolListResponse), 0, soap_copy__ns1__GetPTZProtocolListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetPTZProtocolListResponse * SOAP_FMAC4 soap_instantiate__ns1__GetPTZProtocolListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPTZProtocolListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPTZProtocolListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetPTZProtocolListResponse;
		if (size)
			*size = sizeof(_ns1__GetPTZProtocolListResponse);
		((_ns1__GetPTZProtocolListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetPTZProtocolListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPTZProtocolListResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPTZProtocolListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPTZProtocolListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPTZProtocolListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPTZProtocolListResponse %p -> %p\n", q, p));
	*(_ns1__GetPTZProtocolListResponse*)p = *(_ns1__GetPTZProtocolListResponse*)q;
}

void _ns1__GetPTZProtocolList::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetPTZProtocolList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__GetPTZProtocolList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPTZProtocolList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetPTZProtocolList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPTZProtocolList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPTZProtocolList(struct soap *soap, const char *tag, int id, const _ns1__GetPTZProtocolList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPTZProtocolList), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPTZProtocolList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPTZProtocolList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocolList * SOAP_FMAC4 soap_get__ns1__GetPTZProtocolList(struct soap *soap, _ns1__GetPTZProtocolList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPTZProtocolList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__GetPTZProtocolList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPTZProtocolList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocolList * SOAP_FMAC4 soap_in__ns1__GetPTZProtocolList(struct soap *soap, const char *tag, _ns1__GetPTZProtocolList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPTZProtocolList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPTZProtocolList, sizeof(_ns1__GetPTZProtocolList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPTZProtocolList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPTZProtocolList *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPTZProtocolList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPTZProtocolList, 0, sizeof(_ns1__GetPTZProtocolList), 0, soap_copy__ns1__GetPTZProtocolList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__GetPTZProtocolList * SOAP_FMAC4 soap_instantiate__ns1__GetPTZProtocolList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPTZProtocolList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPTZProtocolList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetPTZProtocolList;
		if (size)
			*size = sizeof(_ns1__GetPTZProtocolList);
		((_ns1__GetPTZProtocolList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetPTZProtocolList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPTZProtocolList);
		for (int i = 0; i < n; i++)
			((_ns1__GetPTZProtocolList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPTZProtocolList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPTZProtocolList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPTZProtocolList %p -> %p\n", q, p));
	*(_ns1__GetPTZProtocolList*)p = *(_ns1__GetPTZProtocolList*)q;
}

void ns1__PortConfig_USCORET::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__PortConfig_USCORET::baudRate);
	soap_default_int(soap, &this->ns1__PortConfig_USCORET::dataBit);
	soap_default_ns1__PARITY_USCORET(soap, &this->ns1__PortConfig_USCORET::parity);
	soap_default_int(soap, &this->ns1__PortConfig_USCORET::stopBit);
	/* transient soap skipped */
}

void ns1__PortConfig_USCORET::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__PortConfig_USCORET::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PortConfig_USCORET);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__PortConfig_USCORET::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PortConfig_USCORET(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PortConfig_USCORET(struct soap *soap, const char *tag, int id, const ns1__PortConfig_USCORET *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PortConfig_USCORET), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:baudRate", -1, &(a->ns1__PortConfig_USCORET::baudRate), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:dataBit", -1, &(a->ns1__PortConfig_USCORET::dataBit), ""))
		return soap->error;
	if (soap_out_ns1__PARITY_USCORET(soap, "ns1:parity", -1, &(a->ns1__PortConfig_USCORET::parity), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:stopBit", -1, &(a->ns1__PortConfig_USCORET::stopBit), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PortConfig_USCORET::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PortConfig_USCORET(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PortConfig_USCORET * SOAP_FMAC4 soap_get_ns1__PortConfig_USCORET(struct soap *soap, ns1__PortConfig_USCORET *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PortConfig_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__PortConfig_USCORET::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PortConfig_USCORET(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PortConfig_USCORET * SOAP_FMAC4 soap_in_ns1__PortConfig_USCORET(struct soap *soap, const char *tag, ns1__PortConfig_USCORET *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PortConfig_USCORET *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PortConfig_USCORET, sizeof(ns1__PortConfig_USCORET), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PortConfig_USCORET)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PortConfig_USCORET *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_baudRate1 = 1;
	size_t soap_flag_dataBit1 = 1;
	size_t soap_flag_parity1 = 1;
	size_t soap_flag_stopBit1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_baudRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:baudRate", &(a->ns1__PortConfig_USCORET::baudRate), "xsd:int"))
				{	soap_flag_baudRate1--;
					continue;
				}
			if (soap_flag_dataBit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:dataBit", &(a->ns1__PortConfig_USCORET::dataBit), "xsd:int"))
				{	soap_flag_dataBit1--;
					continue;
				}
			if (soap_flag_parity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__PARITY_USCORET(soap, "ns1:parity", &(a->ns1__PortConfig_USCORET::parity), "ns1:PARITY_T"))
				{	soap_flag_parity1--;
					continue;
				}
			if (soap_flag_stopBit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:stopBit", &(a->ns1__PortConfig_USCORET::stopBit), "xsd:int"))
				{	soap_flag_stopBit1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PortConfig_USCORET *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PortConfig_USCORET, 0, sizeof(ns1__PortConfig_USCORET), 0, soap_copy_ns1__PortConfig_USCORET);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_baudRate1 > 0 || soap_flag_dataBit1 > 0 || soap_flag_parity1 > 0 || soap_flag_stopBit1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__PortConfig_USCORET * SOAP_FMAC4 soap_instantiate_ns1__PortConfig_USCORET(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PortConfig_USCORET(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PortConfig_USCORET, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__PortConfig_USCORET;
		if (size)
			*size = sizeof(ns1__PortConfig_USCORET);
		((ns1__PortConfig_USCORET*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__PortConfig_USCORET[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PortConfig_USCORET);
		for (int i = 0; i < n; i++)
			((ns1__PortConfig_USCORET*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PortConfig_USCORET*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PortConfig_USCORET(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PortConfig_USCORET %p -> %p\n", q, p));
	*(ns1__PortConfig_USCORET*)p = *(ns1__PortConfig_USCORET*)q;
}

void ns1__Preset_USCORET::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__Preset_USCORET::alias);
	soap_default_int(soap, &this->ns1__Preset_USCORET::sequence);
	soap_default_int(soap, &this->ns1__Preset_USCORET::presetSpeed);
	soap_default_int(soap, &this->ns1__Preset_USCORET::parkTime);
	/* transient soap skipped */
}

void ns1__Preset_USCORET::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__Preset_USCORET::alias);
	/* transient soap skipped */
}

int ns1__Preset_USCORET::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Preset_USCORET);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__Preset_USCORET::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Preset_USCORET(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Preset_USCORET(struct soap *soap, const char *tag, int id, const ns1__Preset_USCORET *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Preset_USCORET), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:alias", -1, &(a->ns1__Preset_USCORET::alias), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:sequence", -1, &(a->ns1__Preset_USCORET::sequence), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:presetSpeed", -1, &(a->ns1__Preset_USCORET::presetSpeed), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:parkTime", -1, &(a->ns1__Preset_USCORET::parkTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Preset_USCORET::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Preset_USCORET(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Preset_USCORET * SOAP_FMAC4 soap_get_ns1__Preset_USCORET(struct soap *soap, ns1__Preset_USCORET *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Preset_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__Preset_USCORET::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Preset_USCORET(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Preset_USCORET * SOAP_FMAC4 soap_in_ns1__Preset_USCORET(struct soap *soap, const char *tag, ns1__Preset_USCORET *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Preset_USCORET *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Preset_USCORET, sizeof(ns1__Preset_USCORET), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Preset_USCORET)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Preset_USCORET *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_alias1 = 1;
	size_t soap_flag_sequence1 = 1;
	size_t soap_flag_presetSpeed1 = 1;
	size_t soap_flag_parkTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alias1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:alias", &(a->ns1__Preset_USCORET::alias), "xsd:string"))
				{	soap_flag_alias1--;
					continue;
				}
			if (soap_flag_sequence1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:sequence", &(a->ns1__Preset_USCORET::sequence), "xsd:int"))
				{	soap_flag_sequence1--;
					continue;
				}
			if (soap_flag_presetSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:presetSpeed", &(a->ns1__Preset_USCORET::presetSpeed), "xsd:int"))
				{	soap_flag_presetSpeed1--;
					continue;
				}
			if (soap_flag_parkTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:parkTime", &(a->ns1__Preset_USCORET::parkTime), "xsd:int"))
				{	soap_flag_parkTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Preset_USCORET *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Preset_USCORET, 0, sizeof(ns1__Preset_USCORET), 0, soap_copy_ns1__Preset_USCORET);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sequence1 > 0 || soap_flag_presetSpeed1 > 0 || soap_flag_parkTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__Preset_USCORET * SOAP_FMAC4 soap_instantiate_ns1__Preset_USCORET(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Preset_USCORET(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Preset_USCORET, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Preset_USCORET;
		if (size)
			*size = sizeof(ns1__Preset_USCORET);
		((ns1__Preset_USCORET*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Preset_USCORET[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Preset_USCORET);
		for (int i = 0; i < n; i++)
			((ns1__Preset_USCORET*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Preset_USCORET*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Preset_USCORET(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Preset_USCORET %p -> %p\n", q, p));
	*(ns1__Preset_USCORET*)p = *(ns1__Preset_USCORET*)q;
}

void ns1__ArrayOfPreset_USCORET::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfPreset_USCORET::__sizePreset_USCORET = 0;
	this->ns1__ArrayOfPreset_USCORET::Preset_USCORET = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfPreset_USCORET::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfPreset_USCORET::Preset_USCORET)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfPreset_USCORET::__sizePreset_USCORET; i++)
		{
			soap_serialize_PointerTons1__Preset_USCORET(soap, this->ns1__ArrayOfPreset_USCORET::Preset_USCORET + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfPreset_USCORET::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfPreset_USCORET);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfPreset_USCORET::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfPreset_USCORET(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfPreset_USCORET(struct soap *soap, const char *tag, int id, const ns1__ArrayOfPreset_USCORET *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfPreset_USCORET), type))
		return soap->error;
	if (a->ns1__ArrayOfPreset_USCORET::Preset_USCORET)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfPreset_USCORET::__sizePreset_USCORET; i++)
			if (soap_out_PointerTons1__Preset_USCORET(soap, "ns1:Preset_T", -1, a->ns1__ArrayOfPreset_USCORET::Preset_USCORET + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfPreset_USCORET::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfPreset_USCORET(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfPreset_USCORET * SOAP_FMAC4 soap_get_ns1__ArrayOfPreset_USCORET(struct soap *soap, ns1__ArrayOfPreset_USCORET *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfPreset_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ArrayOfPreset_USCORET::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfPreset_USCORET(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfPreset_USCORET * SOAP_FMAC4 soap_in_ns1__ArrayOfPreset_USCORET(struct soap *soap, const char *tag, ns1__ArrayOfPreset_USCORET *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfPreset_USCORET *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfPreset_USCORET, sizeof(ns1__ArrayOfPreset_USCORET), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfPreset_USCORET)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfPreset_USCORET *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_Preset_USCORET1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Preset_T", 1, NULL))
			{	if (a->ns1__ArrayOfPreset_USCORET::Preset_USCORET == NULL)
				{	if (soap_blist_Preset_USCORET1 == NULL)
						soap_blist_Preset_USCORET1 = soap_new_block(soap);
					a->ns1__ArrayOfPreset_USCORET::Preset_USCORET = (ns1__Preset_USCORET **)soap_push_block(soap, soap_blist_Preset_USCORET1, sizeof(ns1__Preset_USCORET *));
					if (a->ns1__ArrayOfPreset_USCORET::Preset_USCORET == NULL)
						return NULL;
					*a->ns1__ArrayOfPreset_USCORET::Preset_USCORET = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons1__Preset_USCORET(soap, "ns1:Preset_T", a->ns1__ArrayOfPreset_USCORET::Preset_USCORET, "ns1:Preset_T"))
				{	a->ns1__ArrayOfPreset_USCORET::__sizePreset_USCORET++;
					a->ns1__ArrayOfPreset_USCORET::Preset_USCORET = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfPreset_USCORET::Preset_USCORET)
			soap_pop_block(soap, soap_blist_Preset_USCORET1);
		if (a->ns1__ArrayOfPreset_USCORET::__sizePreset_USCORET)
			a->ns1__ArrayOfPreset_USCORET::Preset_USCORET = (ns1__Preset_USCORET **)soap_save_block(soap, soap_blist_Preset_USCORET1, NULL, 1);
		else
		{	a->ns1__ArrayOfPreset_USCORET::Preset_USCORET = NULL;
			if (soap_blist_Preset_USCORET1)
				soap_end_block(soap, soap_blist_Preset_USCORET1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfPreset_USCORET *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfPreset_USCORET, 0, sizeof(ns1__ArrayOfPreset_USCORET), 0, soap_copy_ns1__ArrayOfPreset_USCORET);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__ArrayOfPreset_USCORET * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfPreset_USCORET(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfPreset_USCORET(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfPreset_USCORET, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfPreset_USCORET;
		if (size)
			*size = sizeof(ns1__ArrayOfPreset_USCORET);
		((ns1__ArrayOfPreset_USCORET*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfPreset_USCORET[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfPreset_USCORET);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfPreset_USCORET*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfPreset_USCORET*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfPreset_USCORET(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfPreset_USCORET %p -> %p\n", q, p));
	*(ns1__ArrayOfPreset_USCORET*)p = *(ns1__ArrayOfPreset_USCORET*)q;
}

void ns1__Parameter_USCORET::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__Parameter_USCORET::key);
	soap_default_string(soap, &this->ns1__Parameter_USCORET::value);
	/* transient soap skipped */
}

void ns1__Parameter_USCORET::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__Parameter_USCORET::key);
	soap_serialize_string(soap, &this->ns1__Parameter_USCORET::value);
	/* transient soap skipped */
}

int ns1__Parameter_USCORET::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Parameter_USCORET);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__Parameter_USCORET::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Parameter_USCORET(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Parameter_USCORET(struct soap *soap, const char *tag, int id, const ns1__Parameter_USCORET *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Parameter_USCORET), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:key", -1, &(a->ns1__Parameter_USCORET::key), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:value", -1, &(a->ns1__Parameter_USCORET::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Parameter_USCORET::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Parameter_USCORET(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Parameter_USCORET * SOAP_FMAC4 soap_get_ns1__Parameter_USCORET(struct soap *soap, ns1__Parameter_USCORET *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Parameter_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__Parameter_USCORET::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Parameter_USCORET(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Parameter_USCORET * SOAP_FMAC4 soap_in_ns1__Parameter_USCORET(struct soap *soap, const char *tag, ns1__Parameter_USCORET *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Parameter_USCORET *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Parameter_USCORET, sizeof(ns1__Parameter_USCORET), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Parameter_USCORET)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Parameter_USCORET *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_key1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:key", &(a->ns1__Parameter_USCORET::key), "xsd:string"))
				{	soap_flag_key1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:value", &(a->ns1__Parameter_USCORET::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Parameter_USCORET *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Parameter_USCORET, 0, sizeof(ns1__Parameter_USCORET), 0, soap_copy_ns1__Parameter_USCORET);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__Parameter_USCORET * SOAP_FMAC4 soap_instantiate_ns1__Parameter_USCORET(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Parameter_USCORET(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Parameter_USCORET, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Parameter_USCORET;
		if (size)
			*size = sizeof(ns1__Parameter_USCORET);
		((ns1__Parameter_USCORET*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Parameter_USCORET[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Parameter_USCORET);
		for (int i = 0; i < n; i++)
			((ns1__Parameter_USCORET*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Parameter_USCORET*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Parameter_USCORET(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Parameter_USCORET %p -> %p\n", q, p));
	*(ns1__Parameter_USCORET*)p = *(ns1__Parameter_USCORET*)q;
}

void ns1__ArrayOfParameter_USCORET::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfParameter_USCORET::__sizeParameter_USCORET = 0;
	this->ns1__ArrayOfParameter_USCORET::Parameter_USCORET = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfParameter_USCORET::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfParameter_USCORET::Parameter_USCORET)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfParameter_USCORET::__sizeParameter_USCORET; i++)
		{
			soap_serialize_PointerTons1__Parameter_USCORET(soap, this->ns1__ArrayOfParameter_USCORET::Parameter_USCORET + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfParameter_USCORET::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfParameter_USCORET);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfParameter_USCORET::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfParameter_USCORET(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfParameter_USCORET(struct soap *soap, const char *tag, int id, const ns1__ArrayOfParameter_USCORET *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfParameter_USCORET), type))
		return soap->error;
	if (a->ns1__ArrayOfParameter_USCORET::Parameter_USCORET)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfParameter_USCORET::__sizeParameter_USCORET; i++)
			if (soap_out_PointerTons1__Parameter_USCORET(soap, "ns1:Parameter_T", -1, a->ns1__ArrayOfParameter_USCORET::Parameter_USCORET + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfParameter_USCORET::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfParameter_USCORET(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfParameter_USCORET * SOAP_FMAC4 soap_get_ns1__ArrayOfParameter_USCORET(struct soap *soap, ns1__ArrayOfParameter_USCORET *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfParameter_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ArrayOfParameter_USCORET::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfParameter_USCORET(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfParameter_USCORET * SOAP_FMAC4 soap_in_ns1__ArrayOfParameter_USCORET(struct soap *soap, const char *tag, ns1__ArrayOfParameter_USCORET *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfParameter_USCORET *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfParameter_USCORET, sizeof(ns1__ArrayOfParameter_USCORET), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfParameter_USCORET)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfParameter_USCORET *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_Parameter_USCORET1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Parameter_T", 1, NULL))
			{	if (a->ns1__ArrayOfParameter_USCORET::Parameter_USCORET == NULL)
				{	if (soap_blist_Parameter_USCORET1 == NULL)
						soap_blist_Parameter_USCORET1 = soap_new_block(soap);
					a->ns1__ArrayOfParameter_USCORET::Parameter_USCORET = (ns1__Parameter_USCORET **)soap_push_block(soap, soap_blist_Parameter_USCORET1, sizeof(ns1__Parameter_USCORET *));
					if (a->ns1__ArrayOfParameter_USCORET::Parameter_USCORET == NULL)
						return NULL;
					*a->ns1__ArrayOfParameter_USCORET::Parameter_USCORET = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons1__Parameter_USCORET(soap, "ns1:Parameter_T", a->ns1__ArrayOfParameter_USCORET::Parameter_USCORET, "ns1:Parameter_T"))
				{	a->ns1__ArrayOfParameter_USCORET::__sizeParameter_USCORET++;
					a->ns1__ArrayOfParameter_USCORET::Parameter_USCORET = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfParameter_USCORET::Parameter_USCORET)
			soap_pop_block(soap, soap_blist_Parameter_USCORET1);
		if (a->ns1__ArrayOfParameter_USCORET::__sizeParameter_USCORET)
			a->ns1__ArrayOfParameter_USCORET::Parameter_USCORET = (ns1__Parameter_USCORET **)soap_save_block(soap, soap_blist_Parameter_USCORET1, NULL, 1);
		else
		{	a->ns1__ArrayOfParameter_USCORET::Parameter_USCORET = NULL;
			if (soap_blist_Parameter_USCORET1)
				soap_end_block(soap, soap_blist_Parameter_USCORET1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfParameter_USCORET *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfParameter_USCORET, 0, sizeof(ns1__ArrayOfParameter_USCORET), 0, soap_copy_ns1__ArrayOfParameter_USCORET);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__ArrayOfParameter_USCORET * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfParameter_USCORET(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfParameter_USCORET(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfParameter_USCORET, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfParameter_USCORET;
		if (size)
			*size = sizeof(ns1__ArrayOfParameter_USCORET);
		((ns1__ArrayOfParameter_USCORET*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfParameter_USCORET[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfParameter_USCORET);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfParameter_USCORET*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfParameter_USCORET*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfParameter_USCORET(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfParameter_USCORET %p -> %p\n", q, p));
	*(ns1__ArrayOfParameter_USCORET*)p = *(ns1__ArrayOfParameter_USCORET*)q;
}

void ns1__IntRange_USCORET::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__IntRange_USCORET::min_);
	soap_default_int(soap, &this->ns1__IntRange_USCORET::max_);
	/* transient soap skipped */
}

void ns1__IntRange_USCORET::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__IntRange_USCORET::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__IntRange_USCORET);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__IntRange_USCORET::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__IntRange_USCORET(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__IntRange_USCORET(struct soap *soap, const char *tag, int id, const ns1__IntRange_USCORET *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__IntRange_USCORET), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:min", -1, &(a->ns1__IntRange_USCORET::min_), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:max", -1, &(a->ns1__IntRange_USCORET::max_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__IntRange_USCORET::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__IntRange_USCORET(soap, this, tag, type);
}

SOAP_FMAC3 ns1__IntRange_USCORET * SOAP_FMAC4 soap_get_ns1__IntRange_USCORET(struct soap *soap, ns1__IntRange_USCORET *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__IntRange_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__IntRange_USCORET::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__IntRange_USCORET(soap, tag, this, type);
}

SOAP_FMAC3 ns1__IntRange_USCORET * SOAP_FMAC4 soap_in_ns1__IntRange_USCORET(struct soap *soap, const char *tag, ns1__IntRange_USCORET *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__IntRange_USCORET *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__IntRange_USCORET, sizeof(ns1__IntRange_USCORET), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__IntRange_USCORET)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__IntRange_USCORET *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_min_1 = 1;
	size_t soap_flag_max_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_min_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:min", &(a->ns1__IntRange_USCORET::min_), "xsd:int"))
				{	soap_flag_min_1--;
					continue;
				}
			if (soap_flag_max_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:max", &(a->ns1__IntRange_USCORET::max_), "xsd:int"))
				{	soap_flag_max_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__IntRange_USCORET *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__IntRange_USCORET, 0, sizeof(ns1__IntRange_USCORET), 0, soap_copy_ns1__IntRange_USCORET);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_min_1 > 0 || soap_flag_max_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__IntRange_USCORET * SOAP_FMAC4 soap_instantiate_ns1__IntRange_USCORET(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__IntRange_USCORET(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__IntRange_USCORET, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__IntRange_USCORET;
		if (size)
			*size = sizeof(ns1__IntRange_USCORET);
		((ns1__IntRange_USCORET*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__IntRange_USCORET[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__IntRange_USCORET);
		for (int i = 0; i < n; i++)
			((ns1__IntRange_USCORET*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__IntRange_USCORET*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__IntRange_USCORET(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__IntRange_USCORET %p -> %p\n", q, p));
	*(ns1__IntRange_USCORET*)p = *(ns1__IntRange_USCORET*)q;
}

void ns1__PTZProtocol_USCORET::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__PTZProtocol_USCORET::name);
	this->ns1__PTZProtocol_USCORET::presetIDRange = NULL;
	this->ns1__PTZProtocol_USCORET::panSpeedRange = NULL;
	this->ns1__PTZProtocol_USCORET::tiltSpeedRange = NULL;
	this->ns1__PTZProtocol_USCORET::zoomSpeedRange = NULL;
	this->ns1__PTZProtocol_USCORET::focusSpeedRange = NULL;
	this->ns1__PTZProtocol_USCORET::cameraIDRange = NULL;
	this->ns1__PTZProtocol_USCORET::presetSpeedRange = NULL;
	this->ns1__PTZProtocol_USCORET::parkTimeRange = NULL;
	/* transient soap skipped */
}

void ns1__PTZProtocol_USCORET::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__PTZProtocol_USCORET::name);
	soap_serialize_PointerTons1__IntRange_USCORET(soap, &this->ns1__PTZProtocol_USCORET::presetIDRange);
	soap_serialize_PointerTons1__IntRange_USCORET(soap, &this->ns1__PTZProtocol_USCORET::panSpeedRange);
	soap_serialize_PointerTons1__IntRange_USCORET(soap, &this->ns1__PTZProtocol_USCORET::tiltSpeedRange);
	soap_serialize_PointerTons1__IntRange_USCORET(soap, &this->ns1__PTZProtocol_USCORET::zoomSpeedRange);
	soap_serialize_PointerTons1__IntRange_USCORET(soap, &this->ns1__PTZProtocol_USCORET::focusSpeedRange);
	soap_serialize_PointerTons1__IntRange_USCORET(soap, &this->ns1__PTZProtocol_USCORET::cameraIDRange);
	soap_serialize_PointerTons1__IntRange_USCORET(soap, &this->ns1__PTZProtocol_USCORET::presetSpeedRange);
	soap_serialize_PointerTons1__IntRange_USCORET(soap, &this->ns1__PTZProtocol_USCORET::parkTimeRange);
	/* transient soap skipped */
}

int ns1__PTZProtocol_USCORET::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PTZProtocol_USCORET);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__PTZProtocol_USCORET::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PTZProtocol_USCORET(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PTZProtocol_USCORET(struct soap *soap, const char *tag, int id, const ns1__PTZProtocol_USCORET *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PTZProtocol_USCORET), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:name", -1, &(a->ns1__PTZProtocol_USCORET::name), ""))
		return soap->error;
	if (soap_out_PointerTons1__IntRange_USCORET(soap, "ns1:presetIDRange", -1, &(a->ns1__PTZProtocol_USCORET::presetIDRange), ""))
		return soap->error;
	if (soap_out_PointerTons1__IntRange_USCORET(soap, "ns1:panSpeedRange", -1, &(a->ns1__PTZProtocol_USCORET::panSpeedRange), ""))
		return soap->error;
	if (soap_out_PointerTons1__IntRange_USCORET(soap, "ns1:tiltSpeedRange", -1, &(a->ns1__PTZProtocol_USCORET::tiltSpeedRange), ""))
		return soap->error;
	if (soap_out_PointerTons1__IntRange_USCORET(soap, "ns1:zoomSpeedRange", -1, &(a->ns1__PTZProtocol_USCORET::zoomSpeedRange), ""))
		return soap->error;
	if (soap_out_PointerTons1__IntRange_USCORET(soap, "ns1:focusSpeedRange", -1, &(a->ns1__PTZProtocol_USCORET::focusSpeedRange), ""))
		return soap->error;
	if (soap_out_PointerTons1__IntRange_USCORET(soap, "ns1:cameraIDRange", -1, &(a->ns1__PTZProtocol_USCORET::cameraIDRange), ""))
		return soap->error;
	if (soap_out_PointerTons1__IntRange_USCORET(soap, "ns1:presetSpeedRange", -1, &(a->ns1__PTZProtocol_USCORET::presetSpeedRange), ""))
		return soap->error;
	if (soap_out_PointerTons1__IntRange_USCORET(soap, "ns1:parkTimeRange", -1, &(a->ns1__PTZProtocol_USCORET::parkTimeRange), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PTZProtocol_USCORET::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PTZProtocol_USCORET(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PTZProtocol_USCORET * SOAP_FMAC4 soap_get_ns1__PTZProtocol_USCORET(struct soap *soap, ns1__PTZProtocol_USCORET *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PTZProtocol_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__PTZProtocol_USCORET::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PTZProtocol_USCORET(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PTZProtocol_USCORET * SOAP_FMAC4 soap_in_ns1__PTZProtocol_USCORET(struct soap *soap, const char *tag, ns1__PTZProtocol_USCORET *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PTZProtocol_USCORET *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PTZProtocol_USCORET, sizeof(ns1__PTZProtocol_USCORET), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PTZProtocol_USCORET)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PTZProtocol_USCORET *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_presetIDRange1 = 1;
	size_t soap_flag_panSpeedRange1 = 1;
	size_t soap_flag_tiltSpeedRange1 = 1;
	size_t soap_flag_zoomSpeedRange1 = 1;
	size_t soap_flag_focusSpeedRange1 = 1;
	size_t soap_flag_cameraIDRange1 = 1;
	size_t soap_flag_presetSpeedRange1 = 1;
	size_t soap_flag_parkTimeRange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:name", &(a->ns1__PTZProtocol_USCORET::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_presetIDRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__IntRange_USCORET(soap, "ns1:presetIDRange", &(a->ns1__PTZProtocol_USCORET::presetIDRange), "ns1:IntRange_T"))
				{	soap_flag_presetIDRange1--;
					continue;
				}
			if (soap_flag_panSpeedRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__IntRange_USCORET(soap, "ns1:panSpeedRange", &(a->ns1__PTZProtocol_USCORET::panSpeedRange), "ns1:IntRange_T"))
				{	soap_flag_panSpeedRange1--;
					continue;
				}
			if (soap_flag_tiltSpeedRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__IntRange_USCORET(soap, "ns1:tiltSpeedRange", &(a->ns1__PTZProtocol_USCORET::tiltSpeedRange), "ns1:IntRange_T"))
				{	soap_flag_tiltSpeedRange1--;
					continue;
				}
			if (soap_flag_zoomSpeedRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__IntRange_USCORET(soap, "ns1:zoomSpeedRange", &(a->ns1__PTZProtocol_USCORET::zoomSpeedRange), "ns1:IntRange_T"))
				{	soap_flag_zoomSpeedRange1--;
					continue;
				}
			if (soap_flag_focusSpeedRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__IntRange_USCORET(soap, "ns1:focusSpeedRange", &(a->ns1__PTZProtocol_USCORET::focusSpeedRange), "ns1:IntRange_T"))
				{	soap_flag_focusSpeedRange1--;
					continue;
				}
			if (soap_flag_cameraIDRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__IntRange_USCORET(soap, "ns1:cameraIDRange", &(a->ns1__PTZProtocol_USCORET::cameraIDRange), "ns1:IntRange_T"))
				{	soap_flag_cameraIDRange1--;
					continue;
				}
			if (soap_flag_presetSpeedRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__IntRange_USCORET(soap, "ns1:presetSpeedRange", &(a->ns1__PTZProtocol_USCORET::presetSpeedRange), "ns1:IntRange_T"))
				{	soap_flag_presetSpeedRange1--;
					continue;
				}
			if (soap_flag_parkTimeRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__IntRange_USCORET(soap, "ns1:parkTimeRange", &(a->ns1__PTZProtocol_USCORET::parkTimeRange), "ns1:IntRange_T"))
				{	soap_flag_parkTimeRange1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PTZProtocol_USCORET *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PTZProtocol_USCORET, 0, sizeof(ns1__PTZProtocol_USCORET), 0, soap_copy_ns1__PTZProtocol_USCORET);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__PTZProtocol_USCORET * SOAP_FMAC4 soap_instantiate_ns1__PTZProtocol_USCORET(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PTZProtocol_USCORET(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PTZProtocol_USCORET, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__PTZProtocol_USCORET;
		if (size)
			*size = sizeof(ns1__PTZProtocol_USCORET);
		((ns1__PTZProtocol_USCORET*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__PTZProtocol_USCORET[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PTZProtocol_USCORET);
		for (int i = 0; i < n; i++)
			((ns1__PTZProtocol_USCORET*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PTZProtocol_USCORET*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PTZProtocol_USCORET(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PTZProtocol_USCORET %p -> %p\n", q, p));
	*(ns1__PTZProtocol_USCORET*)p = *(ns1__PTZProtocol_USCORET*)q;
}

void ns1__ArrayOfString::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfString::__sizestring = 0;
	this->ns1__ArrayOfString::string = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfString::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfString::string)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfString::__sizestring; i++)
		{
			soap_serialize_string(soap, this->ns1__ArrayOfString::string + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfString::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfString);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfString::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfString(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfString(struct soap *soap, const char *tag, int id, const ns1__ArrayOfString *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfString), type))
		return soap->error;
	if (a->ns1__ArrayOfString::string)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfString::__sizestring; i++)
			if (soap_out_string(soap, "ns1:string", -1, a->ns1__ArrayOfString::string + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfString::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfString(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_get_ns1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ArrayOfString::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfString(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_in_ns1__ArrayOfString(struct soap *soap, const char *tag, ns1__ArrayOfString *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfString *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfString)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfString *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_string1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:string", 1, NULL))
			{	if (a->ns1__ArrayOfString::string == NULL)
				{	if (soap_blist_string1 == NULL)
						soap_blist_string1 = soap_new_block(soap);
					a->ns1__ArrayOfString::string = (char **)soap_push_block(soap, soap_blist_string1, sizeof(char *));
					if (a->ns1__ArrayOfString::string == NULL)
						return NULL;
					*a->ns1__ArrayOfString::string = NULL;
				}soap_revert(soap);
				if (soap_in_string(soap, "ns1:string", a->ns1__ArrayOfString::string, "xsd:string"))
				{	a->ns1__ArrayOfString::__sizestring++;
					a->ns1__ArrayOfString::string = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfString::string)
			soap_pop_block(soap, soap_blist_string1);
		if (a->ns1__ArrayOfString::__sizestring)
			a->ns1__ArrayOfString::string = (char **)soap_save_block(soap, soap_blist_string1, NULL, 1);
		else
		{	a->ns1__ArrayOfString::string = NULL;
			if (soap_blist_string1)
				soap_end_block(soap, soap_blist_string1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfString, 0, sizeof(ns1__ArrayOfString), 0, soap_copy_ns1__ArrayOfString);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfString(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfString, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfString;
		if (size)
			*size = sizeof(ns1__ArrayOfString);
		((ns1__ArrayOfString*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfString[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfString);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfString*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfString*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfString(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfString %p -> %p\n", q, p));
	*(ns1__ArrayOfString*)p = *(ns1__ArrayOfString*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__OSDMenu(struct soap *soap, struct __ns3__OSDMenu *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OSDMenu = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__OSDMenu(struct soap *soap, const struct __ns3__OSDMenu *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__OSDMenu(soap, &a->ns1__OSDMenu);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__OSDMenu(struct soap *soap, const struct __ns3__OSDMenu *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__OSDMenu(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__OSDMenu(struct soap *soap, const char *tag, int id, const struct __ns3__OSDMenu *a, const char *type)
{
	if (soap_out_PointerTo_ns1__OSDMenu(soap, "ns1:OSDMenu", -1, &a->ns1__OSDMenu, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__OSDMenu * SOAP_FMAC4 soap_get___ns3__OSDMenu(struct soap *soap, struct __ns3__OSDMenu *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__OSDMenu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__OSDMenu * SOAP_FMAC4 soap_in___ns3__OSDMenu(struct soap *soap, const char *tag, struct __ns3__OSDMenu *a, const char *type)
{
	size_t soap_flag_ns1__OSDMenu = 1;
	short soap_flag;
	a = (struct __ns3__OSDMenu *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__OSDMenu, sizeof(struct __ns3__OSDMenu), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__OSDMenu(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OSDMenu && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__OSDMenu(soap, "ns1:OSDMenu", &a->ns1__OSDMenu, ""))
				{	soap_flag_ns1__OSDMenu--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__OSDMenu * SOAP_FMAC4 soap_instantiate___ns3__OSDMenu(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__OSDMenu(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__OSDMenu, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__OSDMenu;
		if (size)
			*size = sizeof(struct __ns3__OSDMenu);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__OSDMenu[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__OSDMenu);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__OSDMenu*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__OSDMenu(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__OSDMenu %p -> %p\n", q, p));
	*(struct __ns3__OSDMenu*)p = *(struct __ns3__OSDMenu*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__PTZByPass(struct soap *soap, struct __ns3__PTZByPass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PTZByPass = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__PTZByPass(struct soap *soap, const struct __ns3__PTZByPass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PTZByPass(soap, &a->ns1__PTZByPass);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__PTZByPass(struct soap *soap, const struct __ns3__PTZByPass *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__PTZByPass(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__PTZByPass(struct soap *soap, const char *tag, int id, const struct __ns3__PTZByPass *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PTZByPass(soap, "ns1:PTZByPass", -1, &a->ns1__PTZByPass, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__PTZByPass * SOAP_FMAC4 soap_get___ns3__PTZByPass(struct soap *soap, struct __ns3__PTZByPass *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__PTZByPass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__PTZByPass * SOAP_FMAC4 soap_in___ns3__PTZByPass(struct soap *soap, const char *tag, struct __ns3__PTZByPass *a, const char *type)
{
	size_t soap_flag_ns1__PTZByPass = 1;
	short soap_flag;
	a = (struct __ns3__PTZByPass *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__PTZByPass, sizeof(struct __ns3__PTZByPass), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__PTZByPass(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PTZByPass && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PTZByPass(soap, "ns1:PTZByPass", &a->ns1__PTZByPass, ""))
				{	soap_flag_ns1__PTZByPass--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__PTZByPass * SOAP_FMAC4 soap_instantiate___ns3__PTZByPass(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__PTZByPass(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__PTZByPass, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__PTZByPass;
		if (size)
			*size = sizeof(struct __ns3__PTZByPass);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__PTZByPass[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__PTZByPass);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__PTZByPass*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__PTZByPass(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__PTZByPass %p -> %p\n", q, p));
	*(struct __ns3__PTZByPass*)p = *(struct __ns3__PTZByPass*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__SetPTZPort(struct soap *soap, struct __ns3__SetPTZPort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetPTZPort = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__SetPTZPort(struct soap *soap, const struct __ns3__SetPTZPort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetPTZPort(soap, &a->ns1__SetPTZPort);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__SetPTZPort(struct soap *soap, const struct __ns3__SetPTZPort *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__SetPTZPort(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__SetPTZPort(struct soap *soap, const char *tag, int id, const struct __ns3__SetPTZPort *a, const char *type)
{
	if (soap_out_PointerTo_ns1__SetPTZPort(soap, "ns1:SetPTZPort", -1, &a->ns1__SetPTZPort, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__SetPTZPort * SOAP_FMAC4 soap_get___ns3__SetPTZPort(struct soap *soap, struct __ns3__SetPTZPort *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__SetPTZPort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__SetPTZPort * SOAP_FMAC4 soap_in___ns3__SetPTZPort(struct soap *soap, const char *tag, struct __ns3__SetPTZPort *a, const char *type)
{
	size_t soap_flag_ns1__SetPTZPort = 1;
	short soap_flag;
	a = (struct __ns3__SetPTZPort *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__SetPTZPort, sizeof(struct __ns3__SetPTZPort), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__SetPTZPort(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetPTZPort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetPTZPort(soap, "ns1:SetPTZPort", &a->ns1__SetPTZPort, ""))
				{	soap_flag_ns1__SetPTZPort--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__SetPTZPort * SOAP_FMAC4 soap_instantiate___ns3__SetPTZPort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__SetPTZPort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__SetPTZPort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__SetPTZPort;
		if (size)
			*size = sizeof(struct __ns3__SetPTZPort);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__SetPTZPort[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__SetPTZPort);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__SetPTZPort*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__SetPTZPort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__SetPTZPort %p -> %p\n", q, p));
	*(struct __ns3__SetPTZPort*)p = *(struct __ns3__SetPTZPort*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetPTZPort(struct soap *soap, struct __ns3__GetPTZPort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPTZPort = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetPTZPort(struct soap *soap, const struct __ns3__GetPTZPort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPTZPort(soap, &a->ns1__GetPTZPort);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetPTZPort(struct soap *soap, const struct __ns3__GetPTZPort *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetPTZPort(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetPTZPort(struct soap *soap, const char *tag, int id, const struct __ns3__GetPTZPort *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPTZPort(soap, "ns1:GetPTZPort", -1, &a->ns1__GetPTZPort, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPTZPort * SOAP_FMAC4 soap_get___ns3__GetPTZPort(struct soap *soap, struct __ns3__GetPTZPort *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetPTZPort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__GetPTZPort * SOAP_FMAC4 soap_in___ns3__GetPTZPort(struct soap *soap, const char *tag, struct __ns3__GetPTZPort *a, const char *type)
{
	size_t soap_flag_ns1__GetPTZPort = 1;
	short soap_flag;
	a = (struct __ns3__GetPTZPort *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetPTZPort, sizeof(struct __ns3__GetPTZPort), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetPTZPort(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPTZPort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPTZPort(soap, "ns1:GetPTZPort", &a->ns1__GetPTZPort, ""))
				{	soap_flag_ns1__GetPTZPort--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__GetPTZPort * SOAP_FMAC4 soap_instantiate___ns3__GetPTZPort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetPTZPort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetPTZPort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__GetPTZPort;
		if (size)
			*size = sizeof(struct __ns3__GetPTZPort);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__GetPTZPort[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetPTZPort);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetPTZPort*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetPTZPort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetPTZPort %p -> %p\n", q, p));
	*(struct __ns3__GetPTZPort*)p = *(struct __ns3__GetPTZPort*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__SetPTZConfiguration(struct soap *soap, struct __ns3__SetPTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetPTZConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__SetPTZConfiguration(struct soap *soap, const struct __ns3__SetPTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetPTZConfiguration(soap, &a->ns1__SetPTZConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__SetPTZConfiguration(struct soap *soap, const struct __ns3__SetPTZConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__SetPTZConfiguration(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__SetPTZConfiguration(struct soap *soap, const char *tag, int id, const struct __ns3__SetPTZConfiguration *a, const char *type)
{
	if (soap_out_PointerTo_ns1__SetPTZConfiguration(soap, "ns1:SetPTZConfiguration", -1, &a->ns1__SetPTZConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__SetPTZConfiguration * SOAP_FMAC4 soap_get___ns3__SetPTZConfiguration(struct soap *soap, struct __ns3__SetPTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__SetPTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__SetPTZConfiguration * SOAP_FMAC4 soap_in___ns3__SetPTZConfiguration(struct soap *soap, const char *tag, struct __ns3__SetPTZConfiguration *a, const char *type)
{
	size_t soap_flag_ns1__SetPTZConfiguration = 1;
	short soap_flag;
	a = (struct __ns3__SetPTZConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__SetPTZConfiguration, sizeof(struct __ns3__SetPTZConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__SetPTZConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetPTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetPTZConfiguration(soap, "ns1:SetPTZConfiguration", &a->ns1__SetPTZConfiguration, ""))
				{	soap_flag_ns1__SetPTZConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__SetPTZConfiguration * SOAP_FMAC4 soap_instantiate___ns3__SetPTZConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__SetPTZConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__SetPTZConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__SetPTZConfiguration;
		if (size)
			*size = sizeof(struct __ns3__SetPTZConfiguration);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__SetPTZConfiguration[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__SetPTZConfiguration);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__SetPTZConfiguration*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__SetPTZConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__SetPTZConfiguration %p -> %p\n", q, p));
	*(struct __ns3__SetPTZConfiguration*)p = *(struct __ns3__SetPTZConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetPTZConfiguration(struct soap *soap, struct __ns3__GetPTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPTZConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetPTZConfiguration(struct soap *soap, const struct __ns3__GetPTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPTZConfiguration(soap, &a->ns1__GetPTZConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetPTZConfiguration(struct soap *soap, const struct __ns3__GetPTZConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetPTZConfiguration(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetPTZConfiguration(struct soap *soap, const char *tag, int id, const struct __ns3__GetPTZConfiguration *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPTZConfiguration(soap, "ns1:GetPTZConfiguration", -1, &a->ns1__GetPTZConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPTZConfiguration * SOAP_FMAC4 soap_get___ns3__GetPTZConfiguration(struct soap *soap, struct __ns3__GetPTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetPTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__GetPTZConfiguration * SOAP_FMAC4 soap_in___ns3__GetPTZConfiguration(struct soap *soap, const char *tag, struct __ns3__GetPTZConfiguration *a, const char *type)
{
	size_t soap_flag_ns1__GetPTZConfiguration = 1;
	short soap_flag;
	a = (struct __ns3__GetPTZConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetPTZConfiguration, sizeof(struct __ns3__GetPTZConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetPTZConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPTZConfiguration(soap, "ns1:GetPTZConfiguration", &a->ns1__GetPTZConfiguration, ""))
				{	soap_flag_ns1__GetPTZConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__GetPTZConfiguration * SOAP_FMAC4 soap_instantiate___ns3__GetPTZConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetPTZConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetPTZConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__GetPTZConfiguration;
		if (size)
			*size = sizeof(struct __ns3__GetPTZConfiguration);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__GetPTZConfiguration[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetPTZConfiguration);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetPTZConfiguration*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetPTZConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetPTZConfiguration %p -> %p\n", q, p));
	*(struct __ns3__GetPTZConfiguration*)p = *(struct __ns3__GetPTZConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__StopRecordedPattern(struct soap *soap, struct __ns3__StopRecordedPattern *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StopRecordedPattern = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__StopRecordedPattern(struct soap *soap, const struct __ns3__StopRecordedPattern *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__StopRecordedPattern(soap, &a->ns1__StopRecordedPattern);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__StopRecordedPattern(struct soap *soap, const struct __ns3__StopRecordedPattern *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__StopRecordedPattern(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__StopRecordedPattern(struct soap *soap, const char *tag, int id, const struct __ns3__StopRecordedPattern *a, const char *type)
{
	if (soap_out_PointerTo_ns1__StopRecordedPattern(soap, "ns1:StopRecordedPattern", -1, &a->ns1__StopRecordedPattern, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__StopRecordedPattern * SOAP_FMAC4 soap_get___ns3__StopRecordedPattern(struct soap *soap, struct __ns3__StopRecordedPattern *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__StopRecordedPattern(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__StopRecordedPattern * SOAP_FMAC4 soap_in___ns3__StopRecordedPattern(struct soap *soap, const char *tag, struct __ns3__StopRecordedPattern *a, const char *type)
{
	size_t soap_flag_ns1__StopRecordedPattern = 1;
	short soap_flag;
	a = (struct __ns3__StopRecordedPattern *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__StopRecordedPattern, sizeof(struct __ns3__StopRecordedPattern), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__StopRecordedPattern(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StopRecordedPattern && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StopRecordedPattern(soap, "ns1:StopRecordedPattern", &a->ns1__StopRecordedPattern, ""))
				{	soap_flag_ns1__StopRecordedPattern--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__StopRecordedPattern * SOAP_FMAC4 soap_instantiate___ns3__StopRecordedPattern(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__StopRecordedPattern(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__StopRecordedPattern, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__StopRecordedPattern;
		if (size)
			*size = sizeof(struct __ns3__StopRecordedPattern);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__StopRecordedPattern[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__StopRecordedPattern);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__StopRecordedPattern*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__StopRecordedPattern(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__StopRecordedPattern %p -> %p\n", q, p));
	*(struct __ns3__StopRecordedPattern*)p = *(struct __ns3__StopRecordedPattern*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__PlayRecordedPattern(struct soap *soap, struct __ns3__PlayRecordedPattern *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PlayRecordedPattern = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__PlayRecordedPattern(struct soap *soap, const struct __ns3__PlayRecordedPattern *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PlayRecordedPattern(soap, &a->ns1__PlayRecordedPattern);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__PlayRecordedPattern(struct soap *soap, const struct __ns3__PlayRecordedPattern *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__PlayRecordedPattern(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__PlayRecordedPattern(struct soap *soap, const char *tag, int id, const struct __ns3__PlayRecordedPattern *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PlayRecordedPattern(soap, "ns1:PlayRecordedPattern", -1, &a->ns1__PlayRecordedPattern, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__PlayRecordedPattern * SOAP_FMAC4 soap_get___ns3__PlayRecordedPattern(struct soap *soap, struct __ns3__PlayRecordedPattern *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__PlayRecordedPattern(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__PlayRecordedPattern * SOAP_FMAC4 soap_in___ns3__PlayRecordedPattern(struct soap *soap, const char *tag, struct __ns3__PlayRecordedPattern *a, const char *type)
{
	size_t soap_flag_ns1__PlayRecordedPattern = 1;
	short soap_flag;
	a = (struct __ns3__PlayRecordedPattern *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__PlayRecordedPattern, sizeof(struct __ns3__PlayRecordedPattern), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__PlayRecordedPattern(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PlayRecordedPattern && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PlayRecordedPattern(soap, "ns1:PlayRecordedPattern", &a->ns1__PlayRecordedPattern, ""))
				{	soap_flag_ns1__PlayRecordedPattern--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__PlayRecordedPattern * SOAP_FMAC4 soap_instantiate___ns3__PlayRecordedPattern(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__PlayRecordedPattern(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__PlayRecordedPattern, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__PlayRecordedPattern;
		if (size)
			*size = sizeof(struct __ns3__PlayRecordedPattern);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__PlayRecordedPattern[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__PlayRecordedPattern);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__PlayRecordedPattern*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__PlayRecordedPattern(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__PlayRecordedPattern %p -> %p\n", q, p));
	*(struct __ns3__PlayRecordedPattern*)p = *(struct __ns3__PlayRecordedPattern*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__StopPatternRecording(struct soap *soap, struct __ns3__StopPatternRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StopPatternRecording = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__StopPatternRecording(struct soap *soap, const struct __ns3__StopPatternRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__StopPatternRecording(soap, &a->ns1__StopPatternRecording);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__StopPatternRecording(struct soap *soap, const struct __ns3__StopPatternRecording *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__StopPatternRecording(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__StopPatternRecording(struct soap *soap, const char *tag, int id, const struct __ns3__StopPatternRecording *a, const char *type)
{
	if (soap_out_PointerTo_ns1__StopPatternRecording(soap, "ns1:StopPatternRecording", -1, &a->ns1__StopPatternRecording, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__StopPatternRecording * SOAP_FMAC4 soap_get___ns3__StopPatternRecording(struct soap *soap, struct __ns3__StopPatternRecording *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__StopPatternRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__StopPatternRecording * SOAP_FMAC4 soap_in___ns3__StopPatternRecording(struct soap *soap, const char *tag, struct __ns3__StopPatternRecording *a, const char *type)
{
	size_t soap_flag_ns1__StopPatternRecording = 1;
	short soap_flag;
	a = (struct __ns3__StopPatternRecording *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__StopPatternRecording, sizeof(struct __ns3__StopPatternRecording), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__StopPatternRecording(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StopPatternRecording && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StopPatternRecording(soap, "ns1:StopPatternRecording", &a->ns1__StopPatternRecording, ""))
				{	soap_flag_ns1__StopPatternRecording--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__StopPatternRecording * SOAP_FMAC4 soap_instantiate___ns3__StopPatternRecording(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__StopPatternRecording(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__StopPatternRecording, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__StopPatternRecording;
		if (size)
			*size = sizeof(struct __ns3__StopPatternRecording);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__StopPatternRecording[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__StopPatternRecording);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__StopPatternRecording*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__StopPatternRecording(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__StopPatternRecording %p -> %p\n", q, p));
	*(struct __ns3__StopPatternRecording*)p = *(struct __ns3__StopPatternRecording*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__StartPatternRecording(struct soap *soap, struct __ns3__StartPatternRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StartPatternRecording = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__StartPatternRecording(struct soap *soap, const struct __ns3__StartPatternRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__StartPatternRecording(soap, &a->ns1__StartPatternRecording);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__StartPatternRecording(struct soap *soap, const struct __ns3__StartPatternRecording *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__StartPatternRecording(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__StartPatternRecording(struct soap *soap, const char *tag, int id, const struct __ns3__StartPatternRecording *a, const char *type)
{
	if (soap_out_PointerTo_ns1__StartPatternRecording(soap, "ns1:StartPatternRecording", -1, &a->ns1__StartPatternRecording, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__StartPatternRecording * SOAP_FMAC4 soap_get___ns3__StartPatternRecording(struct soap *soap, struct __ns3__StartPatternRecording *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__StartPatternRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__StartPatternRecording * SOAP_FMAC4 soap_in___ns3__StartPatternRecording(struct soap *soap, const char *tag, struct __ns3__StartPatternRecording *a, const char *type)
{
	size_t soap_flag_ns1__StartPatternRecording = 1;
	short soap_flag;
	a = (struct __ns3__StartPatternRecording *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__StartPatternRecording, sizeof(struct __ns3__StartPatternRecording), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__StartPatternRecording(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StartPatternRecording && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StartPatternRecording(soap, "ns1:StartPatternRecording", &a->ns1__StartPatternRecording, ""))
				{	soap_flag_ns1__StartPatternRecording--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__StartPatternRecording * SOAP_FMAC4 soap_instantiate___ns3__StartPatternRecording(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__StartPatternRecording(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__StartPatternRecording, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__StartPatternRecording;
		if (size)
			*size = sizeof(struct __ns3__StartPatternRecording);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__StartPatternRecording[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__StartPatternRecording);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__StartPatternRecording*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__StartPatternRecording(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__StartPatternRecording %p -> %p\n", q, p));
	*(struct __ns3__StartPatternRecording*)p = *(struct __ns3__StartPatternRecording*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__StopPresetTour(struct soap *soap, struct __ns3__StopPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StopPresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__StopPresetTour(struct soap *soap, const struct __ns3__StopPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__StopPresetTour(soap, &a->ns1__StopPresetTour);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__StopPresetTour(struct soap *soap, const struct __ns3__StopPresetTour *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__StopPresetTour(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__StopPresetTour(struct soap *soap, const char *tag, int id, const struct __ns3__StopPresetTour *a, const char *type)
{
	if (soap_out_PointerTo_ns1__StopPresetTour(soap, "ns1:StopPresetTour", -1, &a->ns1__StopPresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__StopPresetTour * SOAP_FMAC4 soap_get___ns3__StopPresetTour(struct soap *soap, struct __ns3__StopPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__StopPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__StopPresetTour * SOAP_FMAC4 soap_in___ns3__StopPresetTour(struct soap *soap, const char *tag, struct __ns3__StopPresetTour *a, const char *type)
{
	size_t soap_flag_ns1__StopPresetTour = 1;
	short soap_flag;
	a = (struct __ns3__StopPresetTour *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__StopPresetTour, sizeof(struct __ns3__StopPresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__StopPresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StopPresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StopPresetTour(soap, "ns1:StopPresetTour", &a->ns1__StopPresetTour, ""))
				{	soap_flag_ns1__StopPresetTour--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__StopPresetTour * SOAP_FMAC4 soap_instantiate___ns3__StopPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__StopPresetTour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__StopPresetTour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__StopPresetTour;
		if (size)
			*size = sizeof(struct __ns3__StopPresetTour);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__StopPresetTour[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__StopPresetTour);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__StopPresetTour*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__StopPresetTour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__StopPresetTour %p -> %p\n", q, p));
	*(struct __ns3__StopPresetTour*)p = *(struct __ns3__StopPresetTour*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__PlayPresetTour(struct soap *soap, struct __ns3__PlayPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PlayPresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__PlayPresetTour(struct soap *soap, const struct __ns3__PlayPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PlayPresetTour(soap, &a->ns1__PlayPresetTour);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__PlayPresetTour(struct soap *soap, const struct __ns3__PlayPresetTour *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__PlayPresetTour(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__PlayPresetTour(struct soap *soap, const char *tag, int id, const struct __ns3__PlayPresetTour *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PlayPresetTour(soap, "ns1:PlayPresetTour", -1, &a->ns1__PlayPresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__PlayPresetTour * SOAP_FMAC4 soap_get___ns3__PlayPresetTour(struct soap *soap, struct __ns3__PlayPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__PlayPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__PlayPresetTour * SOAP_FMAC4 soap_in___ns3__PlayPresetTour(struct soap *soap, const char *tag, struct __ns3__PlayPresetTour *a, const char *type)
{
	size_t soap_flag_ns1__PlayPresetTour = 1;
	short soap_flag;
	a = (struct __ns3__PlayPresetTour *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__PlayPresetTour, sizeof(struct __ns3__PlayPresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__PlayPresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PlayPresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PlayPresetTour(soap, "ns1:PlayPresetTour", &a->ns1__PlayPresetTour, ""))
				{	soap_flag_ns1__PlayPresetTour--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__PlayPresetTour * SOAP_FMAC4 soap_instantiate___ns3__PlayPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__PlayPresetTour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__PlayPresetTour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__PlayPresetTour;
		if (size)
			*size = sizeof(struct __ns3__PlayPresetTour);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__PlayPresetTour[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__PlayPresetTour);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__PlayPresetTour*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__PlayPresetTour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__PlayPresetTour %p -> %p\n", q, p));
	*(struct __ns3__PlayPresetTour*)p = *(struct __ns3__PlayPresetTour*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__SetPresetTour(struct soap *soap, struct __ns3__SetPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetPresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__SetPresetTour(struct soap *soap, const struct __ns3__SetPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetPresetTour(soap, &a->ns1__SetPresetTour);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__SetPresetTour(struct soap *soap, const struct __ns3__SetPresetTour *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__SetPresetTour(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__SetPresetTour(struct soap *soap, const char *tag, int id, const struct __ns3__SetPresetTour *a, const char *type)
{
	if (soap_out_PointerTo_ns1__SetPresetTour(soap, "ns1:SetPresetTour", -1, &a->ns1__SetPresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__SetPresetTour * SOAP_FMAC4 soap_get___ns3__SetPresetTour(struct soap *soap, struct __ns3__SetPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__SetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__SetPresetTour * SOAP_FMAC4 soap_in___ns3__SetPresetTour(struct soap *soap, const char *tag, struct __ns3__SetPresetTour *a, const char *type)
{
	size_t soap_flag_ns1__SetPresetTour = 1;
	short soap_flag;
	a = (struct __ns3__SetPresetTour *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__SetPresetTour, sizeof(struct __ns3__SetPresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__SetPresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetPresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetPresetTour(soap, "ns1:SetPresetTour", &a->ns1__SetPresetTour, ""))
				{	soap_flag_ns1__SetPresetTour--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__SetPresetTour * SOAP_FMAC4 soap_instantiate___ns3__SetPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__SetPresetTour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__SetPresetTour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__SetPresetTour;
		if (size)
			*size = sizeof(struct __ns3__SetPresetTour);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__SetPresetTour[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__SetPresetTour);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__SetPresetTour*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__SetPresetTour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__SetPresetTour %p -> %p\n", q, p));
	*(struct __ns3__SetPresetTour*)p = *(struct __ns3__SetPresetTour*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetPresetTour(struct soap *soap, struct __ns3__GetPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetPresetTour(struct soap *soap, const struct __ns3__GetPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPresetTour(soap, &a->ns1__GetPresetTour);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetPresetTour(struct soap *soap, const struct __ns3__GetPresetTour *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetPresetTour(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetPresetTour(struct soap *soap, const char *tag, int id, const struct __ns3__GetPresetTour *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPresetTour(soap, "ns1:GetPresetTour", -1, &a->ns1__GetPresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPresetTour * SOAP_FMAC4 soap_get___ns3__GetPresetTour(struct soap *soap, struct __ns3__GetPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__GetPresetTour * SOAP_FMAC4 soap_in___ns3__GetPresetTour(struct soap *soap, const char *tag, struct __ns3__GetPresetTour *a, const char *type)
{
	size_t soap_flag_ns1__GetPresetTour = 1;
	short soap_flag;
	a = (struct __ns3__GetPresetTour *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetPresetTour, sizeof(struct __ns3__GetPresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetPresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPresetTour(soap, "ns1:GetPresetTour", &a->ns1__GetPresetTour, ""))
				{	soap_flag_ns1__GetPresetTour--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__GetPresetTour * SOAP_FMAC4 soap_instantiate___ns3__GetPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetPresetTour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetPresetTour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__GetPresetTour;
		if (size)
			*size = sizeof(struct __ns3__GetPresetTour);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__GetPresetTour[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetPresetTour);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetPresetTour*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetPresetTour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetPresetTour %p -> %p\n", q, p));
	*(struct __ns3__GetPresetTour*)p = *(struct __ns3__GetPresetTour*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__RemovePreset(struct soap *soap, struct __ns3__RemovePreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RemovePreset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__RemovePreset(struct soap *soap, const struct __ns3__RemovePreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__RemovePreset(soap, &a->ns1__RemovePreset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__RemovePreset(struct soap *soap, const struct __ns3__RemovePreset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__RemovePreset(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__RemovePreset(struct soap *soap, const char *tag, int id, const struct __ns3__RemovePreset *a, const char *type)
{
	if (soap_out_PointerTo_ns1__RemovePreset(soap, "ns1:RemovePreset", -1, &a->ns1__RemovePreset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__RemovePreset * SOAP_FMAC4 soap_get___ns3__RemovePreset(struct soap *soap, struct __ns3__RemovePreset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__RemovePreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__RemovePreset * SOAP_FMAC4 soap_in___ns3__RemovePreset(struct soap *soap, const char *tag, struct __ns3__RemovePreset *a, const char *type)
{
	size_t soap_flag_ns1__RemovePreset = 1;
	short soap_flag;
	a = (struct __ns3__RemovePreset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__RemovePreset, sizeof(struct __ns3__RemovePreset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__RemovePreset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RemovePreset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RemovePreset(soap, "ns1:RemovePreset", &a->ns1__RemovePreset, ""))
				{	soap_flag_ns1__RemovePreset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__RemovePreset * SOAP_FMAC4 soap_instantiate___ns3__RemovePreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__RemovePreset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__RemovePreset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__RemovePreset;
		if (size)
			*size = sizeof(struct __ns3__RemovePreset);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__RemovePreset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__RemovePreset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__RemovePreset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__RemovePreset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__RemovePreset %p -> %p\n", q, p));
	*(struct __ns3__RemovePreset*)p = *(struct __ns3__RemovePreset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GotoPreset(struct soap *soap, struct __ns3__GotoPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GotoPreset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GotoPreset(struct soap *soap, const struct __ns3__GotoPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GotoPreset(soap, &a->ns1__GotoPreset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GotoPreset(struct soap *soap, const struct __ns3__GotoPreset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GotoPreset(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GotoPreset(struct soap *soap, const char *tag, int id, const struct __ns3__GotoPreset *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GotoPreset(soap, "ns1:GotoPreset", -1, &a->ns1__GotoPreset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GotoPreset * SOAP_FMAC4 soap_get___ns3__GotoPreset(struct soap *soap, struct __ns3__GotoPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GotoPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__GotoPreset * SOAP_FMAC4 soap_in___ns3__GotoPreset(struct soap *soap, const char *tag, struct __ns3__GotoPreset *a, const char *type)
{
	size_t soap_flag_ns1__GotoPreset = 1;
	short soap_flag;
	a = (struct __ns3__GotoPreset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GotoPreset, sizeof(struct __ns3__GotoPreset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GotoPreset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GotoPreset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GotoPreset(soap, "ns1:GotoPreset", &a->ns1__GotoPreset, ""))
				{	soap_flag_ns1__GotoPreset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__GotoPreset * SOAP_FMAC4 soap_instantiate___ns3__GotoPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GotoPreset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GotoPreset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__GotoPreset;
		if (size)
			*size = sizeof(struct __ns3__GotoPreset);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__GotoPreset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GotoPreset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GotoPreset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GotoPreset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GotoPreset %p -> %p\n", q, p));
	*(struct __ns3__GotoPreset*)p = *(struct __ns3__GotoPreset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__AddPreset(struct soap *soap, struct __ns3__AddPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddPreset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__AddPreset(struct soap *soap, const struct __ns3__AddPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AddPreset(soap, &a->ns1__AddPreset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__AddPreset(struct soap *soap, const struct __ns3__AddPreset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__AddPreset(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__AddPreset(struct soap *soap, const char *tag, int id, const struct __ns3__AddPreset *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AddPreset(soap, "ns1:AddPreset", -1, &a->ns1__AddPreset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__AddPreset * SOAP_FMAC4 soap_get___ns3__AddPreset(struct soap *soap, struct __ns3__AddPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__AddPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__AddPreset * SOAP_FMAC4 soap_in___ns3__AddPreset(struct soap *soap, const char *tag, struct __ns3__AddPreset *a, const char *type)
{
	size_t soap_flag_ns1__AddPreset = 1;
	short soap_flag;
	a = (struct __ns3__AddPreset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__AddPreset, sizeof(struct __ns3__AddPreset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__AddPreset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddPreset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddPreset(soap, "ns1:AddPreset", &a->ns1__AddPreset, ""))
				{	soap_flag_ns1__AddPreset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__AddPreset * SOAP_FMAC4 soap_instantiate___ns3__AddPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__AddPreset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__AddPreset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__AddPreset;
		if (size)
			*size = sizeof(struct __ns3__AddPreset);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__AddPreset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__AddPreset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__AddPreset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__AddPreset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__AddPreset %p -> %p\n", q, p));
	*(struct __ns3__AddPreset*)p = *(struct __ns3__AddPreset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetPresetList(struct soap *soap, struct __ns3__GetPresetList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPresetList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetPresetList(struct soap *soap, const struct __ns3__GetPresetList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPresetList(soap, &a->ns1__GetPresetList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetPresetList(struct soap *soap, const struct __ns3__GetPresetList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetPresetList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetPresetList(struct soap *soap, const char *tag, int id, const struct __ns3__GetPresetList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPresetList(soap, "ns1:GetPresetList", -1, &a->ns1__GetPresetList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPresetList * SOAP_FMAC4 soap_get___ns3__GetPresetList(struct soap *soap, struct __ns3__GetPresetList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetPresetList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__GetPresetList * SOAP_FMAC4 soap_in___ns3__GetPresetList(struct soap *soap, const char *tag, struct __ns3__GetPresetList *a, const char *type)
{
	size_t soap_flag_ns1__GetPresetList = 1;
	short soap_flag;
	a = (struct __ns3__GetPresetList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetPresetList, sizeof(struct __ns3__GetPresetList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetPresetList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPresetList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPresetList(soap, "ns1:GetPresetList", &a->ns1__GetPresetList, ""))
				{	soap_flag_ns1__GetPresetList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__GetPresetList * SOAP_FMAC4 soap_instantiate___ns3__GetPresetList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetPresetList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetPresetList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__GetPresetList;
		if (size)
			*size = sizeof(struct __ns3__GetPresetList);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__GetPresetList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetPresetList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetPresetList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetPresetList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetPresetList %p -> %p\n", q, p));
	*(struct __ns3__GetPresetList*)p = *(struct __ns3__GetPresetList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__Stop(struct soap *soap, struct __ns3__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Stop = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__Stop(struct soap *soap, const struct __ns3__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__Stop(soap, &a->ns1__Stop);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__Stop(struct soap *soap, const struct __ns3__Stop *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__Stop(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__Stop(struct soap *soap, const char *tag, int id, const struct __ns3__Stop *a, const char *type)
{
	if (soap_out_PointerTo_ns1__Stop(soap, "ns1:Stop", -1, &a->ns1__Stop, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__Stop * SOAP_FMAC4 soap_get___ns3__Stop(struct soap *soap, struct __ns3__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__Stop * SOAP_FMAC4 soap_in___ns3__Stop(struct soap *soap, const char *tag, struct __ns3__Stop *a, const char *type)
{
	size_t soap_flag_ns1__Stop = 1;
	short soap_flag;
	a = (struct __ns3__Stop *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__Stop, sizeof(struct __ns3__Stop), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__Stop(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Stop && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Stop(soap, "ns1:Stop", &a->ns1__Stop, ""))
				{	soap_flag_ns1__Stop--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__Stop * SOAP_FMAC4 soap_instantiate___ns3__Stop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__Stop(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__Stop, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__Stop;
		if (size)
			*size = sizeof(struct __ns3__Stop);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__Stop[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__Stop);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__Stop*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__Stop(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__Stop %p -> %p\n", q, p));
	*(struct __ns3__Stop*)p = *(struct __ns3__Stop*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__ControlPTZ(struct soap *soap, struct __ns3__ControlPTZ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ControlPTZ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__ControlPTZ(struct soap *soap, const struct __ns3__ControlPTZ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ControlPTZ(soap, &a->ns1__ControlPTZ);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__ControlPTZ(struct soap *soap, const struct __ns3__ControlPTZ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__ControlPTZ(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__ControlPTZ(struct soap *soap, const char *tag, int id, const struct __ns3__ControlPTZ *a, const char *type)
{
	if (soap_out_PointerTo_ns1__ControlPTZ(soap, "ns1:ControlPTZ", -1, &a->ns1__ControlPTZ, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__ControlPTZ * SOAP_FMAC4 soap_get___ns3__ControlPTZ(struct soap *soap, struct __ns3__ControlPTZ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__ControlPTZ(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__ControlPTZ * SOAP_FMAC4 soap_in___ns3__ControlPTZ(struct soap *soap, const char *tag, struct __ns3__ControlPTZ *a, const char *type)
{
	size_t soap_flag_ns1__ControlPTZ = 1;
	short soap_flag;
	a = (struct __ns3__ControlPTZ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__ControlPTZ, sizeof(struct __ns3__ControlPTZ), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__ControlPTZ(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ControlPTZ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ControlPTZ(soap, "ns1:ControlPTZ", &a->ns1__ControlPTZ, ""))
				{	soap_flag_ns1__ControlPTZ--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__ControlPTZ * SOAP_FMAC4 soap_instantiate___ns3__ControlPTZ(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__ControlPTZ(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__ControlPTZ, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__ControlPTZ;
		if (size)
			*size = sizeof(struct __ns3__ControlPTZ);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__ControlPTZ[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__ControlPTZ);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__ControlPTZ*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__ControlPTZ(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__ControlPTZ %p -> %p\n", q, p));
	*(struct __ns3__ControlPTZ*)p = *(struct __ns3__ControlPTZ*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetPTZCommandList(struct soap *soap, struct __ns3__GetPTZCommandList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPTZCommandList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetPTZCommandList(struct soap *soap, const struct __ns3__GetPTZCommandList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPTZCommandList(soap, &a->ns1__GetPTZCommandList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetPTZCommandList(struct soap *soap, const struct __ns3__GetPTZCommandList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetPTZCommandList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetPTZCommandList(struct soap *soap, const char *tag, int id, const struct __ns3__GetPTZCommandList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPTZCommandList(soap, "ns1:GetPTZCommandList", -1, &a->ns1__GetPTZCommandList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPTZCommandList * SOAP_FMAC4 soap_get___ns3__GetPTZCommandList(struct soap *soap, struct __ns3__GetPTZCommandList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetPTZCommandList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__GetPTZCommandList * SOAP_FMAC4 soap_in___ns3__GetPTZCommandList(struct soap *soap, const char *tag, struct __ns3__GetPTZCommandList *a, const char *type)
{
	size_t soap_flag_ns1__GetPTZCommandList = 1;
	short soap_flag;
	a = (struct __ns3__GetPTZCommandList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetPTZCommandList, sizeof(struct __ns3__GetPTZCommandList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetPTZCommandList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPTZCommandList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPTZCommandList(soap, "ns1:GetPTZCommandList", &a->ns1__GetPTZCommandList, ""))
				{	soap_flag_ns1__GetPTZCommandList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__GetPTZCommandList * SOAP_FMAC4 soap_instantiate___ns3__GetPTZCommandList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetPTZCommandList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetPTZCommandList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__GetPTZCommandList;
		if (size)
			*size = sizeof(struct __ns3__GetPTZCommandList);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__GetPTZCommandList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetPTZCommandList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetPTZCommandList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetPTZCommandList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetPTZCommandList %p -> %p\n", q, p));
	*(struct __ns3__GetPTZCommandList*)p = *(struct __ns3__GetPTZCommandList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetPTZProtocolInfo(struct soap *soap, struct __ns3__GetPTZProtocolInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPTZProtocolInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetPTZProtocolInfo(struct soap *soap, const struct __ns3__GetPTZProtocolInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPTZProtocolInfo(soap, &a->ns1__GetPTZProtocolInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetPTZProtocolInfo(struct soap *soap, const struct __ns3__GetPTZProtocolInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetPTZProtocolInfo(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetPTZProtocolInfo(struct soap *soap, const char *tag, int id, const struct __ns3__GetPTZProtocolInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPTZProtocolInfo(soap, "ns1:GetPTZProtocolInfo", -1, &a->ns1__GetPTZProtocolInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPTZProtocolInfo * SOAP_FMAC4 soap_get___ns3__GetPTZProtocolInfo(struct soap *soap, struct __ns3__GetPTZProtocolInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetPTZProtocolInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__GetPTZProtocolInfo * SOAP_FMAC4 soap_in___ns3__GetPTZProtocolInfo(struct soap *soap, const char *tag, struct __ns3__GetPTZProtocolInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetPTZProtocolInfo = 1;
	short soap_flag;
	a = (struct __ns3__GetPTZProtocolInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetPTZProtocolInfo, sizeof(struct __ns3__GetPTZProtocolInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetPTZProtocolInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPTZProtocolInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPTZProtocolInfo(soap, "ns1:GetPTZProtocolInfo", &a->ns1__GetPTZProtocolInfo, ""))
				{	soap_flag_ns1__GetPTZProtocolInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__GetPTZProtocolInfo * SOAP_FMAC4 soap_instantiate___ns3__GetPTZProtocolInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetPTZProtocolInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetPTZProtocolInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__GetPTZProtocolInfo;
		if (size)
			*size = sizeof(struct __ns3__GetPTZProtocolInfo);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__GetPTZProtocolInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetPTZProtocolInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetPTZProtocolInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetPTZProtocolInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetPTZProtocolInfo %p -> %p\n", q, p));
	*(struct __ns3__GetPTZProtocolInfo*)p = *(struct __ns3__GetPTZProtocolInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__RemovePTZProtocol(struct soap *soap, struct __ns3__RemovePTZProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RemovePTZProtocol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__RemovePTZProtocol(struct soap *soap, const struct __ns3__RemovePTZProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__RemovePTZProtocol(soap, &a->ns1__RemovePTZProtocol);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__RemovePTZProtocol(struct soap *soap, const struct __ns3__RemovePTZProtocol *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__RemovePTZProtocol(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__RemovePTZProtocol(struct soap *soap, const char *tag, int id, const struct __ns3__RemovePTZProtocol *a, const char *type)
{
	if (soap_out_PointerTo_ns1__RemovePTZProtocol(soap, "ns1:RemovePTZProtocol", -1, &a->ns1__RemovePTZProtocol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__RemovePTZProtocol * SOAP_FMAC4 soap_get___ns3__RemovePTZProtocol(struct soap *soap, struct __ns3__RemovePTZProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__RemovePTZProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__RemovePTZProtocol * SOAP_FMAC4 soap_in___ns3__RemovePTZProtocol(struct soap *soap, const char *tag, struct __ns3__RemovePTZProtocol *a, const char *type)
{
	size_t soap_flag_ns1__RemovePTZProtocol = 1;
	short soap_flag;
	a = (struct __ns3__RemovePTZProtocol *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__RemovePTZProtocol, sizeof(struct __ns3__RemovePTZProtocol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__RemovePTZProtocol(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RemovePTZProtocol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RemovePTZProtocol(soap, "ns1:RemovePTZProtocol", &a->ns1__RemovePTZProtocol, ""))
				{	soap_flag_ns1__RemovePTZProtocol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__RemovePTZProtocol * SOAP_FMAC4 soap_instantiate___ns3__RemovePTZProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__RemovePTZProtocol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__RemovePTZProtocol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__RemovePTZProtocol;
		if (size)
			*size = sizeof(struct __ns3__RemovePTZProtocol);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__RemovePTZProtocol[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__RemovePTZProtocol);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__RemovePTZProtocol*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__RemovePTZProtocol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__RemovePTZProtocol %p -> %p\n", q, p));
	*(struct __ns3__RemovePTZProtocol*)p = *(struct __ns3__RemovePTZProtocol*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__AddPTZProtocol(struct soap *soap, struct __ns3__AddPTZProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddPTZProtocol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__AddPTZProtocol(struct soap *soap, const struct __ns3__AddPTZProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AddPTZProtocol(soap, &a->ns1__AddPTZProtocol);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__AddPTZProtocol(struct soap *soap, const struct __ns3__AddPTZProtocol *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__AddPTZProtocol(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__AddPTZProtocol(struct soap *soap, const char *tag, int id, const struct __ns3__AddPTZProtocol *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AddPTZProtocol(soap, "ns1:AddPTZProtocol", -1, &a->ns1__AddPTZProtocol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__AddPTZProtocol * SOAP_FMAC4 soap_get___ns3__AddPTZProtocol(struct soap *soap, struct __ns3__AddPTZProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__AddPTZProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__AddPTZProtocol * SOAP_FMAC4 soap_in___ns3__AddPTZProtocol(struct soap *soap, const char *tag, struct __ns3__AddPTZProtocol *a, const char *type)
{
	size_t soap_flag_ns1__AddPTZProtocol = 1;
	short soap_flag;
	a = (struct __ns3__AddPTZProtocol *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__AddPTZProtocol, sizeof(struct __ns3__AddPTZProtocol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__AddPTZProtocol(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddPTZProtocol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddPTZProtocol(soap, "ns1:AddPTZProtocol", &a->ns1__AddPTZProtocol, ""))
				{	soap_flag_ns1__AddPTZProtocol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__AddPTZProtocol * SOAP_FMAC4 soap_instantiate___ns3__AddPTZProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__AddPTZProtocol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__AddPTZProtocol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__AddPTZProtocol;
		if (size)
			*size = sizeof(struct __ns3__AddPTZProtocol);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__AddPTZProtocol[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__AddPTZProtocol);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__AddPTZProtocol*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__AddPTZProtocol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__AddPTZProtocol %p -> %p\n", q, p));
	*(struct __ns3__AddPTZProtocol*)p = *(struct __ns3__AddPTZProtocol*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__SetPTZProtocol(struct soap *soap, struct __ns3__SetPTZProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetPTZProtocol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__SetPTZProtocol(struct soap *soap, const struct __ns3__SetPTZProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetPTZProtocol(soap, &a->ns1__SetPTZProtocol);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__SetPTZProtocol(struct soap *soap, const struct __ns3__SetPTZProtocol *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__SetPTZProtocol(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__SetPTZProtocol(struct soap *soap, const char *tag, int id, const struct __ns3__SetPTZProtocol *a, const char *type)
{
	if (soap_out_PointerTo_ns1__SetPTZProtocol(soap, "ns1:SetPTZProtocol", -1, &a->ns1__SetPTZProtocol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__SetPTZProtocol * SOAP_FMAC4 soap_get___ns3__SetPTZProtocol(struct soap *soap, struct __ns3__SetPTZProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__SetPTZProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__SetPTZProtocol * SOAP_FMAC4 soap_in___ns3__SetPTZProtocol(struct soap *soap, const char *tag, struct __ns3__SetPTZProtocol *a, const char *type)
{
	size_t soap_flag_ns1__SetPTZProtocol = 1;
	short soap_flag;
	a = (struct __ns3__SetPTZProtocol *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__SetPTZProtocol, sizeof(struct __ns3__SetPTZProtocol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__SetPTZProtocol(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetPTZProtocol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetPTZProtocol(soap, "ns1:SetPTZProtocol", &a->ns1__SetPTZProtocol, ""))
				{	soap_flag_ns1__SetPTZProtocol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__SetPTZProtocol * SOAP_FMAC4 soap_instantiate___ns3__SetPTZProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__SetPTZProtocol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__SetPTZProtocol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__SetPTZProtocol;
		if (size)
			*size = sizeof(struct __ns3__SetPTZProtocol);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__SetPTZProtocol[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__SetPTZProtocol);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__SetPTZProtocol*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__SetPTZProtocol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__SetPTZProtocol %p -> %p\n", q, p));
	*(struct __ns3__SetPTZProtocol*)p = *(struct __ns3__SetPTZProtocol*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetPTZProtocol(struct soap *soap, struct __ns3__GetPTZProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPTZProtocol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetPTZProtocol(struct soap *soap, const struct __ns3__GetPTZProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPTZProtocol(soap, &a->ns1__GetPTZProtocol);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetPTZProtocol(struct soap *soap, const struct __ns3__GetPTZProtocol *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetPTZProtocol(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetPTZProtocol(struct soap *soap, const char *tag, int id, const struct __ns3__GetPTZProtocol *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPTZProtocol(soap, "ns1:GetPTZProtocol", -1, &a->ns1__GetPTZProtocol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPTZProtocol * SOAP_FMAC4 soap_get___ns3__GetPTZProtocol(struct soap *soap, struct __ns3__GetPTZProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetPTZProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__GetPTZProtocol * SOAP_FMAC4 soap_in___ns3__GetPTZProtocol(struct soap *soap, const char *tag, struct __ns3__GetPTZProtocol *a, const char *type)
{
	size_t soap_flag_ns1__GetPTZProtocol = 1;
	short soap_flag;
	a = (struct __ns3__GetPTZProtocol *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetPTZProtocol, sizeof(struct __ns3__GetPTZProtocol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetPTZProtocol(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPTZProtocol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPTZProtocol(soap, "ns1:GetPTZProtocol", &a->ns1__GetPTZProtocol, ""))
				{	soap_flag_ns1__GetPTZProtocol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__GetPTZProtocol * SOAP_FMAC4 soap_instantiate___ns3__GetPTZProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetPTZProtocol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetPTZProtocol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__GetPTZProtocol;
		if (size)
			*size = sizeof(struct __ns3__GetPTZProtocol);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__GetPTZProtocol[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetPTZProtocol);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetPTZProtocol*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetPTZProtocol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetPTZProtocol %p -> %p\n", q, p));
	*(struct __ns3__GetPTZProtocol*)p = *(struct __ns3__GetPTZProtocol*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetPTZProtocolList(struct soap *soap, struct __ns3__GetPTZProtocolList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPTZProtocolList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetPTZProtocolList(struct soap *soap, const struct __ns3__GetPTZProtocolList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPTZProtocolList(soap, &a->ns1__GetPTZProtocolList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetPTZProtocolList(struct soap *soap, const struct __ns3__GetPTZProtocolList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns3__GetPTZProtocolList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetPTZProtocolList(struct soap *soap, const char *tag, int id, const struct __ns3__GetPTZProtocolList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPTZProtocolList(soap, "ns1:GetPTZProtocolList", -1, &a->ns1__GetPTZProtocolList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetPTZProtocolList * SOAP_FMAC4 soap_get___ns3__GetPTZProtocolList(struct soap *soap, struct __ns3__GetPTZProtocolList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetPTZProtocolList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns3__GetPTZProtocolList * SOAP_FMAC4 soap_in___ns3__GetPTZProtocolList(struct soap *soap, const char *tag, struct __ns3__GetPTZProtocolList *a, const char *type)
{
	size_t soap_flag_ns1__GetPTZProtocolList = 1;
	short soap_flag;
	a = (struct __ns3__GetPTZProtocolList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetPTZProtocolList, sizeof(struct __ns3__GetPTZProtocolList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetPTZProtocolList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPTZProtocolList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPTZProtocolList(soap, "ns1:GetPTZProtocolList", &a->ns1__GetPTZProtocolList, ""))
				{	soap_flag_ns1__GetPTZProtocolList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__GetPTZProtocolList * SOAP_FMAC4 soap_instantiate___ns3__GetPTZProtocolList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__GetPTZProtocolList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__GetPTZProtocolList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns3__GetPTZProtocolList;
		if (size)
			*size = sizeof(struct __ns3__GetPTZProtocolList);
	}
	else
	{	cp->ptr = (void*)new struct __ns3__GetPTZProtocolList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns3__GetPTZProtocolList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns3__GetPTZProtocolList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__GetPTZProtocolList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__GetPTZProtocolList %p -> %p\n", q, p));
	*(struct __ns3__GetPTZProtocolList*)p = *(struct __ns3__GetPTZProtocolList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__OSDMenu(struct soap *soap, struct __ns2__OSDMenu *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OSDMenu = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__OSDMenu(struct soap *soap, const struct __ns2__OSDMenu *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__OSDMenu(soap, &a->ns1__OSDMenu);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__OSDMenu(struct soap *soap, const struct __ns2__OSDMenu *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__OSDMenu(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__OSDMenu(struct soap *soap, const char *tag, int id, const struct __ns2__OSDMenu *a, const char *type)
{
	if (soap_out_PointerTo_ns1__OSDMenu(soap, "ns1:OSDMenu", -1, &a->ns1__OSDMenu, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__OSDMenu * SOAP_FMAC4 soap_get___ns2__OSDMenu(struct soap *soap, struct __ns2__OSDMenu *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__OSDMenu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__OSDMenu * SOAP_FMAC4 soap_in___ns2__OSDMenu(struct soap *soap, const char *tag, struct __ns2__OSDMenu *a, const char *type)
{
	size_t soap_flag_ns1__OSDMenu = 1;
	short soap_flag;
	a = (struct __ns2__OSDMenu *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__OSDMenu, sizeof(struct __ns2__OSDMenu), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__OSDMenu(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OSDMenu && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__OSDMenu(soap, "ns1:OSDMenu", &a->ns1__OSDMenu, ""))
				{	soap_flag_ns1__OSDMenu--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__OSDMenu * SOAP_FMAC4 soap_instantiate___ns2__OSDMenu(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__OSDMenu(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__OSDMenu, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__OSDMenu;
		if (size)
			*size = sizeof(struct __ns2__OSDMenu);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__OSDMenu[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__OSDMenu);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__OSDMenu*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__OSDMenu(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__OSDMenu %p -> %p\n", q, p));
	*(struct __ns2__OSDMenu*)p = *(struct __ns2__OSDMenu*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__PTZByPass(struct soap *soap, struct __ns2__PTZByPass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PTZByPass = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__PTZByPass(struct soap *soap, const struct __ns2__PTZByPass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PTZByPass(soap, &a->ns1__PTZByPass);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__PTZByPass(struct soap *soap, const struct __ns2__PTZByPass *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__PTZByPass(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__PTZByPass(struct soap *soap, const char *tag, int id, const struct __ns2__PTZByPass *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PTZByPass(soap, "ns1:PTZByPass", -1, &a->ns1__PTZByPass, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__PTZByPass * SOAP_FMAC4 soap_get___ns2__PTZByPass(struct soap *soap, struct __ns2__PTZByPass *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__PTZByPass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__PTZByPass * SOAP_FMAC4 soap_in___ns2__PTZByPass(struct soap *soap, const char *tag, struct __ns2__PTZByPass *a, const char *type)
{
	size_t soap_flag_ns1__PTZByPass = 1;
	short soap_flag;
	a = (struct __ns2__PTZByPass *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__PTZByPass, sizeof(struct __ns2__PTZByPass), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__PTZByPass(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PTZByPass && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PTZByPass(soap, "ns1:PTZByPass", &a->ns1__PTZByPass, ""))
				{	soap_flag_ns1__PTZByPass--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__PTZByPass * SOAP_FMAC4 soap_instantiate___ns2__PTZByPass(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__PTZByPass(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__PTZByPass, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__PTZByPass;
		if (size)
			*size = sizeof(struct __ns2__PTZByPass);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__PTZByPass[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__PTZByPass);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__PTZByPass*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__PTZByPass(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__PTZByPass %p -> %p\n", q, p));
	*(struct __ns2__PTZByPass*)p = *(struct __ns2__PTZByPass*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__SetPTZPort(struct soap *soap, struct __ns2__SetPTZPort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetPTZPort = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__SetPTZPort(struct soap *soap, const struct __ns2__SetPTZPort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetPTZPort(soap, &a->ns1__SetPTZPort);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__SetPTZPort(struct soap *soap, const struct __ns2__SetPTZPort *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__SetPTZPort(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__SetPTZPort(struct soap *soap, const char *tag, int id, const struct __ns2__SetPTZPort *a, const char *type)
{
	if (soap_out_PointerTo_ns1__SetPTZPort(soap, "ns1:SetPTZPort", -1, &a->ns1__SetPTZPort, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__SetPTZPort * SOAP_FMAC4 soap_get___ns2__SetPTZPort(struct soap *soap, struct __ns2__SetPTZPort *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__SetPTZPort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__SetPTZPort * SOAP_FMAC4 soap_in___ns2__SetPTZPort(struct soap *soap, const char *tag, struct __ns2__SetPTZPort *a, const char *type)
{
	size_t soap_flag_ns1__SetPTZPort = 1;
	short soap_flag;
	a = (struct __ns2__SetPTZPort *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__SetPTZPort, sizeof(struct __ns2__SetPTZPort), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__SetPTZPort(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetPTZPort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetPTZPort(soap, "ns1:SetPTZPort", &a->ns1__SetPTZPort, ""))
				{	soap_flag_ns1__SetPTZPort--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__SetPTZPort * SOAP_FMAC4 soap_instantiate___ns2__SetPTZPort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__SetPTZPort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__SetPTZPort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__SetPTZPort;
		if (size)
			*size = sizeof(struct __ns2__SetPTZPort);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__SetPTZPort[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__SetPTZPort);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__SetPTZPort*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__SetPTZPort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__SetPTZPort %p -> %p\n", q, p));
	*(struct __ns2__SetPTZPort*)p = *(struct __ns2__SetPTZPort*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetPTZPort(struct soap *soap, struct __ns2__GetPTZPort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPTZPort = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetPTZPort(struct soap *soap, const struct __ns2__GetPTZPort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPTZPort(soap, &a->ns1__GetPTZPort);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetPTZPort(struct soap *soap, const struct __ns2__GetPTZPort *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetPTZPort(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetPTZPort(struct soap *soap, const char *tag, int id, const struct __ns2__GetPTZPort *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPTZPort(soap, "ns1:GetPTZPort", -1, &a->ns1__GetPTZPort, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetPTZPort * SOAP_FMAC4 soap_get___ns2__GetPTZPort(struct soap *soap, struct __ns2__GetPTZPort *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetPTZPort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__GetPTZPort * SOAP_FMAC4 soap_in___ns2__GetPTZPort(struct soap *soap, const char *tag, struct __ns2__GetPTZPort *a, const char *type)
{
	size_t soap_flag_ns1__GetPTZPort = 1;
	short soap_flag;
	a = (struct __ns2__GetPTZPort *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetPTZPort, sizeof(struct __ns2__GetPTZPort), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetPTZPort(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPTZPort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPTZPort(soap, "ns1:GetPTZPort", &a->ns1__GetPTZPort, ""))
				{	soap_flag_ns1__GetPTZPort--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__GetPTZPort * SOAP_FMAC4 soap_instantiate___ns2__GetPTZPort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetPTZPort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetPTZPort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__GetPTZPort;
		if (size)
			*size = sizeof(struct __ns2__GetPTZPort);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__GetPTZPort[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__GetPTZPort);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetPTZPort*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetPTZPort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetPTZPort %p -> %p\n", q, p));
	*(struct __ns2__GetPTZPort*)p = *(struct __ns2__GetPTZPort*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__SetPTZConfiguration(struct soap *soap, struct __ns2__SetPTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetPTZConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__SetPTZConfiguration(struct soap *soap, const struct __ns2__SetPTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetPTZConfiguration(soap, &a->ns1__SetPTZConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__SetPTZConfiguration(struct soap *soap, const struct __ns2__SetPTZConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__SetPTZConfiguration(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__SetPTZConfiguration(struct soap *soap, const char *tag, int id, const struct __ns2__SetPTZConfiguration *a, const char *type)
{
	if (soap_out_PointerTo_ns1__SetPTZConfiguration(soap, "ns1:SetPTZConfiguration", -1, &a->ns1__SetPTZConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__SetPTZConfiguration * SOAP_FMAC4 soap_get___ns2__SetPTZConfiguration(struct soap *soap, struct __ns2__SetPTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__SetPTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__SetPTZConfiguration * SOAP_FMAC4 soap_in___ns2__SetPTZConfiguration(struct soap *soap, const char *tag, struct __ns2__SetPTZConfiguration *a, const char *type)
{
	size_t soap_flag_ns1__SetPTZConfiguration = 1;
	short soap_flag;
	a = (struct __ns2__SetPTZConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__SetPTZConfiguration, sizeof(struct __ns2__SetPTZConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__SetPTZConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetPTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetPTZConfiguration(soap, "ns1:SetPTZConfiguration", &a->ns1__SetPTZConfiguration, ""))
				{	soap_flag_ns1__SetPTZConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__SetPTZConfiguration * SOAP_FMAC4 soap_instantiate___ns2__SetPTZConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__SetPTZConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__SetPTZConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__SetPTZConfiguration;
		if (size)
			*size = sizeof(struct __ns2__SetPTZConfiguration);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__SetPTZConfiguration[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__SetPTZConfiguration);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__SetPTZConfiguration*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__SetPTZConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__SetPTZConfiguration %p -> %p\n", q, p));
	*(struct __ns2__SetPTZConfiguration*)p = *(struct __ns2__SetPTZConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetPTZConfiguration(struct soap *soap, struct __ns2__GetPTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPTZConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetPTZConfiguration(struct soap *soap, const struct __ns2__GetPTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPTZConfiguration(soap, &a->ns1__GetPTZConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetPTZConfiguration(struct soap *soap, const struct __ns2__GetPTZConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetPTZConfiguration(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetPTZConfiguration(struct soap *soap, const char *tag, int id, const struct __ns2__GetPTZConfiguration *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPTZConfiguration(soap, "ns1:GetPTZConfiguration", -1, &a->ns1__GetPTZConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetPTZConfiguration * SOAP_FMAC4 soap_get___ns2__GetPTZConfiguration(struct soap *soap, struct __ns2__GetPTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetPTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__GetPTZConfiguration * SOAP_FMAC4 soap_in___ns2__GetPTZConfiguration(struct soap *soap, const char *tag, struct __ns2__GetPTZConfiguration *a, const char *type)
{
	size_t soap_flag_ns1__GetPTZConfiguration = 1;
	short soap_flag;
	a = (struct __ns2__GetPTZConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetPTZConfiguration, sizeof(struct __ns2__GetPTZConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetPTZConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPTZConfiguration(soap, "ns1:GetPTZConfiguration", &a->ns1__GetPTZConfiguration, ""))
				{	soap_flag_ns1__GetPTZConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__GetPTZConfiguration * SOAP_FMAC4 soap_instantiate___ns2__GetPTZConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetPTZConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetPTZConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__GetPTZConfiguration;
		if (size)
			*size = sizeof(struct __ns2__GetPTZConfiguration);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__GetPTZConfiguration[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__GetPTZConfiguration);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetPTZConfiguration*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetPTZConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetPTZConfiguration %p -> %p\n", q, p));
	*(struct __ns2__GetPTZConfiguration*)p = *(struct __ns2__GetPTZConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__StopRecordedPattern(struct soap *soap, struct __ns2__StopRecordedPattern *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StopRecordedPattern = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__StopRecordedPattern(struct soap *soap, const struct __ns2__StopRecordedPattern *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__StopRecordedPattern(soap, &a->ns1__StopRecordedPattern);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__StopRecordedPattern(struct soap *soap, const struct __ns2__StopRecordedPattern *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__StopRecordedPattern(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__StopRecordedPattern(struct soap *soap, const char *tag, int id, const struct __ns2__StopRecordedPattern *a, const char *type)
{
	if (soap_out_PointerTo_ns1__StopRecordedPattern(soap, "ns1:StopRecordedPattern", -1, &a->ns1__StopRecordedPattern, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__StopRecordedPattern * SOAP_FMAC4 soap_get___ns2__StopRecordedPattern(struct soap *soap, struct __ns2__StopRecordedPattern *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__StopRecordedPattern(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__StopRecordedPattern * SOAP_FMAC4 soap_in___ns2__StopRecordedPattern(struct soap *soap, const char *tag, struct __ns2__StopRecordedPattern *a, const char *type)
{
	size_t soap_flag_ns1__StopRecordedPattern = 1;
	short soap_flag;
	a = (struct __ns2__StopRecordedPattern *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__StopRecordedPattern, sizeof(struct __ns2__StopRecordedPattern), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__StopRecordedPattern(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StopRecordedPattern && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StopRecordedPattern(soap, "ns1:StopRecordedPattern", &a->ns1__StopRecordedPattern, ""))
				{	soap_flag_ns1__StopRecordedPattern--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__StopRecordedPattern * SOAP_FMAC4 soap_instantiate___ns2__StopRecordedPattern(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__StopRecordedPattern(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__StopRecordedPattern, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__StopRecordedPattern;
		if (size)
			*size = sizeof(struct __ns2__StopRecordedPattern);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__StopRecordedPattern[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__StopRecordedPattern);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__StopRecordedPattern*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__StopRecordedPattern(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__StopRecordedPattern %p -> %p\n", q, p));
	*(struct __ns2__StopRecordedPattern*)p = *(struct __ns2__StopRecordedPattern*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__PlayRecordedPattern(struct soap *soap, struct __ns2__PlayRecordedPattern *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PlayRecordedPattern = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__PlayRecordedPattern(struct soap *soap, const struct __ns2__PlayRecordedPattern *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PlayRecordedPattern(soap, &a->ns1__PlayRecordedPattern);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__PlayRecordedPattern(struct soap *soap, const struct __ns2__PlayRecordedPattern *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__PlayRecordedPattern(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__PlayRecordedPattern(struct soap *soap, const char *tag, int id, const struct __ns2__PlayRecordedPattern *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PlayRecordedPattern(soap, "ns1:PlayRecordedPattern", -1, &a->ns1__PlayRecordedPattern, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__PlayRecordedPattern * SOAP_FMAC4 soap_get___ns2__PlayRecordedPattern(struct soap *soap, struct __ns2__PlayRecordedPattern *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__PlayRecordedPattern(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__PlayRecordedPattern * SOAP_FMAC4 soap_in___ns2__PlayRecordedPattern(struct soap *soap, const char *tag, struct __ns2__PlayRecordedPattern *a, const char *type)
{
	size_t soap_flag_ns1__PlayRecordedPattern = 1;
	short soap_flag;
	a = (struct __ns2__PlayRecordedPattern *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__PlayRecordedPattern, sizeof(struct __ns2__PlayRecordedPattern), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__PlayRecordedPattern(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PlayRecordedPattern && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PlayRecordedPattern(soap, "ns1:PlayRecordedPattern", &a->ns1__PlayRecordedPattern, ""))
				{	soap_flag_ns1__PlayRecordedPattern--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__PlayRecordedPattern * SOAP_FMAC4 soap_instantiate___ns2__PlayRecordedPattern(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__PlayRecordedPattern(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__PlayRecordedPattern, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__PlayRecordedPattern;
		if (size)
			*size = sizeof(struct __ns2__PlayRecordedPattern);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__PlayRecordedPattern[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__PlayRecordedPattern);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__PlayRecordedPattern*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__PlayRecordedPattern(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__PlayRecordedPattern %p -> %p\n", q, p));
	*(struct __ns2__PlayRecordedPattern*)p = *(struct __ns2__PlayRecordedPattern*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__StopPatternRecording(struct soap *soap, struct __ns2__StopPatternRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StopPatternRecording = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__StopPatternRecording(struct soap *soap, const struct __ns2__StopPatternRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__StopPatternRecording(soap, &a->ns1__StopPatternRecording);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__StopPatternRecording(struct soap *soap, const struct __ns2__StopPatternRecording *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__StopPatternRecording(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__StopPatternRecording(struct soap *soap, const char *tag, int id, const struct __ns2__StopPatternRecording *a, const char *type)
{
	if (soap_out_PointerTo_ns1__StopPatternRecording(soap, "ns1:StopPatternRecording", -1, &a->ns1__StopPatternRecording, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__StopPatternRecording * SOAP_FMAC4 soap_get___ns2__StopPatternRecording(struct soap *soap, struct __ns2__StopPatternRecording *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__StopPatternRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__StopPatternRecording * SOAP_FMAC4 soap_in___ns2__StopPatternRecording(struct soap *soap, const char *tag, struct __ns2__StopPatternRecording *a, const char *type)
{
	size_t soap_flag_ns1__StopPatternRecording = 1;
	short soap_flag;
	a = (struct __ns2__StopPatternRecording *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__StopPatternRecording, sizeof(struct __ns2__StopPatternRecording), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__StopPatternRecording(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StopPatternRecording && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StopPatternRecording(soap, "ns1:StopPatternRecording", &a->ns1__StopPatternRecording, ""))
				{	soap_flag_ns1__StopPatternRecording--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__StopPatternRecording * SOAP_FMAC4 soap_instantiate___ns2__StopPatternRecording(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__StopPatternRecording(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__StopPatternRecording, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__StopPatternRecording;
		if (size)
			*size = sizeof(struct __ns2__StopPatternRecording);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__StopPatternRecording[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__StopPatternRecording);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__StopPatternRecording*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__StopPatternRecording(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__StopPatternRecording %p -> %p\n", q, p));
	*(struct __ns2__StopPatternRecording*)p = *(struct __ns2__StopPatternRecording*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__StartPatternRecording(struct soap *soap, struct __ns2__StartPatternRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StartPatternRecording = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__StartPatternRecording(struct soap *soap, const struct __ns2__StartPatternRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__StartPatternRecording(soap, &a->ns1__StartPatternRecording);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__StartPatternRecording(struct soap *soap, const struct __ns2__StartPatternRecording *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__StartPatternRecording(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__StartPatternRecording(struct soap *soap, const char *tag, int id, const struct __ns2__StartPatternRecording *a, const char *type)
{
	if (soap_out_PointerTo_ns1__StartPatternRecording(soap, "ns1:StartPatternRecording", -1, &a->ns1__StartPatternRecording, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__StartPatternRecording * SOAP_FMAC4 soap_get___ns2__StartPatternRecording(struct soap *soap, struct __ns2__StartPatternRecording *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__StartPatternRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__StartPatternRecording * SOAP_FMAC4 soap_in___ns2__StartPatternRecording(struct soap *soap, const char *tag, struct __ns2__StartPatternRecording *a, const char *type)
{
	size_t soap_flag_ns1__StartPatternRecording = 1;
	short soap_flag;
	a = (struct __ns2__StartPatternRecording *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__StartPatternRecording, sizeof(struct __ns2__StartPatternRecording), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__StartPatternRecording(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StartPatternRecording && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StartPatternRecording(soap, "ns1:StartPatternRecording", &a->ns1__StartPatternRecording, ""))
				{	soap_flag_ns1__StartPatternRecording--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__StartPatternRecording * SOAP_FMAC4 soap_instantiate___ns2__StartPatternRecording(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__StartPatternRecording(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__StartPatternRecording, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__StartPatternRecording;
		if (size)
			*size = sizeof(struct __ns2__StartPatternRecording);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__StartPatternRecording[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__StartPatternRecording);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__StartPatternRecording*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__StartPatternRecording(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__StartPatternRecording %p -> %p\n", q, p));
	*(struct __ns2__StartPatternRecording*)p = *(struct __ns2__StartPatternRecording*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__StopPresetTour(struct soap *soap, struct __ns2__StopPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StopPresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__StopPresetTour(struct soap *soap, const struct __ns2__StopPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__StopPresetTour(soap, &a->ns1__StopPresetTour);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__StopPresetTour(struct soap *soap, const struct __ns2__StopPresetTour *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__StopPresetTour(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__StopPresetTour(struct soap *soap, const char *tag, int id, const struct __ns2__StopPresetTour *a, const char *type)
{
	if (soap_out_PointerTo_ns1__StopPresetTour(soap, "ns1:StopPresetTour", -1, &a->ns1__StopPresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__StopPresetTour * SOAP_FMAC4 soap_get___ns2__StopPresetTour(struct soap *soap, struct __ns2__StopPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__StopPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__StopPresetTour * SOAP_FMAC4 soap_in___ns2__StopPresetTour(struct soap *soap, const char *tag, struct __ns2__StopPresetTour *a, const char *type)
{
	size_t soap_flag_ns1__StopPresetTour = 1;
	short soap_flag;
	a = (struct __ns2__StopPresetTour *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__StopPresetTour, sizeof(struct __ns2__StopPresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__StopPresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StopPresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StopPresetTour(soap, "ns1:StopPresetTour", &a->ns1__StopPresetTour, ""))
				{	soap_flag_ns1__StopPresetTour--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__StopPresetTour * SOAP_FMAC4 soap_instantiate___ns2__StopPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__StopPresetTour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__StopPresetTour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__StopPresetTour;
		if (size)
			*size = sizeof(struct __ns2__StopPresetTour);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__StopPresetTour[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__StopPresetTour);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__StopPresetTour*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__StopPresetTour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__StopPresetTour %p -> %p\n", q, p));
	*(struct __ns2__StopPresetTour*)p = *(struct __ns2__StopPresetTour*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__PlayPresetTour(struct soap *soap, struct __ns2__PlayPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PlayPresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__PlayPresetTour(struct soap *soap, const struct __ns2__PlayPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PlayPresetTour(soap, &a->ns1__PlayPresetTour);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__PlayPresetTour(struct soap *soap, const struct __ns2__PlayPresetTour *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__PlayPresetTour(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__PlayPresetTour(struct soap *soap, const char *tag, int id, const struct __ns2__PlayPresetTour *a, const char *type)
{
	if (soap_out_PointerTo_ns1__PlayPresetTour(soap, "ns1:PlayPresetTour", -1, &a->ns1__PlayPresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__PlayPresetTour * SOAP_FMAC4 soap_get___ns2__PlayPresetTour(struct soap *soap, struct __ns2__PlayPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__PlayPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__PlayPresetTour * SOAP_FMAC4 soap_in___ns2__PlayPresetTour(struct soap *soap, const char *tag, struct __ns2__PlayPresetTour *a, const char *type)
{
	size_t soap_flag_ns1__PlayPresetTour = 1;
	short soap_flag;
	a = (struct __ns2__PlayPresetTour *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__PlayPresetTour, sizeof(struct __ns2__PlayPresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__PlayPresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PlayPresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PlayPresetTour(soap, "ns1:PlayPresetTour", &a->ns1__PlayPresetTour, ""))
				{	soap_flag_ns1__PlayPresetTour--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__PlayPresetTour * SOAP_FMAC4 soap_instantiate___ns2__PlayPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__PlayPresetTour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__PlayPresetTour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__PlayPresetTour;
		if (size)
			*size = sizeof(struct __ns2__PlayPresetTour);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__PlayPresetTour[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__PlayPresetTour);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__PlayPresetTour*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__PlayPresetTour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__PlayPresetTour %p -> %p\n", q, p));
	*(struct __ns2__PlayPresetTour*)p = *(struct __ns2__PlayPresetTour*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__SetPresetTour(struct soap *soap, struct __ns2__SetPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetPresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__SetPresetTour(struct soap *soap, const struct __ns2__SetPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetPresetTour(soap, &a->ns1__SetPresetTour);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__SetPresetTour(struct soap *soap, const struct __ns2__SetPresetTour *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__SetPresetTour(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__SetPresetTour(struct soap *soap, const char *tag, int id, const struct __ns2__SetPresetTour *a, const char *type)
{
	if (soap_out_PointerTo_ns1__SetPresetTour(soap, "ns1:SetPresetTour", -1, &a->ns1__SetPresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__SetPresetTour * SOAP_FMAC4 soap_get___ns2__SetPresetTour(struct soap *soap, struct __ns2__SetPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__SetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__SetPresetTour * SOAP_FMAC4 soap_in___ns2__SetPresetTour(struct soap *soap, const char *tag, struct __ns2__SetPresetTour *a, const char *type)
{
	size_t soap_flag_ns1__SetPresetTour = 1;
	short soap_flag;
	a = (struct __ns2__SetPresetTour *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__SetPresetTour, sizeof(struct __ns2__SetPresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__SetPresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetPresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetPresetTour(soap, "ns1:SetPresetTour", &a->ns1__SetPresetTour, ""))
				{	soap_flag_ns1__SetPresetTour--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__SetPresetTour * SOAP_FMAC4 soap_instantiate___ns2__SetPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__SetPresetTour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__SetPresetTour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__SetPresetTour;
		if (size)
			*size = sizeof(struct __ns2__SetPresetTour);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__SetPresetTour[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__SetPresetTour);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__SetPresetTour*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__SetPresetTour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__SetPresetTour %p -> %p\n", q, p));
	*(struct __ns2__SetPresetTour*)p = *(struct __ns2__SetPresetTour*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetPresetTour(struct soap *soap, struct __ns2__GetPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetPresetTour(struct soap *soap, const struct __ns2__GetPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPresetTour(soap, &a->ns1__GetPresetTour);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetPresetTour(struct soap *soap, const struct __ns2__GetPresetTour *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetPresetTour(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetPresetTour(struct soap *soap, const char *tag, int id, const struct __ns2__GetPresetTour *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPresetTour(soap, "ns1:GetPresetTour", -1, &a->ns1__GetPresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetPresetTour * SOAP_FMAC4 soap_get___ns2__GetPresetTour(struct soap *soap, struct __ns2__GetPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__GetPresetTour * SOAP_FMAC4 soap_in___ns2__GetPresetTour(struct soap *soap, const char *tag, struct __ns2__GetPresetTour *a, const char *type)
{
	size_t soap_flag_ns1__GetPresetTour = 1;
	short soap_flag;
	a = (struct __ns2__GetPresetTour *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetPresetTour, sizeof(struct __ns2__GetPresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetPresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPresetTour(soap, "ns1:GetPresetTour", &a->ns1__GetPresetTour, ""))
				{	soap_flag_ns1__GetPresetTour--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__GetPresetTour * SOAP_FMAC4 soap_instantiate___ns2__GetPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetPresetTour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetPresetTour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__GetPresetTour;
		if (size)
			*size = sizeof(struct __ns2__GetPresetTour);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__GetPresetTour[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__GetPresetTour);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetPresetTour*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetPresetTour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetPresetTour %p -> %p\n", q, p));
	*(struct __ns2__GetPresetTour*)p = *(struct __ns2__GetPresetTour*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__RemovePreset(struct soap *soap, struct __ns2__RemovePreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RemovePreset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__RemovePreset(struct soap *soap, const struct __ns2__RemovePreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__RemovePreset(soap, &a->ns1__RemovePreset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__RemovePreset(struct soap *soap, const struct __ns2__RemovePreset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__RemovePreset(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__RemovePreset(struct soap *soap, const char *tag, int id, const struct __ns2__RemovePreset *a, const char *type)
{
	if (soap_out_PointerTo_ns1__RemovePreset(soap, "ns1:RemovePreset", -1, &a->ns1__RemovePreset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__RemovePreset * SOAP_FMAC4 soap_get___ns2__RemovePreset(struct soap *soap, struct __ns2__RemovePreset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__RemovePreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__RemovePreset * SOAP_FMAC4 soap_in___ns2__RemovePreset(struct soap *soap, const char *tag, struct __ns2__RemovePreset *a, const char *type)
{
	size_t soap_flag_ns1__RemovePreset = 1;
	short soap_flag;
	a = (struct __ns2__RemovePreset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__RemovePreset, sizeof(struct __ns2__RemovePreset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__RemovePreset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RemovePreset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RemovePreset(soap, "ns1:RemovePreset", &a->ns1__RemovePreset, ""))
				{	soap_flag_ns1__RemovePreset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__RemovePreset * SOAP_FMAC4 soap_instantiate___ns2__RemovePreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__RemovePreset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__RemovePreset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__RemovePreset;
		if (size)
			*size = sizeof(struct __ns2__RemovePreset);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__RemovePreset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__RemovePreset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__RemovePreset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__RemovePreset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__RemovePreset %p -> %p\n", q, p));
	*(struct __ns2__RemovePreset*)p = *(struct __ns2__RemovePreset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GotoPreset(struct soap *soap, struct __ns2__GotoPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GotoPreset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GotoPreset(struct soap *soap, const struct __ns2__GotoPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GotoPreset(soap, &a->ns1__GotoPreset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GotoPreset(struct soap *soap, const struct __ns2__GotoPreset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GotoPreset(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GotoPreset(struct soap *soap, const char *tag, int id, const struct __ns2__GotoPreset *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GotoPreset(soap, "ns1:GotoPreset", -1, &a->ns1__GotoPreset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GotoPreset * SOAP_FMAC4 soap_get___ns2__GotoPreset(struct soap *soap, struct __ns2__GotoPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GotoPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__GotoPreset * SOAP_FMAC4 soap_in___ns2__GotoPreset(struct soap *soap, const char *tag, struct __ns2__GotoPreset *a, const char *type)
{
	size_t soap_flag_ns1__GotoPreset = 1;
	short soap_flag;
	a = (struct __ns2__GotoPreset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GotoPreset, sizeof(struct __ns2__GotoPreset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GotoPreset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GotoPreset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GotoPreset(soap, "ns1:GotoPreset", &a->ns1__GotoPreset, ""))
				{	soap_flag_ns1__GotoPreset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__GotoPreset * SOAP_FMAC4 soap_instantiate___ns2__GotoPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GotoPreset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GotoPreset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__GotoPreset;
		if (size)
			*size = sizeof(struct __ns2__GotoPreset);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__GotoPreset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__GotoPreset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GotoPreset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GotoPreset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GotoPreset %p -> %p\n", q, p));
	*(struct __ns2__GotoPreset*)p = *(struct __ns2__GotoPreset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__AddPreset(struct soap *soap, struct __ns2__AddPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddPreset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__AddPreset(struct soap *soap, const struct __ns2__AddPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AddPreset(soap, &a->ns1__AddPreset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__AddPreset(struct soap *soap, const struct __ns2__AddPreset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__AddPreset(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__AddPreset(struct soap *soap, const char *tag, int id, const struct __ns2__AddPreset *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AddPreset(soap, "ns1:AddPreset", -1, &a->ns1__AddPreset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__AddPreset * SOAP_FMAC4 soap_get___ns2__AddPreset(struct soap *soap, struct __ns2__AddPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__AddPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__AddPreset * SOAP_FMAC4 soap_in___ns2__AddPreset(struct soap *soap, const char *tag, struct __ns2__AddPreset *a, const char *type)
{
	size_t soap_flag_ns1__AddPreset = 1;
	short soap_flag;
	a = (struct __ns2__AddPreset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__AddPreset, sizeof(struct __ns2__AddPreset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__AddPreset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddPreset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddPreset(soap, "ns1:AddPreset", &a->ns1__AddPreset, ""))
				{	soap_flag_ns1__AddPreset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__AddPreset * SOAP_FMAC4 soap_instantiate___ns2__AddPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__AddPreset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__AddPreset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__AddPreset;
		if (size)
			*size = sizeof(struct __ns2__AddPreset);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__AddPreset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__AddPreset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__AddPreset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__AddPreset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__AddPreset %p -> %p\n", q, p));
	*(struct __ns2__AddPreset*)p = *(struct __ns2__AddPreset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetPresetList(struct soap *soap, struct __ns2__GetPresetList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPresetList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetPresetList(struct soap *soap, const struct __ns2__GetPresetList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPresetList(soap, &a->ns1__GetPresetList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetPresetList(struct soap *soap, const struct __ns2__GetPresetList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetPresetList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetPresetList(struct soap *soap, const char *tag, int id, const struct __ns2__GetPresetList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPresetList(soap, "ns1:GetPresetList", -1, &a->ns1__GetPresetList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetPresetList * SOAP_FMAC4 soap_get___ns2__GetPresetList(struct soap *soap, struct __ns2__GetPresetList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetPresetList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__GetPresetList * SOAP_FMAC4 soap_in___ns2__GetPresetList(struct soap *soap, const char *tag, struct __ns2__GetPresetList *a, const char *type)
{
	size_t soap_flag_ns1__GetPresetList = 1;
	short soap_flag;
	a = (struct __ns2__GetPresetList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetPresetList, sizeof(struct __ns2__GetPresetList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetPresetList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPresetList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPresetList(soap, "ns1:GetPresetList", &a->ns1__GetPresetList, ""))
				{	soap_flag_ns1__GetPresetList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__GetPresetList * SOAP_FMAC4 soap_instantiate___ns2__GetPresetList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetPresetList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetPresetList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__GetPresetList;
		if (size)
			*size = sizeof(struct __ns2__GetPresetList);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__GetPresetList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__GetPresetList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetPresetList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetPresetList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetPresetList %p -> %p\n", q, p));
	*(struct __ns2__GetPresetList*)p = *(struct __ns2__GetPresetList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__Stop(struct soap *soap, struct __ns2__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Stop = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__Stop(struct soap *soap, const struct __ns2__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__Stop(soap, &a->ns1__Stop);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__Stop(struct soap *soap, const struct __ns2__Stop *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__Stop(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__Stop(struct soap *soap, const char *tag, int id, const struct __ns2__Stop *a, const char *type)
{
	if (soap_out_PointerTo_ns1__Stop(soap, "ns1:Stop", -1, &a->ns1__Stop, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__Stop * SOAP_FMAC4 soap_get___ns2__Stop(struct soap *soap, struct __ns2__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__Stop * SOAP_FMAC4 soap_in___ns2__Stop(struct soap *soap, const char *tag, struct __ns2__Stop *a, const char *type)
{
	size_t soap_flag_ns1__Stop = 1;
	short soap_flag;
	a = (struct __ns2__Stop *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__Stop, sizeof(struct __ns2__Stop), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__Stop(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Stop && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Stop(soap, "ns1:Stop", &a->ns1__Stop, ""))
				{	soap_flag_ns1__Stop--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__Stop * SOAP_FMAC4 soap_instantiate___ns2__Stop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__Stop(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__Stop, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__Stop;
		if (size)
			*size = sizeof(struct __ns2__Stop);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__Stop[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__Stop);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__Stop*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__Stop(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__Stop %p -> %p\n", q, p));
	*(struct __ns2__Stop*)p = *(struct __ns2__Stop*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__ControlPTZ(struct soap *soap, struct __ns2__ControlPTZ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ControlPTZ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__ControlPTZ(struct soap *soap, const struct __ns2__ControlPTZ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ControlPTZ(soap, &a->ns1__ControlPTZ);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__ControlPTZ(struct soap *soap, const struct __ns2__ControlPTZ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__ControlPTZ(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__ControlPTZ(struct soap *soap, const char *tag, int id, const struct __ns2__ControlPTZ *a, const char *type)
{
	if (soap_out_PointerTo_ns1__ControlPTZ(soap, "ns1:ControlPTZ", -1, &a->ns1__ControlPTZ, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__ControlPTZ * SOAP_FMAC4 soap_get___ns2__ControlPTZ(struct soap *soap, struct __ns2__ControlPTZ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__ControlPTZ(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__ControlPTZ * SOAP_FMAC4 soap_in___ns2__ControlPTZ(struct soap *soap, const char *tag, struct __ns2__ControlPTZ *a, const char *type)
{
	size_t soap_flag_ns1__ControlPTZ = 1;
	short soap_flag;
	a = (struct __ns2__ControlPTZ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__ControlPTZ, sizeof(struct __ns2__ControlPTZ), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__ControlPTZ(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ControlPTZ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ControlPTZ(soap, "ns1:ControlPTZ", &a->ns1__ControlPTZ, ""))
				{	soap_flag_ns1__ControlPTZ--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__ControlPTZ * SOAP_FMAC4 soap_instantiate___ns2__ControlPTZ(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__ControlPTZ(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__ControlPTZ, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__ControlPTZ;
		if (size)
			*size = sizeof(struct __ns2__ControlPTZ);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__ControlPTZ[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__ControlPTZ);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__ControlPTZ*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__ControlPTZ(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__ControlPTZ %p -> %p\n", q, p));
	*(struct __ns2__ControlPTZ*)p = *(struct __ns2__ControlPTZ*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetPTZCommandList(struct soap *soap, struct __ns2__GetPTZCommandList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPTZCommandList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetPTZCommandList(struct soap *soap, const struct __ns2__GetPTZCommandList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPTZCommandList(soap, &a->ns1__GetPTZCommandList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetPTZCommandList(struct soap *soap, const struct __ns2__GetPTZCommandList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetPTZCommandList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetPTZCommandList(struct soap *soap, const char *tag, int id, const struct __ns2__GetPTZCommandList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPTZCommandList(soap, "ns1:GetPTZCommandList", -1, &a->ns1__GetPTZCommandList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetPTZCommandList * SOAP_FMAC4 soap_get___ns2__GetPTZCommandList(struct soap *soap, struct __ns2__GetPTZCommandList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetPTZCommandList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__GetPTZCommandList * SOAP_FMAC4 soap_in___ns2__GetPTZCommandList(struct soap *soap, const char *tag, struct __ns2__GetPTZCommandList *a, const char *type)
{
	size_t soap_flag_ns1__GetPTZCommandList = 1;
	short soap_flag;
	a = (struct __ns2__GetPTZCommandList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetPTZCommandList, sizeof(struct __ns2__GetPTZCommandList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetPTZCommandList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPTZCommandList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPTZCommandList(soap, "ns1:GetPTZCommandList", &a->ns1__GetPTZCommandList, ""))
				{	soap_flag_ns1__GetPTZCommandList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__GetPTZCommandList * SOAP_FMAC4 soap_instantiate___ns2__GetPTZCommandList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetPTZCommandList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetPTZCommandList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__GetPTZCommandList;
		if (size)
			*size = sizeof(struct __ns2__GetPTZCommandList);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__GetPTZCommandList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__GetPTZCommandList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetPTZCommandList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetPTZCommandList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetPTZCommandList %p -> %p\n", q, p));
	*(struct __ns2__GetPTZCommandList*)p = *(struct __ns2__GetPTZCommandList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetPTZProtocolInfo(struct soap *soap, struct __ns2__GetPTZProtocolInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPTZProtocolInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetPTZProtocolInfo(struct soap *soap, const struct __ns2__GetPTZProtocolInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPTZProtocolInfo(soap, &a->ns1__GetPTZProtocolInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetPTZProtocolInfo(struct soap *soap, const struct __ns2__GetPTZProtocolInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetPTZProtocolInfo(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetPTZProtocolInfo(struct soap *soap, const char *tag, int id, const struct __ns2__GetPTZProtocolInfo *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPTZProtocolInfo(soap, "ns1:GetPTZProtocolInfo", -1, &a->ns1__GetPTZProtocolInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetPTZProtocolInfo * SOAP_FMAC4 soap_get___ns2__GetPTZProtocolInfo(struct soap *soap, struct __ns2__GetPTZProtocolInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetPTZProtocolInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__GetPTZProtocolInfo * SOAP_FMAC4 soap_in___ns2__GetPTZProtocolInfo(struct soap *soap, const char *tag, struct __ns2__GetPTZProtocolInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetPTZProtocolInfo = 1;
	short soap_flag;
	a = (struct __ns2__GetPTZProtocolInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetPTZProtocolInfo, sizeof(struct __ns2__GetPTZProtocolInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetPTZProtocolInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPTZProtocolInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPTZProtocolInfo(soap, "ns1:GetPTZProtocolInfo", &a->ns1__GetPTZProtocolInfo, ""))
				{	soap_flag_ns1__GetPTZProtocolInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__GetPTZProtocolInfo * SOAP_FMAC4 soap_instantiate___ns2__GetPTZProtocolInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetPTZProtocolInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetPTZProtocolInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__GetPTZProtocolInfo;
		if (size)
			*size = sizeof(struct __ns2__GetPTZProtocolInfo);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__GetPTZProtocolInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__GetPTZProtocolInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetPTZProtocolInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetPTZProtocolInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetPTZProtocolInfo %p -> %p\n", q, p));
	*(struct __ns2__GetPTZProtocolInfo*)p = *(struct __ns2__GetPTZProtocolInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__RemovePTZProtocol(struct soap *soap, struct __ns2__RemovePTZProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RemovePTZProtocol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__RemovePTZProtocol(struct soap *soap, const struct __ns2__RemovePTZProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__RemovePTZProtocol(soap, &a->ns1__RemovePTZProtocol);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__RemovePTZProtocol(struct soap *soap, const struct __ns2__RemovePTZProtocol *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__RemovePTZProtocol(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__RemovePTZProtocol(struct soap *soap, const char *tag, int id, const struct __ns2__RemovePTZProtocol *a, const char *type)
{
	if (soap_out_PointerTo_ns1__RemovePTZProtocol(soap, "ns1:RemovePTZProtocol", -1, &a->ns1__RemovePTZProtocol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__RemovePTZProtocol * SOAP_FMAC4 soap_get___ns2__RemovePTZProtocol(struct soap *soap, struct __ns2__RemovePTZProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__RemovePTZProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__RemovePTZProtocol * SOAP_FMAC4 soap_in___ns2__RemovePTZProtocol(struct soap *soap, const char *tag, struct __ns2__RemovePTZProtocol *a, const char *type)
{
	size_t soap_flag_ns1__RemovePTZProtocol = 1;
	short soap_flag;
	a = (struct __ns2__RemovePTZProtocol *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__RemovePTZProtocol, sizeof(struct __ns2__RemovePTZProtocol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__RemovePTZProtocol(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RemovePTZProtocol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RemovePTZProtocol(soap, "ns1:RemovePTZProtocol", &a->ns1__RemovePTZProtocol, ""))
				{	soap_flag_ns1__RemovePTZProtocol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__RemovePTZProtocol * SOAP_FMAC4 soap_instantiate___ns2__RemovePTZProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__RemovePTZProtocol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__RemovePTZProtocol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__RemovePTZProtocol;
		if (size)
			*size = sizeof(struct __ns2__RemovePTZProtocol);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__RemovePTZProtocol[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__RemovePTZProtocol);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__RemovePTZProtocol*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__RemovePTZProtocol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__RemovePTZProtocol %p -> %p\n", q, p));
	*(struct __ns2__RemovePTZProtocol*)p = *(struct __ns2__RemovePTZProtocol*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__AddPTZProtocol(struct soap *soap, struct __ns2__AddPTZProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddPTZProtocol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__AddPTZProtocol(struct soap *soap, const struct __ns2__AddPTZProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AddPTZProtocol(soap, &a->ns1__AddPTZProtocol);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__AddPTZProtocol(struct soap *soap, const struct __ns2__AddPTZProtocol *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__AddPTZProtocol(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__AddPTZProtocol(struct soap *soap, const char *tag, int id, const struct __ns2__AddPTZProtocol *a, const char *type)
{
	if (soap_out_PointerTo_ns1__AddPTZProtocol(soap, "ns1:AddPTZProtocol", -1, &a->ns1__AddPTZProtocol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__AddPTZProtocol * SOAP_FMAC4 soap_get___ns2__AddPTZProtocol(struct soap *soap, struct __ns2__AddPTZProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__AddPTZProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__AddPTZProtocol * SOAP_FMAC4 soap_in___ns2__AddPTZProtocol(struct soap *soap, const char *tag, struct __ns2__AddPTZProtocol *a, const char *type)
{
	size_t soap_flag_ns1__AddPTZProtocol = 1;
	short soap_flag;
	a = (struct __ns2__AddPTZProtocol *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__AddPTZProtocol, sizeof(struct __ns2__AddPTZProtocol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__AddPTZProtocol(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddPTZProtocol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddPTZProtocol(soap, "ns1:AddPTZProtocol", &a->ns1__AddPTZProtocol, ""))
				{	soap_flag_ns1__AddPTZProtocol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__AddPTZProtocol * SOAP_FMAC4 soap_instantiate___ns2__AddPTZProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__AddPTZProtocol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__AddPTZProtocol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__AddPTZProtocol;
		if (size)
			*size = sizeof(struct __ns2__AddPTZProtocol);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__AddPTZProtocol[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__AddPTZProtocol);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__AddPTZProtocol*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__AddPTZProtocol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__AddPTZProtocol %p -> %p\n", q, p));
	*(struct __ns2__AddPTZProtocol*)p = *(struct __ns2__AddPTZProtocol*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__SetPTZProtocol(struct soap *soap, struct __ns2__SetPTZProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetPTZProtocol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__SetPTZProtocol(struct soap *soap, const struct __ns2__SetPTZProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetPTZProtocol(soap, &a->ns1__SetPTZProtocol);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__SetPTZProtocol(struct soap *soap, const struct __ns2__SetPTZProtocol *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__SetPTZProtocol(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__SetPTZProtocol(struct soap *soap, const char *tag, int id, const struct __ns2__SetPTZProtocol *a, const char *type)
{
	if (soap_out_PointerTo_ns1__SetPTZProtocol(soap, "ns1:SetPTZProtocol", -1, &a->ns1__SetPTZProtocol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__SetPTZProtocol * SOAP_FMAC4 soap_get___ns2__SetPTZProtocol(struct soap *soap, struct __ns2__SetPTZProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__SetPTZProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__SetPTZProtocol * SOAP_FMAC4 soap_in___ns2__SetPTZProtocol(struct soap *soap, const char *tag, struct __ns2__SetPTZProtocol *a, const char *type)
{
	size_t soap_flag_ns1__SetPTZProtocol = 1;
	short soap_flag;
	a = (struct __ns2__SetPTZProtocol *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__SetPTZProtocol, sizeof(struct __ns2__SetPTZProtocol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__SetPTZProtocol(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetPTZProtocol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetPTZProtocol(soap, "ns1:SetPTZProtocol", &a->ns1__SetPTZProtocol, ""))
				{	soap_flag_ns1__SetPTZProtocol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__SetPTZProtocol * SOAP_FMAC4 soap_instantiate___ns2__SetPTZProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__SetPTZProtocol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__SetPTZProtocol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__SetPTZProtocol;
		if (size)
			*size = sizeof(struct __ns2__SetPTZProtocol);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__SetPTZProtocol[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__SetPTZProtocol);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__SetPTZProtocol*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__SetPTZProtocol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__SetPTZProtocol %p -> %p\n", q, p));
	*(struct __ns2__SetPTZProtocol*)p = *(struct __ns2__SetPTZProtocol*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetPTZProtocol(struct soap *soap, struct __ns2__GetPTZProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPTZProtocol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetPTZProtocol(struct soap *soap, const struct __ns2__GetPTZProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPTZProtocol(soap, &a->ns1__GetPTZProtocol);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetPTZProtocol(struct soap *soap, const struct __ns2__GetPTZProtocol *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetPTZProtocol(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetPTZProtocol(struct soap *soap, const char *tag, int id, const struct __ns2__GetPTZProtocol *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPTZProtocol(soap, "ns1:GetPTZProtocol", -1, &a->ns1__GetPTZProtocol, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetPTZProtocol * SOAP_FMAC4 soap_get___ns2__GetPTZProtocol(struct soap *soap, struct __ns2__GetPTZProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetPTZProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__GetPTZProtocol * SOAP_FMAC4 soap_in___ns2__GetPTZProtocol(struct soap *soap, const char *tag, struct __ns2__GetPTZProtocol *a, const char *type)
{
	size_t soap_flag_ns1__GetPTZProtocol = 1;
	short soap_flag;
	a = (struct __ns2__GetPTZProtocol *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetPTZProtocol, sizeof(struct __ns2__GetPTZProtocol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetPTZProtocol(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPTZProtocol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPTZProtocol(soap, "ns1:GetPTZProtocol", &a->ns1__GetPTZProtocol, ""))
				{	soap_flag_ns1__GetPTZProtocol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__GetPTZProtocol * SOAP_FMAC4 soap_instantiate___ns2__GetPTZProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetPTZProtocol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetPTZProtocol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__GetPTZProtocol;
		if (size)
			*size = sizeof(struct __ns2__GetPTZProtocol);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__GetPTZProtocol[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__GetPTZProtocol);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetPTZProtocol*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetPTZProtocol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetPTZProtocol %p -> %p\n", q, p));
	*(struct __ns2__GetPTZProtocol*)p = *(struct __ns2__GetPTZProtocol*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetPTZProtocolList(struct soap *soap, struct __ns2__GetPTZProtocolList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPTZProtocolList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetPTZProtocolList(struct soap *soap, const struct __ns2__GetPTZProtocolList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPTZProtocolList(soap, &a->ns1__GetPTZProtocolList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetPTZProtocolList(struct soap *soap, const struct __ns2__GetPTZProtocolList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetPTZProtocolList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetPTZProtocolList(struct soap *soap, const char *tag, int id, const struct __ns2__GetPTZProtocolList *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPTZProtocolList(soap, "ns1:GetPTZProtocolList", -1, &a->ns1__GetPTZProtocolList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetPTZProtocolList * SOAP_FMAC4 soap_get___ns2__GetPTZProtocolList(struct soap *soap, struct __ns2__GetPTZProtocolList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetPTZProtocolList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__GetPTZProtocolList * SOAP_FMAC4 soap_in___ns2__GetPTZProtocolList(struct soap *soap, const char *tag, struct __ns2__GetPTZProtocolList *a, const char *type)
{
	size_t soap_flag_ns1__GetPTZProtocolList = 1;
	short soap_flag;
	a = (struct __ns2__GetPTZProtocolList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetPTZProtocolList, sizeof(struct __ns2__GetPTZProtocolList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetPTZProtocolList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPTZProtocolList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPTZProtocolList(soap, "ns1:GetPTZProtocolList", &a->ns1__GetPTZProtocolList, ""))
				{	soap_flag_ns1__GetPTZProtocolList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__GetPTZProtocolList * SOAP_FMAC4 soap_instantiate___ns2__GetPTZProtocolList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetPTZProtocolList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetPTZProtocolList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__GetPTZProtocolList;
		if (size)
			*size = sizeof(struct __ns2__GetPTZProtocolList);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__GetPTZProtocolList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__GetPTZProtocolList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetPTZProtocolList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetPTZProtocolList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetPTZProtocolList %p -> %p\n", q, p));
	*(struct __ns2__GetPTZProtocolList*)p = *(struct __ns2__GetPTZProtocolList*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OSDMenuResponse(struct soap *soap, _ns1__OSDMenuResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OSDMenuResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OSDMenuResponse(struct soap *soap, _ns1__OSDMenuResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__OSDMenuResponse);
	if (soap_out_PointerTo_ns1__OSDMenuResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OSDMenuResponse(struct soap *soap, const char *tag, int id, _ns1__OSDMenuResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OSDMenuResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__OSDMenuResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__OSDMenuResponse(struct soap *soap, _ns1__OSDMenuResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OSDMenuResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__OSDMenuResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__OSDMenuResponse(struct soap *soap, const char *tag, _ns1__OSDMenuResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__OSDMenuResponse **)soap_malloc(soap, sizeof(_ns1__OSDMenuResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__OSDMenuResponse *)soap_instantiate__ns1__OSDMenuResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__OSDMenuResponse ** p = (_ns1__OSDMenuResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OSDMenuResponse, sizeof(_ns1__OSDMenuResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OSDMenu(struct soap *soap, _ns1__OSDMenu *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OSDMenu))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OSDMenu(struct soap *soap, _ns1__OSDMenu *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__OSDMenu);
	if (soap_out_PointerTo_ns1__OSDMenu(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OSDMenu(struct soap *soap, const char *tag, int id, _ns1__OSDMenu *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OSDMenu);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__OSDMenu ** SOAP_FMAC4 soap_get_PointerTo_ns1__OSDMenu(struct soap *soap, _ns1__OSDMenu **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OSDMenu(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__OSDMenu ** SOAP_FMAC4 soap_in_PointerTo_ns1__OSDMenu(struct soap *soap, const char *tag, _ns1__OSDMenu **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__OSDMenu **)soap_malloc(soap, sizeof(_ns1__OSDMenu *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__OSDMenu *)soap_instantiate__ns1__OSDMenu(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__OSDMenu ** p = (_ns1__OSDMenu **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OSDMenu, sizeof(_ns1__OSDMenu), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PTZByPassResponse(struct soap *soap, _ns1__PTZByPassResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PTZByPassResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PTZByPassResponse(struct soap *soap, _ns1__PTZByPassResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PTZByPassResponse);
	if (soap_out_PointerTo_ns1__PTZByPassResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PTZByPassResponse(struct soap *soap, const char *tag, int id, _ns1__PTZByPassResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PTZByPassResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PTZByPassResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__PTZByPassResponse(struct soap *soap, _ns1__PTZByPassResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PTZByPassResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__PTZByPassResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__PTZByPassResponse(struct soap *soap, const char *tag, _ns1__PTZByPassResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PTZByPassResponse **)soap_malloc(soap, sizeof(_ns1__PTZByPassResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PTZByPassResponse *)soap_instantiate__ns1__PTZByPassResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PTZByPassResponse ** p = (_ns1__PTZByPassResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PTZByPassResponse, sizeof(_ns1__PTZByPassResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PTZByPass(struct soap *soap, _ns1__PTZByPass *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PTZByPass))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PTZByPass(struct soap *soap, _ns1__PTZByPass *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PTZByPass);
	if (soap_out_PointerTo_ns1__PTZByPass(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PTZByPass(struct soap *soap, const char *tag, int id, _ns1__PTZByPass *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PTZByPass);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PTZByPass ** SOAP_FMAC4 soap_get_PointerTo_ns1__PTZByPass(struct soap *soap, _ns1__PTZByPass **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PTZByPass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__PTZByPass ** SOAP_FMAC4 soap_in_PointerTo_ns1__PTZByPass(struct soap *soap, const char *tag, _ns1__PTZByPass **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PTZByPass **)soap_malloc(soap, sizeof(_ns1__PTZByPass *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PTZByPass *)soap_instantiate__ns1__PTZByPass(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PTZByPass ** p = (_ns1__PTZByPass **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PTZByPass, sizeof(_ns1__PTZByPass), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetPTZPortResponse(struct soap *soap, _ns1__SetPTZPortResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetPTZPortResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetPTZPortResponse(struct soap *soap, _ns1__SetPTZPortResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetPTZPortResponse);
	if (soap_out_PointerTo_ns1__SetPTZPortResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetPTZPortResponse(struct soap *soap, const char *tag, int id, _ns1__SetPTZPortResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetPTZPortResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetPTZPortResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetPTZPortResponse(struct soap *soap, _ns1__SetPTZPortResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetPTZPortResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__SetPTZPortResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetPTZPortResponse(struct soap *soap, const char *tag, _ns1__SetPTZPortResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetPTZPortResponse **)soap_malloc(soap, sizeof(_ns1__SetPTZPortResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetPTZPortResponse *)soap_instantiate__ns1__SetPTZPortResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetPTZPortResponse ** p = (_ns1__SetPTZPortResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetPTZPortResponse, sizeof(_ns1__SetPTZPortResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetPTZPort(struct soap *soap, _ns1__SetPTZPort *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetPTZPort))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetPTZPort(struct soap *soap, _ns1__SetPTZPort *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetPTZPort);
	if (soap_out_PointerTo_ns1__SetPTZPort(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetPTZPort(struct soap *soap, const char *tag, int id, _ns1__SetPTZPort *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetPTZPort);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetPTZPort ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetPTZPort(struct soap *soap, _ns1__SetPTZPort **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetPTZPort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__SetPTZPort ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetPTZPort(struct soap *soap, const char *tag, _ns1__SetPTZPort **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetPTZPort **)soap_malloc(soap, sizeof(_ns1__SetPTZPort *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetPTZPort *)soap_instantiate__ns1__SetPTZPort(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetPTZPort ** p = (_ns1__SetPTZPort **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetPTZPort, sizeof(_ns1__SetPTZPort), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPTZPortResponse(struct soap *soap, _ns1__GetPTZPortResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPTZPortResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPTZPortResponse(struct soap *soap, _ns1__GetPTZPortResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPTZPortResponse);
	if (soap_out_PointerTo_ns1__GetPTZPortResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPTZPortResponse(struct soap *soap, const char *tag, int id, _ns1__GetPTZPortResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPTZPortResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPTZPortResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPTZPortResponse(struct soap *soap, _ns1__GetPTZPortResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPTZPortResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetPTZPortResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPTZPortResponse(struct soap *soap, const char *tag, _ns1__GetPTZPortResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPTZPortResponse **)soap_malloc(soap, sizeof(_ns1__GetPTZPortResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPTZPortResponse *)soap_instantiate__ns1__GetPTZPortResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPTZPortResponse ** p = (_ns1__GetPTZPortResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPTZPortResponse, sizeof(_ns1__GetPTZPortResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPTZPort(struct soap *soap, _ns1__GetPTZPort *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPTZPort))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPTZPort(struct soap *soap, _ns1__GetPTZPort *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPTZPort);
	if (soap_out_PointerTo_ns1__GetPTZPort(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPTZPort(struct soap *soap, const char *tag, int id, _ns1__GetPTZPort *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPTZPort);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPTZPort ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPTZPort(struct soap *soap, _ns1__GetPTZPort **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPTZPort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetPTZPort ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPTZPort(struct soap *soap, const char *tag, _ns1__GetPTZPort **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPTZPort **)soap_malloc(soap, sizeof(_ns1__GetPTZPort *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPTZPort *)soap_instantiate__ns1__GetPTZPort(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPTZPort ** p = (_ns1__GetPTZPort **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPTZPort, sizeof(_ns1__GetPTZPort), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetPTZConfigurationResponse(struct soap *soap, _ns1__SetPTZConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetPTZConfigurationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetPTZConfigurationResponse(struct soap *soap, _ns1__SetPTZConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetPTZConfigurationResponse);
	if (soap_out_PointerTo_ns1__SetPTZConfigurationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetPTZConfigurationResponse(struct soap *soap, const char *tag, int id, _ns1__SetPTZConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetPTZConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetPTZConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetPTZConfigurationResponse(struct soap *soap, _ns1__SetPTZConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetPTZConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__SetPTZConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetPTZConfigurationResponse(struct soap *soap, const char *tag, _ns1__SetPTZConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetPTZConfigurationResponse **)soap_malloc(soap, sizeof(_ns1__SetPTZConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetPTZConfigurationResponse *)soap_instantiate__ns1__SetPTZConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetPTZConfigurationResponse ** p = (_ns1__SetPTZConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetPTZConfigurationResponse, sizeof(_ns1__SetPTZConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetPTZConfiguration(struct soap *soap, _ns1__SetPTZConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetPTZConfiguration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetPTZConfiguration(struct soap *soap, _ns1__SetPTZConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetPTZConfiguration);
	if (soap_out_PointerTo_ns1__SetPTZConfiguration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetPTZConfiguration(struct soap *soap, const char *tag, int id, _ns1__SetPTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetPTZConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetPTZConfiguration ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetPTZConfiguration(struct soap *soap, _ns1__SetPTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetPTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__SetPTZConfiguration ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetPTZConfiguration(struct soap *soap, const char *tag, _ns1__SetPTZConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetPTZConfiguration **)soap_malloc(soap, sizeof(_ns1__SetPTZConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetPTZConfiguration *)soap_instantiate__ns1__SetPTZConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetPTZConfiguration ** p = (_ns1__SetPTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetPTZConfiguration, sizeof(_ns1__SetPTZConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPTZConfigurationResponse(struct soap *soap, _ns1__GetPTZConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPTZConfigurationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPTZConfigurationResponse(struct soap *soap, _ns1__GetPTZConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPTZConfigurationResponse);
	if (soap_out_PointerTo_ns1__GetPTZConfigurationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPTZConfigurationResponse(struct soap *soap, const char *tag, int id, _ns1__GetPTZConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPTZConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPTZConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPTZConfigurationResponse(struct soap *soap, _ns1__GetPTZConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPTZConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetPTZConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPTZConfigurationResponse(struct soap *soap, const char *tag, _ns1__GetPTZConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPTZConfigurationResponse **)soap_malloc(soap, sizeof(_ns1__GetPTZConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPTZConfigurationResponse *)soap_instantiate__ns1__GetPTZConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPTZConfigurationResponse ** p = (_ns1__GetPTZConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPTZConfigurationResponse, sizeof(_ns1__GetPTZConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPTZConfiguration(struct soap *soap, _ns1__GetPTZConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPTZConfiguration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPTZConfiguration(struct soap *soap, _ns1__GetPTZConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPTZConfiguration);
	if (soap_out_PointerTo_ns1__GetPTZConfiguration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPTZConfiguration(struct soap *soap, const char *tag, int id, _ns1__GetPTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPTZConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPTZConfiguration ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPTZConfiguration(struct soap *soap, _ns1__GetPTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetPTZConfiguration ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPTZConfiguration(struct soap *soap, const char *tag, _ns1__GetPTZConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPTZConfiguration **)soap_malloc(soap, sizeof(_ns1__GetPTZConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPTZConfiguration *)soap_instantiate__ns1__GetPTZConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPTZConfiguration ** p = (_ns1__GetPTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPTZConfiguration, sizeof(_ns1__GetPTZConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StopRecordedPatternResponse(struct soap *soap, _ns1__StopRecordedPatternResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StopRecordedPatternResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StopRecordedPatternResponse(struct soap *soap, _ns1__StopRecordedPatternResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__StopRecordedPatternResponse);
	if (soap_out_PointerTo_ns1__StopRecordedPatternResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StopRecordedPatternResponse(struct soap *soap, const char *tag, int id, _ns1__StopRecordedPatternResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StopRecordedPatternResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StopRecordedPatternResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__StopRecordedPatternResponse(struct soap *soap, _ns1__StopRecordedPatternResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StopRecordedPatternResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__StopRecordedPatternResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__StopRecordedPatternResponse(struct soap *soap, const char *tag, _ns1__StopRecordedPatternResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StopRecordedPatternResponse **)soap_malloc(soap, sizeof(_ns1__StopRecordedPatternResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StopRecordedPatternResponse *)soap_instantiate__ns1__StopRecordedPatternResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__StopRecordedPatternResponse ** p = (_ns1__StopRecordedPatternResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StopRecordedPatternResponse, sizeof(_ns1__StopRecordedPatternResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StopRecordedPattern(struct soap *soap, _ns1__StopRecordedPattern *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StopRecordedPattern))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StopRecordedPattern(struct soap *soap, _ns1__StopRecordedPattern *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__StopRecordedPattern);
	if (soap_out_PointerTo_ns1__StopRecordedPattern(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StopRecordedPattern(struct soap *soap, const char *tag, int id, _ns1__StopRecordedPattern *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StopRecordedPattern);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StopRecordedPattern ** SOAP_FMAC4 soap_get_PointerTo_ns1__StopRecordedPattern(struct soap *soap, _ns1__StopRecordedPattern **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StopRecordedPattern(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__StopRecordedPattern ** SOAP_FMAC4 soap_in_PointerTo_ns1__StopRecordedPattern(struct soap *soap, const char *tag, _ns1__StopRecordedPattern **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StopRecordedPattern **)soap_malloc(soap, sizeof(_ns1__StopRecordedPattern *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StopRecordedPattern *)soap_instantiate__ns1__StopRecordedPattern(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__StopRecordedPattern ** p = (_ns1__StopRecordedPattern **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StopRecordedPattern, sizeof(_ns1__StopRecordedPattern), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PlayRecordedPatternResponse(struct soap *soap, _ns1__PlayRecordedPatternResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PlayRecordedPatternResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PlayRecordedPatternResponse(struct soap *soap, _ns1__PlayRecordedPatternResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PlayRecordedPatternResponse);
	if (soap_out_PointerTo_ns1__PlayRecordedPatternResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PlayRecordedPatternResponse(struct soap *soap, const char *tag, int id, _ns1__PlayRecordedPatternResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PlayRecordedPatternResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PlayRecordedPatternResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__PlayRecordedPatternResponse(struct soap *soap, _ns1__PlayRecordedPatternResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PlayRecordedPatternResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__PlayRecordedPatternResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__PlayRecordedPatternResponse(struct soap *soap, const char *tag, _ns1__PlayRecordedPatternResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PlayRecordedPatternResponse **)soap_malloc(soap, sizeof(_ns1__PlayRecordedPatternResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PlayRecordedPatternResponse *)soap_instantiate__ns1__PlayRecordedPatternResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PlayRecordedPatternResponse ** p = (_ns1__PlayRecordedPatternResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PlayRecordedPatternResponse, sizeof(_ns1__PlayRecordedPatternResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PlayRecordedPattern(struct soap *soap, _ns1__PlayRecordedPattern *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PlayRecordedPattern))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PlayRecordedPattern(struct soap *soap, _ns1__PlayRecordedPattern *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PlayRecordedPattern);
	if (soap_out_PointerTo_ns1__PlayRecordedPattern(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PlayRecordedPattern(struct soap *soap, const char *tag, int id, _ns1__PlayRecordedPattern *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PlayRecordedPattern);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PlayRecordedPattern ** SOAP_FMAC4 soap_get_PointerTo_ns1__PlayRecordedPattern(struct soap *soap, _ns1__PlayRecordedPattern **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PlayRecordedPattern(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__PlayRecordedPattern ** SOAP_FMAC4 soap_in_PointerTo_ns1__PlayRecordedPattern(struct soap *soap, const char *tag, _ns1__PlayRecordedPattern **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PlayRecordedPattern **)soap_malloc(soap, sizeof(_ns1__PlayRecordedPattern *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PlayRecordedPattern *)soap_instantiate__ns1__PlayRecordedPattern(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PlayRecordedPattern ** p = (_ns1__PlayRecordedPattern **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PlayRecordedPattern, sizeof(_ns1__PlayRecordedPattern), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StopPatternRecordingResponse(struct soap *soap, _ns1__StopPatternRecordingResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StopPatternRecordingResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StopPatternRecordingResponse(struct soap *soap, _ns1__StopPatternRecordingResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__StopPatternRecordingResponse);
	if (soap_out_PointerTo_ns1__StopPatternRecordingResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StopPatternRecordingResponse(struct soap *soap, const char *tag, int id, _ns1__StopPatternRecordingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StopPatternRecordingResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StopPatternRecordingResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__StopPatternRecordingResponse(struct soap *soap, _ns1__StopPatternRecordingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StopPatternRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__StopPatternRecordingResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__StopPatternRecordingResponse(struct soap *soap, const char *tag, _ns1__StopPatternRecordingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StopPatternRecordingResponse **)soap_malloc(soap, sizeof(_ns1__StopPatternRecordingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StopPatternRecordingResponse *)soap_instantiate__ns1__StopPatternRecordingResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__StopPatternRecordingResponse ** p = (_ns1__StopPatternRecordingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StopPatternRecordingResponse, sizeof(_ns1__StopPatternRecordingResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StopPatternRecording(struct soap *soap, _ns1__StopPatternRecording *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StopPatternRecording))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StopPatternRecording(struct soap *soap, _ns1__StopPatternRecording *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__StopPatternRecording);
	if (soap_out_PointerTo_ns1__StopPatternRecording(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StopPatternRecording(struct soap *soap, const char *tag, int id, _ns1__StopPatternRecording *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StopPatternRecording);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StopPatternRecording ** SOAP_FMAC4 soap_get_PointerTo_ns1__StopPatternRecording(struct soap *soap, _ns1__StopPatternRecording **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StopPatternRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__StopPatternRecording ** SOAP_FMAC4 soap_in_PointerTo_ns1__StopPatternRecording(struct soap *soap, const char *tag, _ns1__StopPatternRecording **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StopPatternRecording **)soap_malloc(soap, sizeof(_ns1__StopPatternRecording *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StopPatternRecording *)soap_instantiate__ns1__StopPatternRecording(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__StopPatternRecording ** p = (_ns1__StopPatternRecording **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StopPatternRecording, sizeof(_ns1__StopPatternRecording), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StartPatternRecordingResponse(struct soap *soap, _ns1__StartPatternRecordingResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StartPatternRecordingResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StartPatternRecordingResponse(struct soap *soap, _ns1__StartPatternRecordingResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__StartPatternRecordingResponse);
	if (soap_out_PointerTo_ns1__StartPatternRecordingResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StartPatternRecordingResponse(struct soap *soap, const char *tag, int id, _ns1__StartPatternRecordingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StartPatternRecordingResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StartPatternRecordingResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__StartPatternRecordingResponse(struct soap *soap, _ns1__StartPatternRecordingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StartPatternRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__StartPatternRecordingResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__StartPatternRecordingResponse(struct soap *soap, const char *tag, _ns1__StartPatternRecordingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StartPatternRecordingResponse **)soap_malloc(soap, sizeof(_ns1__StartPatternRecordingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StartPatternRecordingResponse *)soap_instantiate__ns1__StartPatternRecordingResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__StartPatternRecordingResponse ** p = (_ns1__StartPatternRecordingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StartPatternRecordingResponse, sizeof(_ns1__StartPatternRecordingResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StartPatternRecording(struct soap *soap, _ns1__StartPatternRecording *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StartPatternRecording))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StartPatternRecording(struct soap *soap, _ns1__StartPatternRecording *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__StartPatternRecording);
	if (soap_out_PointerTo_ns1__StartPatternRecording(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StartPatternRecording(struct soap *soap, const char *tag, int id, _ns1__StartPatternRecording *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StartPatternRecording);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StartPatternRecording ** SOAP_FMAC4 soap_get_PointerTo_ns1__StartPatternRecording(struct soap *soap, _ns1__StartPatternRecording **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StartPatternRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__StartPatternRecording ** SOAP_FMAC4 soap_in_PointerTo_ns1__StartPatternRecording(struct soap *soap, const char *tag, _ns1__StartPatternRecording **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StartPatternRecording **)soap_malloc(soap, sizeof(_ns1__StartPatternRecording *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StartPatternRecording *)soap_instantiate__ns1__StartPatternRecording(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__StartPatternRecording ** p = (_ns1__StartPatternRecording **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StartPatternRecording, sizeof(_ns1__StartPatternRecording), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StopPresetTourResponse(struct soap *soap, _ns1__StopPresetTourResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StopPresetTourResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StopPresetTourResponse(struct soap *soap, _ns1__StopPresetTourResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__StopPresetTourResponse);
	if (soap_out_PointerTo_ns1__StopPresetTourResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StopPresetTourResponse(struct soap *soap, const char *tag, int id, _ns1__StopPresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StopPresetTourResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StopPresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__StopPresetTourResponse(struct soap *soap, _ns1__StopPresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StopPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__StopPresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__StopPresetTourResponse(struct soap *soap, const char *tag, _ns1__StopPresetTourResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StopPresetTourResponse **)soap_malloc(soap, sizeof(_ns1__StopPresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StopPresetTourResponse *)soap_instantiate__ns1__StopPresetTourResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__StopPresetTourResponse ** p = (_ns1__StopPresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StopPresetTourResponse, sizeof(_ns1__StopPresetTourResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StopPresetTour(struct soap *soap, _ns1__StopPresetTour *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StopPresetTour))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StopPresetTour(struct soap *soap, _ns1__StopPresetTour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__StopPresetTour);
	if (soap_out_PointerTo_ns1__StopPresetTour(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StopPresetTour(struct soap *soap, const char *tag, int id, _ns1__StopPresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StopPresetTour);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StopPresetTour ** SOAP_FMAC4 soap_get_PointerTo_ns1__StopPresetTour(struct soap *soap, _ns1__StopPresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StopPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__StopPresetTour ** SOAP_FMAC4 soap_in_PointerTo_ns1__StopPresetTour(struct soap *soap, const char *tag, _ns1__StopPresetTour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StopPresetTour **)soap_malloc(soap, sizeof(_ns1__StopPresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StopPresetTour *)soap_instantiate__ns1__StopPresetTour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__StopPresetTour ** p = (_ns1__StopPresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StopPresetTour, sizeof(_ns1__StopPresetTour), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PlayPresetTourResponse(struct soap *soap, _ns1__PlayPresetTourResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PlayPresetTourResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PlayPresetTourResponse(struct soap *soap, _ns1__PlayPresetTourResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PlayPresetTourResponse);
	if (soap_out_PointerTo_ns1__PlayPresetTourResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PlayPresetTourResponse(struct soap *soap, const char *tag, int id, _ns1__PlayPresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PlayPresetTourResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PlayPresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__PlayPresetTourResponse(struct soap *soap, _ns1__PlayPresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PlayPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__PlayPresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__PlayPresetTourResponse(struct soap *soap, const char *tag, _ns1__PlayPresetTourResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PlayPresetTourResponse **)soap_malloc(soap, sizeof(_ns1__PlayPresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PlayPresetTourResponse *)soap_instantiate__ns1__PlayPresetTourResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PlayPresetTourResponse ** p = (_ns1__PlayPresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PlayPresetTourResponse, sizeof(_ns1__PlayPresetTourResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PlayPresetTour(struct soap *soap, _ns1__PlayPresetTour *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PlayPresetTour))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PlayPresetTour(struct soap *soap, _ns1__PlayPresetTour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PlayPresetTour);
	if (soap_out_PointerTo_ns1__PlayPresetTour(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PlayPresetTour(struct soap *soap, const char *tag, int id, _ns1__PlayPresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PlayPresetTour);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PlayPresetTour ** SOAP_FMAC4 soap_get_PointerTo_ns1__PlayPresetTour(struct soap *soap, _ns1__PlayPresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PlayPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__PlayPresetTour ** SOAP_FMAC4 soap_in_PointerTo_ns1__PlayPresetTour(struct soap *soap, const char *tag, _ns1__PlayPresetTour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PlayPresetTour **)soap_malloc(soap, sizeof(_ns1__PlayPresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PlayPresetTour *)soap_instantiate__ns1__PlayPresetTour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PlayPresetTour ** p = (_ns1__PlayPresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PlayPresetTour, sizeof(_ns1__PlayPresetTour), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetPresetTourResponse(struct soap *soap, _ns1__SetPresetTourResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetPresetTourResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetPresetTourResponse(struct soap *soap, _ns1__SetPresetTourResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetPresetTourResponse);
	if (soap_out_PointerTo_ns1__SetPresetTourResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetPresetTourResponse(struct soap *soap, const char *tag, int id, _ns1__SetPresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetPresetTourResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetPresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetPresetTourResponse(struct soap *soap, _ns1__SetPresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__SetPresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetPresetTourResponse(struct soap *soap, const char *tag, _ns1__SetPresetTourResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetPresetTourResponse **)soap_malloc(soap, sizeof(_ns1__SetPresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetPresetTourResponse *)soap_instantiate__ns1__SetPresetTourResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetPresetTourResponse ** p = (_ns1__SetPresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetPresetTourResponse, sizeof(_ns1__SetPresetTourResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetPresetTour(struct soap *soap, _ns1__SetPresetTour *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetPresetTour))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetPresetTour(struct soap *soap, _ns1__SetPresetTour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetPresetTour);
	if (soap_out_PointerTo_ns1__SetPresetTour(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetPresetTour(struct soap *soap, const char *tag, int id, _ns1__SetPresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetPresetTour);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetPresetTour ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetPresetTour(struct soap *soap, _ns1__SetPresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__SetPresetTour ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetPresetTour(struct soap *soap, const char *tag, _ns1__SetPresetTour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetPresetTour **)soap_malloc(soap, sizeof(_ns1__SetPresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetPresetTour *)soap_instantiate__ns1__SetPresetTour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetPresetTour ** p = (_ns1__SetPresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetPresetTour, sizeof(_ns1__SetPresetTour), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPresetTourResponse(struct soap *soap, _ns1__GetPresetTourResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPresetTourResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPresetTourResponse(struct soap *soap, _ns1__GetPresetTourResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPresetTourResponse);
	if (soap_out_PointerTo_ns1__GetPresetTourResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPresetTourResponse(struct soap *soap, const char *tag, int id, _ns1__GetPresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPresetTourResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPresetTourResponse(struct soap *soap, _ns1__GetPresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetPresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPresetTourResponse(struct soap *soap, const char *tag, _ns1__GetPresetTourResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPresetTourResponse **)soap_malloc(soap, sizeof(_ns1__GetPresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPresetTourResponse *)soap_instantiate__ns1__GetPresetTourResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPresetTourResponse ** p = (_ns1__GetPresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPresetTourResponse, sizeof(_ns1__GetPresetTourResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPresetTour(struct soap *soap, _ns1__GetPresetTour *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPresetTour))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPresetTour(struct soap *soap, _ns1__GetPresetTour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPresetTour);
	if (soap_out_PointerTo_ns1__GetPresetTour(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPresetTour(struct soap *soap, const char *tag, int id, _ns1__GetPresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPresetTour);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPresetTour ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPresetTour(struct soap *soap, _ns1__GetPresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetPresetTour ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPresetTour(struct soap *soap, const char *tag, _ns1__GetPresetTour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPresetTour **)soap_malloc(soap, sizeof(_ns1__GetPresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPresetTour *)soap_instantiate__ns1__GetPresetTour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPresetTour ** p = (_ns1__GetPresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPresetTour, sizeof(_ns1__GetPresetTour), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RemovePresetResponse(struct soap *soap, _ns1__RemovePresetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RemovePresetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RemovePresetResponse(struct soap *soap, _ns1__RemovePresetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__RemovePresetResponse);
	if (soap_out_PointerTo_ns1__RemovePresetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RemovePresetResponse(struct soap *soap, const char *tag, int id, _ns1__RemovePresetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RemovePresetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RemovePresetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__RemovePresetResponse(struct soap *soap, _ns1__RemovePresetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RemovePresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__RemovePresetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__RemovePresetResponse(struct soap *soap, const char *tag, _ns1__RemovePresetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RemovePresetResponse **)soap_malloc(soap, sizeof(_ns1__RemovePresetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RemovePresetResponse *)soap_instantiate__ns1__RemovePresetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__RemovePresetResponse ** p = (_ns1__RemovePresetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RemovePresetResponse, sizeof(_ns1__RemovePresetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RemovePreset(struct soap *soap, _ns1__RemovePreset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RemovePreset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RemovePreset(struct soap *soap, _ns1__RemovePreset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__RemovePreset);
	if (soap_out_PointerTo_ns1__RemovePreset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RemovePreset(struct soap *soap, const char *tag, int id, _ns1__RemovePreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RemovePreset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RemovePreset ** SOAP_FMAC4 soap_get_PointerTo_ns1__RemovePreset(struct soap *soap, _ns1__RemovePreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RemovePreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__RemovePreset ** SOAP_FMAC4 soap_in_PointerTo_ns1__RemovePreset(struct soap *soap, const char *tag, _ns1__RemovePreset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RemovePreset **)soap_malloc(soap, sizeof(_ns1__RemovePreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RemovePreset *)soap_instantiate__ns1__RemovePreset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__RemovePreset ** p = (_ns1__RemovePreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RemovePreset, sizeof(_ns1__RemovePreset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GotoPresetResponse(struct soap *soap, _ns1__GotoPresetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GotoPresetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GotoPresetResponse(struct soap *soap, _ns1__GotoPresetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GotoPresetResponse);
	if (soap_out_PointerTo_ns1__GotoPresetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GotoPresetResponse(struct soap *soap, const char *tag, int id, _ns1__GotoPresetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GotoPresetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GotoPresetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GotoPresetResponse(struct soap *soap, _ns1__GotoPresetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GotoPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GotoPresetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GotoPresetResponse(struct soap *soap, const char *tag, _ns1__GotoPresetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GotoPresetResponse **)soap_malloc(soap, sizeof(_ns1__GotoPresetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GotoPresetResponse *)soap_instantiate__ns1__GotoPresetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GotoPresetResponse ** p = (_ns1__GotoPresetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GotoPresetResponse, sizeof(_ns1__GotoPresetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GotoPreset(struct soap *soap, _ns1__GotoPreset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GotoPreset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GotoPreset(struct soap *soap, _ns1__GotoPreset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GotoPreset);
	if (soap_out_PointerTo_ns1__GotoPreset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GotoPreset(struct soap *soap, const char *tag, int id, _ns1__GotoPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GotoPreset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GotoPreset ** SOAP_FMAC4 soap_get_PointerTo_ns1__GotoPreset(struct soap *soap, _ns1__GotoPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GotoPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GotoPreset ** SOAP_FMAC4 soap_in_PointerTo_ns1__GotoPreset(struct soap *soap, const char *tag, _ns1__GotoPreset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GotoPreset **)soap_malloc(soap, sizeof(_ns1__GotoPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GotoPreset *)soap_instantiate__ns1__GotoPreset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GotoPreset ** p = (_ns1__GotoPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GotoPreset, sizeof(_ns1__GotoPreset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddPresetResponse(struct soap *soap, _ns1__AddPresetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddPresetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddPresetResponse(struct soap *soap, _ns1__AddPresetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddPresetResponse);
	if (soap_out_PointerTo_ns1__AddPresetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddPresetResponse(struct soap *soap, const char *tag, int id, _ns1__AddPresetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddPresetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddPresetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddPresetResponse(struct soap *soap, _ns1__AddPresetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__AddPresetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddPresetResponse(struct soap *soap, const char *tag, _ns1__AddPresetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddPresetResponse **)soap_malloc(soap, sizeof(_ns1__AddPresetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddPresetResponse *)soap_instantiate__ns1__AddPresetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddPresetResponse ** p = (_ns1__AddPresetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddPresetResponse, sizeof(_ns1__AddPresetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddPreset(struct soap *soap, _ns1__AddPreset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddPreset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddPreset(struct soap *soap, _ns1__AddPreset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddPreset);
	if (soap_out_PointerTo_ns1__AddPreset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddPreset(struct soap *soap, const char *tag, int id, _ns1__AddPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddPreset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddPreset ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddPreset(struct soap *soap, _ns1__AddPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__AddPreset ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddPreset(struct soap *soap, const char *tag, _ns1__AddPreset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddPreset **)soap_malloc(soap, sizeof(_ns1__AddPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddPreset *)soap_instantiate__ns1__AddPreset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddPreset ** p = (_ns1__AddPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddPreset, sizeof(_ns1__AddPreset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPresetListResponse(struct soap *soap, _ns1__GetPresetListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPresetListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPresetListResponse(struct soap *soap, _ns1__GetPresetListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPresetListResponse);
	if (soap_out_PointerTo_ns1__GetPresetListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPresetListResponse(struct soap *soap, const char *tag, int id, _ns1__GetPresetListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPresetListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPresetListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPresetListResponse(struct soap *soap, _ns1__GetPresetListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPresetListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetPresetListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPresetListResponse(struct soap *soap, const char *tag, _ns1__GetPresetListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPresetListResponse **)soap_malloc(soap, sizeof(_ns1__GetPresetListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPresetListResponse *)soap_instantiate__ns1__GetPresetListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPresetListResponse ** p = (_ns1__GetPresetListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPresetListResponse, sizeof(_ns1__GetPresetListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPresetList(struct soap *soap, _ns1__GetPresetList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPresetList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPresetList(struct soap *soap, _ns1__GetPresetList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPresetList);
	if (soap_out_PointerTo_ns1__GetPresetList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPresetList(struct soap *soap, const char *tag, int id, _ns1__GetPresetList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPresetList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPresetList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPresetList(struct soap *soap, _ns1__GetPresetList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPresetList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetPresetList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPresetList(struct soap *soap, const char *tag, _ns1__GetPresetList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPresetList **)soap_malloc(soap, sizeof(_ns1__GetPresetList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPresetList *)soap_instantiate__ns1__GetPresetList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPresetList ** p = (_ns1__GetPresetList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPresetList, sizeof(_ns1__GetPresetList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StopResponse(struct soap *soap, _ns1__StopResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StopResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StopResponse(struct soap *soap, _ns1__StopResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__StopResponse);
	if (soap_out_PointerTo_ns1__StopResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StopResponse(struct soap *soap, const char *tag, int id, _ns1__StopResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StopResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StopResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__StopResponse(struct soap *soap, _ns1__StopResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__StopResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__StopResponse(struct soap *soap, const char *tag, _ns1__StopResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StopResponse **)soap_malloc(soap, sizeof(_ns1__StopResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StopResponse *)soap_instantiate__ns1__StopResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__StopResponse ** p = (_ns1__StopResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StopResponse, sizeof(_ns1__StopResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Stop(struct soap *soap, _ns1__Stop *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Stop))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Stop(struct soap *soap, _ns1__Stop *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__Stop);
	if (soap_out_PointerTo_ns1__Stop(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Stop(struct soap *soap, const char *tag, int id, _ns1__Stop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Stop);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Stop ** SOAP_FMAC4 soap_get_PointerTo_ns1__Stop(struct soap *soap, _ns1__Stop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__Stop ** SOAP_FMAC4 soap_in_PointerTo_ns1__Stop(struct soap *soap, const char *tag, _ns1__Stop **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Stop **)soap_malloc(soap, sizeof(_ns1__Stop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Stop *)soap_instantiate__ns1__Stop(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__Stop ** p = (_ns1__Stop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Stop, sizeof(_ns1__Stop), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ControlPTZResponse(struct soap *soap, _ns1__ControlPTZResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ControlPTZResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ControlPTZResponse(struct soap *soap, _ns1__ControlPTZResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ControlPTZResponse);
	if (soap_out_PointerTo_ns1__ControlPTZResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ControlPTZResponse(struct soap *soap, const char *tag, int id, _ns1__ControlPTZResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ControlPTZResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ControlPTZResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__ControlPTZResponse(struct soap *soap, _ns1__ControlPTZResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ControlPTZResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__ControlPTZResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__ControlPTZResponse(struct soap *soap, const char *tag, _ns1__ControlPTZResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ControlPTZResponse **)soap_malloc(soap, sizeof(_ns1__ControlPTZResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ControlPTZResponse *)soap_instantiate__ns1__ControlPTZResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__ControlPTZResponse ** p = (_ns1__ControlPTZResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ControlPTZResponse, sizeof(_ns1__ControlPTZResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ControlPTZ(struct soap *soap, _ns1__ControlPTZ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ControlPTZ))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ControlPTZ(struct soap *soap, _ns1__ControlPTZ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ControlPTZ);
	if (soap_out_PointerTo_ns1__ControlPTZ(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ControlPTZ(struct soap *soap, const char *tag, int id, _ns1__ControlPTZ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ControlPTZ);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ControlPTZ ** SOAP_FMAC4 soap_get_PointerTo_ns1__ControlPTZ(struct soap *soap, _ns1__ControlPTZ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ControlPTZ(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__ControlPTZ ** SOAP_FMAC4 soap_in_PointerTo_ns1__ControlPTZ(struct soap *soap, const char *tag, _ns1__ControlPTZ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ControlPTZ **)soap_malloc(soap, sizeof(_ns1__ControlPTZ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ControlPTZ *)soap_instantiate__ns1__ControlPTZ(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__ControlPTZ ** p = (_ns1__ControlPTZ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ControlPTZ, sizeof(_ns1__ControlPTZ), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPTZCommandListResponse(struct soap *soap, _ns1__GetPTZCommandListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPTZCommandListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPTZCommandListResponse(struct soap *soap, _ns1__GetPTZCommandListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPTZCommandListResponse);
	if (soap_out_PointerTo_ns1__GetPTZCommandListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPTZCommandListResponse(struct soap *soap, const char *tag, int id, _ns1__GetPTZCommandListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPTZCommandListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPTZCommandListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPTZCommandListResponse(struct soap *soap, _ns1__GetPTZCommandListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPTZCommandListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetPTZCommandListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPTZCommandListResponse(struct soap *soap, const char *tag, _ns1__GetPTZCommandListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPTZCommandListResponse **)soap_malloc(soap, sizeof(_ns1__GetPTZCommandListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPTZCommandListResponse *)soap_instantiate__ns1__GetPTZCommandListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPTZCommandListResponse ** p = (_ns1__GetPTZCommandListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPTZCommandListResponse, sizeof(_ns1__GetPTZCommandListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPTZCommandList(struct soap *soap, _ns1__GetPTZCommandList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPTZCommandList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPTZCommandList(struct soap *soap, _ns1__GetPTZCommandList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPTZCommandList);
	if (soap_out_PointerTo_ns1__GetPTZCommandList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPTZCommandList(struct soap *soap, const char *tag, int id, _ns1__GetPTZCommandList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPTZCommandList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPTZCommandList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPTZCommandList(struct soap *soap, _ns1__GetPTZCommandList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPTZCommandList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetPTZCommandList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPTZCommandList(struct soap *soap, const char *tag, _ns1__GetPTZCommandList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPTZCommandList **)soap_malloc(soap, sizeof(_ns1__GetPTZCommandList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPTZCommandList *)soap_instantiate__ns1__GetPTZCommandList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPTZCommandList ** p = (_ns1__GetPTZCommandList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPTZCommandList, sizeof(_ns1__GetPTZCommandList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPTZProtocolInfoResponse(struct soap *soap, _ns1__GetPTZProtocolInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPTZProtocolInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPTZProtocolInfoResponse(struct soap *soap, _ns1__GetPTZProtocolInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPTZProtocolInfoResponse);
	if (soap_out_PointerTo_ns1__GetPTZProtocolInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPTZProtocolInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetPTZProtocolInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPTZProtocolInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocolInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPTZProtocolInfoResponse(struct soap *soap, _ns1__GetPTZProtocolInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPTZProtocolInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetPTZProtocolInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPTZProtocolInfoResponse(struct soap *soap, const char *tag, _ns1__GetPTZProtocolInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPTZProtocolInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetPTZProtocolInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPTZProtocolInfoResponse *)soap_instantiate__ns1__GetPTZProtocolInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPTZProtocolInfoResponse ** p = (_ns1__GetPTZProtocolInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPTZProtocolInfoResponse, sizeof(_ns1__GetPTZProtocolInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPTZProtocolInfo(struct soap *soap, _ns1__GetPTZProtocolInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPTZProtocolInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPTZProtocolInfo(struct soap *soap, _ns1__GetPTZProtocolInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPTZProtocolInfo);
	if (soap_out_PointerTo_ns1__GetPTZProtocolInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPTZProtocolInfo(struct soap *soap, const char *tag, int id, _ns1__GetPTZProtocolInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPTZProtocolInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocolInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPTZProtocolInfo(struct soap *soap, _ns1__GetPTZProtocolInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPTZProtocolInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetPTZProtocolInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPTZProtocolInfo(struct soap *soap, const char *tag, _ns1__GetPTZProtocolInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPTZProtocolInfo **)soap_malloc(soap, sizeof(_ns1__GetPTZProtocolInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPTZProtocolInfo *)soap_instantiate__ns1__GetPTZProtocolInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPTZProtocolInfo ** p = (_ns1__GetPTZProtocolInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPTZProtocolInfo, sizeof(_ns1__GetPTZProtocolInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RemovePTZProtocolResponse(struct soap *soap, _ns1__RemovePTZProtocolResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RemovePTZProtocolResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RemovePTZProtocolResponse(struct soap *soap, _ns1__RemovePTZProtocolResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__RemovePTZProtocolResponse);
	if (soap_out_PointerTo_ns1__RemovePTZProtocolResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RemovePTZProtocolResponse(struct soap *soap, const char *tag, int id, _ns1__RemovePTZProtocolResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RemovePTZProtocolResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RemovePTZProtocolResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__RemovePTZProtocolResponse(struct soap *soap, _ns1__RemovePTZProtocolResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RemovePTZProtocolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__RemovePTZProtocolResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__RemovePTZProtocolResponse(struct soap *soap, const char *tag, _ns1__RemovePTZProtocolResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RemovePTZProtocolResponse **)soap_malloc(soap, sizeof(_ns1__RemovePTZProtocolResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RemovePTZProtocolResponse *)soap_instantiate__ns1__RemovePTZProtocolResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__RemovePTZProtocolResponse ** p = (_ns1__RemovePTZProtocolResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RemovePTZProtocolResponse, sizeof(_ns1__RemovePTZProtocolResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RemovePTZProtocol(struct soap *soap, _ns1__RemovePTZProtocol *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RemovePTZProtocol))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RemovePTZProtocol(struct soap *soap, _ns1__RemovePTZProtocol *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__RemovePTZProtocol);
	if (soap_out_PointerTo_ns1__RemovePTZProtocol(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RemovePTZProtocol(struct soap *soap, const char *tag, int id, _ns1__RemovePTZProtocol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RemovePTZProtocol);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RemovePTZProtocol ** SOAP_FMAC4 soap_get_PointerTo_ns1__RemovePTZProtocol(struct soap *soap, _ns1__RemovePTZProtocol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RemovePTZProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__RemovePTZProtocol ** SOAP_FMAC4 soap_in_PointerTo_ns1__RemovePTZProtocol(struct soap *soap, const char *tag, _ns1__RemovePTZProtocol **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RemovePTZProtocol **)soap_malloc(soap, sizeof(_ns1__RemovePTZProtocol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RemovePTZProtocol *)soap_instantiate__ns1__RemovePTZProtocol(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__RemovePTZProtocol ** p = (_ns1__RemovePTZProtocol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RemovePTZProtocol, sizeof(_ns1__RemovePTZProtocol), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddPTZProtocolResponse(struct soap *soap, _ns1__AddPTZProtocolResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddPTZProtocolResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddPTZProtocolResponse(struct soap *soap, _ns1__AddPTZProtocolResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddPTZProtocolResponse);
	if (soap_out_PointerTo_ns1__AddPTZProtocolResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddPTZProtocolResponse(struct soap *soap, const char *tag, int id, _ns1__AddPTZProtocolResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddPTZProtocolResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddPTZProtocolResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddPTZProtocolResponse(struct soap *soap, _ns1__AddPTZProtocolResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddPTZProtocolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__AddPTZProtocolResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddPTZProtocolResponse(struct soap *soap, const char *tag, _ns1__AddPTZProtocolResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddPTZProtocolResponse **)soap_malloc(soap, sizeof(_ns1__AddPTZProtocolResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddPTZProtocolResponse *)soap_instantiate__ns1__AddPTZProtocolResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddPTZProtocolResponse ** p = (_ns1__AddPTZProtocolResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddPTZProtocolResponse, sizeof(_ns1__AddPTZProtocolResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddPTZProtocol(struct soap *soap, _ns1__AddPTZProtocol *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddPTZProtocol))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddPTZProtocol(struct soap *soap, _ns1__AddPTZProtocol *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AddPTZProtocol);
	if (soap_out_PointerTo_ns1__AddPTZProtocol(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddPTZProtocol(struct soap *soap, const char *tag, int id, _ns1__AddPTZProtocol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddPTZProtocol);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddPTZProtocol ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddPTZProtocol(struct soap *soap, _ns1__AddPTZProtocol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddPTZProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__AddPTZProtocol ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddPTZProtocol(struct soap *soap, const char *tag, _ns1__AddPTZProtocol **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddPTZProtocol **)soap_malloc(soap, sizeof(_ns1__AddPTZProtocol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddPTZProtocol *)soap_instantiate__ns1__AddPTZProtocol(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AddPTZProtocol ** p = (_ns1__AddPTZProtocol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddPTZProtocol, sizeof(_ns1__AddPTZProtocol), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetPTZProtocolResponse(struct soap *soap, _ns1__SetPTZProtocolResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetPTZProtocolResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetPTZProtocolResponse(struct soap *soap, _ns1__SetPTZProtocolResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetPTZProtocolResponse);
	if (soap_out_PointerTo_ns1__SetPTZProtocolResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetPTZProtocolResponse(struct soap *soap, const char *tag, int id, _ns1__SetPTZProtocolResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetPTZProtocolResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetPTZProtocolResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetPTZProtocolResponse(struct soap *soap, _ns1__SetPTZProtocolResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetPTZProtocolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__SetPTZProtocolResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetPTZProtocolResponse(struct soap *soap, const char *tag, _ns1__SetPTZProtocolResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetPTZProtocolResponse **)soap_malloc(soap, sizeof(_ns1__SetPTZProtocolResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetPTZProtocolResponse *)soap_instantiate__ns1__SetPTZProtocolResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetPTZProtocolResponse ** p = (_ns1__SetPTZProtocolResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetPTZProtocolResponse, sizeof(_ns1__SetPTZProtocolResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetPTZProtocol(struct soap *soap, _ns1__SetPTZProtocol *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetPTZProtocol))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetPTZProtocol(struct soap *soap, _ns1__SetPTZProtocol *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetPTZProtocol);
	if (soap_out_PointerTo_ns1__SetPTZProtocol(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetPTZProtocol(struct soap *soap, const char *tag, int id, _ns1__SetPTZProtocol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetPTZProtocol);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetPTZProtocol ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetPTZProtocol(struct soap *soap, _ns1__SetPTZProtocol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetPTZProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__SetPTZProtocol ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetPTZProtocol(struct soap *soap, const char *tag, _ns1__SetPTZProtocol **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetPTZProtocol **)soap_malloc(soap, sizeof(_ns1__SetPTZProtocol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetPTZProtocol *)soap_instantiate__ns1__SetPTZProtocol(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetPTZProtocol ** p = (_ns1__SetPTZProtocol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetPTZProtocol, sizeof(_ns1__SetPTZProtocol), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPTZProtocolResponse(struct soap *soap, _ns1__GetPTZProtocolResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPTZProtocolResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPTZProtocolResponse(struct soap *soap, _ns1__GetPTZProtocolResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPTZProtocolResponse);
	if (soap_out_PointerTo_ns1__GetPTZProtocolResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPTZProtocolResponse(struct soap *soap, const char *tag, int id, _ns1__GetPTZProtocolResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPTZProtocolResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocolResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPTZProtocolResponse(struct soap *soap, _ns1__GetPTZProtocolResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPTZProtocolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetPTZProtocolResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPTZProtocolResponse(struct soap *soap, const char *tag, _ns1__GetPTZProtocolResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPTZProtocolResponse **)soap_malloc(soap, sizeof(_ns1__GetPTZProtocolResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPTZProtocolResponse *)soap_instantiate__ns1__GetPTZProtocolResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPTZProtocolResponse ** p = (_ns1__GetPTZProtocolResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPTZProtocolResponse, sizeof(_ns1__GetPTZProtocolResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPTZProtocol(struct soap *soap, _ns1__GetPTZProtocol *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPTZProtocol))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPTZProtocol(struct soap *soap, _ns1__GetPTZProtocol *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPTZProtocol);
	if (soap_out_PointerTo_ns1__GetPTZProtocol(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPTZProtocol(struct soap *soap, const char *tag, int id, _ns1__GetPTZProtocol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPTZProtocol);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocol ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPTZProtocol(struct soap *soap, _ns1__GetPTZProtocol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPTZProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetPTZProtocol ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPTZProtocol(struct soap *soap, const char *tag, _ns1__GetPTZProtocol **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPTZProtocol **)soap_malloc(soap, sizeof(_ns1__GetPTZProtocol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPTZProtocol *)soap_instantiate__ns1__GetPTZProtocol(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPTZProtocol ** p = (_ns1__GetPTZProtocol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPTZProtocol, sizeof(_ns1__GetPTZProtocol), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPTZProtocolListResponse(struct soap *soap, _ns1__GetPTZProtocolListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPTZProtocolListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPTZProtocolListResponse(struct soap *soap, _ns1__GetPTZProtocolListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPTZProtocolListResponse);
	if (soap_out_PointerTo_ns1__GetPTZProtocolListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPTZProtocolListResponse(struct soap *soap, const char *tag, int id, _ns1__GetPTZProtocolListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPTZProtocolListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocolListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPTZProtocolListResponse(struct soap *soap, _ns1__GetPTZProtocolListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPTZProtocolListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetPTZProtocolListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPTZProtocolListResponse(struct soap *soap, const char *tag, _ns1__GetPTZProtocolListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPTZProtocolListResponse **)soap_malloc(soap, sizeof(_ns1__GetPTZProtocolListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPTZProtocolListResponse *)soap_instantiate__ns1__GetPTZProtocolListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPTZProtocolListResponse ** p = (_ns1__GetPTZProtocolListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPTZProtocolListResponse, sizeof(_ns1__GetPTZProtocolListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPTZProtocolList(struct soap *soap, _ns1__GetPTZProtocolList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPTZProtocolList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPTZProtocolList(struct soap *soap, _ns1__GetPTZProtocolList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPTZProtocolList);
	if (soap_out_PointerTo_ns1__GetPTZProtocolList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPTZProtocolList(struct soap *soap, const char *tag, int id, _ns1__GetPTZProtocolList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPTZProtocolList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPTZProtocolList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPTZProtocolList(struct soap *soap, _ns1__GetPTZProtocolList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPTZProtocolList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__GetPTZProtocolList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPTZProtocolList(struct soap *soap, const char *tag, _ns1__GetPTZProtocolList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPTZProtocolList **)soap_malloc(soap, sizeof(_ns1__GetPTZProtocolList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPTZProtocolList *)soap_instantiate__ns1__GetPTZProtocolList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPTZProtocolList ** p = (_ns1__GetPTZProtocolList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPTZProtocolList, sizeof(_ns1__GetPTZProtocolList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PortConfig_USCORET(struct soap *soap, ns1__PortConfig_USCORET *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PortConfig_USCORET))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PortConfig_USCORET(struct soap *soap, ns1__PortConfig_USCORET *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PortConfig_USCORET);
	if (soap_out_PointerTons1__PortConfig_USCORET(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PortConfig_USCORET(struct soap *soap, const char *tag, int id, ns1__PortConfig_USCORET *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PortConfig_USCORET);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PortConfig_USCORET ** SOAP_FMAC4 soap_get_PointerTons1__PortConfig_USCORET(struct soap *soap, ns1__PortConfig_USCORET **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PortConfig_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__PortConfig_USCORET ** SOAP_FMAC4 soap_in_PointerTons1__PortConfig_USCORET(struct soap *soap, const char *tag, ns1__PortConfig_USCORET **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PortConfig_USCORET **)soap_malloc(soap, sizeof(ns1__PortConfig_USCORET *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PortConfig_USCORET *)soap_instantiate_ns1__PortConfig_USCORET(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PortConfig_USCORET ** p = (ns1__PortConfig_USCORET **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PortConfig_USCORET, sizeof(ns1__PortConfig_USCORET), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfPreset_USCORET(struct soap *soap, ns1__ArrayOfPreset_USCORET *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfPreset_USCORET))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfPreset_USCORET(struct soap *soap, ns1__ArrayOfPreset_USCORET *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfPreset_USCORET);
	if (soap_out_PointerTons1__ArrayOfPreset_USCORET(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfPreset_USCORET(struct soap *soap, const char *tag, int id, ns1__ArrayOfPreset_USCORET *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfPreset_USCORET);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfPreset_USCORET ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfPreset_USCORET(struct soap *soap, ns1__ArrayOfPreset_USCORET **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfPreset_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ArrayOfPreset_USCORET ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfPreset_USCORET(struct soap *soap, const char *tag, ns1__ArrayOfPreset_USCORET **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfPreset_USCORET **)soap_malloc(soap, sizeof(ns1__ArrayOfPreset_USCORET *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfPreset_USCORET *)soap_instantiate_ns1__ArrayOfPreset_USCORET(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfPreset_USCORET ** p = (ns1__ArrayOfPreset_USCORET **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfPreset_USCORET, sizeof(ns1__ArrayOfPreset_USCORET), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfParameter_USCORET(struct soap *soap, ns1__ArrayOfParameter_USCORET *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfParameter_USCORET))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfParameter_USCORET(struct soap *soap, ns1__ArrayOfParameter_USCORET *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfParameter_USCORET);
	if (soap_out_PointerTons1__ArrayOfParameter_USCORET(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfParameter_USCORET(struct soap *soap, const char *tag, int id, ns1__ArrayOfParameter_USCORET *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfParameter_USCORET);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfParameter_USCORET ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfParameter_USCORET(struct soap *soap, ns1__ArrayOfParameter_USCORET **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfParameter_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ArrayOfParameter_USCORET ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfParameter_USCORET(struct soap *soap, const char *tag, ns1__ArrayOfParameter_USCORET **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfParameter_USCORET **)soap_malloc(soap, sizeof(ns1__ArrayOfParameter_USCORET *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfParameter_USCORET *)soap_instantiate_ns1__ArrayOfParameter_USCORET(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfParameter_USCORET ** p = (ns1__ArrayOfParameter_USCORET **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfParameter_USCORET, sizeof(ns1__ArrayOfParameter_USCORET), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PTZProtocol_USCORET(struct soap *soap, ns1__PTZProtocol_USCORET *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PTZProtocol_USCORET))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PTZProtocol_USCORET(struct soap *soap, ns1__PTZProtocol_USCORET *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PTZProtocol_USCORET);
	if (soap_out_PointerTons1__PTZProtocol_USCORET(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PTZProtocol_USCORET(struct soap *soap, const char *tag, int id, ns1__PTZProtocol_USCORET *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PTZProtocol_USCORET);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PTZProtocol_USCORET ** SOAP_FMAC4 soap_get_PointerTons1__PTZProtocol_USCORET(struct soap *soap, ns1__PTZProtocol_USCORET **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PTZProtocol_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__PTZProtocol_USCORET ** SOAP_FMAC4 soap_in_PointerTons1__PTZProtocol_USCORET(struct soap *soap, const char *tag, ns1__PTZProtocol_USCORET **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PTZProtocol_USCORET **)soap_malloc(soap, sizeof(ns1__PTZProtocol_USCORET *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PTZProtocol_USCORET *)soap_instantiate_ns1__PTZProtocol_USCORET(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PTZProtocol_USCORET ** p = (ns1__PTZProtocol_USCORET **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PTZProtocol_USCORET, sizeof(ns1__PTZProtocol_USCORET), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfString))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfString);
	if (soap_out_PointerTons1__ArrayOfString(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, int id, ns1__ArrayOfString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfString);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfString ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfString(struct soap *soap, ns1__ArrayOfString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ArrayOfString ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfString(struct soap *soap, const char *tag, ns1__ArrayOfString **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfString **)soap_malloc(soap, sizeof(ns1__ArrayOfString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfString *)soap_instantiate_ns1__ArrayOfString(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfString ** p = (ns1__ArrayOfString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Preset_USCORET(struct soap *soap, ns1__Preset_USCORET **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Preset_USCORET))
		soap_serialize_PointerTons1__Preset_USCORET(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Preset_USCORET(struct soap *soap, ns1__Preset_USCORET **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Preset_USCORET);
	if (soap_out_PointerToPointerTons1__Preset_USCORET(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Preset_USCORET(struct soap *soap, const char *tag, int id, ns1__Preset_USCORET **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Preset_USCORET);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Preset_USCORET(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Preset_USCORET *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Preset_USCORET(struct soap *soap, ns1__Preset_USCORET ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Preset_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Preset_USCORET *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Preset_USCORET(struct soap *soap, const char *tag, ns1__Preset_USCORET ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Preset_USCORET ***)soap_malloc(soap, sizeof(ns1__Preset_USCORET **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Preset_USCORET(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Preset_USCORET ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Preset_USCORET, sizeof(ns1__Preset_USCORET *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Preset_USCORET(struct soap *soap, ns1__Preset_USCORET *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Preset_USCORET))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Preset_USCORET(struct soap *soap, ns1__Preset_USCORET *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Preset_USCORET);
	if (soap_out_PointerTons1__Preset_USCORET(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Preset_USCORET(struct soap *soap, const char *tag, int id, ns1__Preset_USCORET *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Preset_USCORET);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Preset_USCORET ** SOAP_FMAC4 soap_get_PointerTons1__Preset_USCORET(struct soap *soap, ns1__Preset_USCORET **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Preset_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Preset_USCORET ** SOAP_FMAC4 soap_in_PointerTons1__Preset_USCORET(struct soap *soap, const char *tag, ns1__Preset_USCORET **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Preset_USCORET **)soap_malloc(soap, sizeof(ns1__Preset_USCORET *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Preset_USCORET *)soap_instantiate_ns1__Preset_USCORET(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Preset_USCORET ** p = (ns1__Preset_USCORET **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Preset_USCORET, sizeof(ns1__Preset_USCORET), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Parameter_USCORET(struct soap *soap, ns1__Parameter_USCORET **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Parameter_USCORET))
		soap_serialize_PointerTons1__Parameter_USCORET(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Parameter_USCORET(struct soap *soap, ns1__Parameter_USCORET **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Parameter_USCORET);
	if (soap_out_PointerToPointerTons1__Parameter_USCORET(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Parameter_USCORET(struct soap *soap, const char *tag, int id, ns1__Parameter_USCORET **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Parameter_USCORET);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Parameter_USCORET(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Parameter_USCORET *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Parameter_USCORET(struct soap *soap, ns1__Parameter_USCORET ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Parameter_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Parameter_USCORET *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Parameter_USCORET(struct soap *soap, const char *tag, ns1__Parameter_USCORET ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Parameter_USCORET ***)soap_malloc(soap, sizeof(ns1__Parameter_USCORET **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Parameter_USCORET(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Parameter_USCORET ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Parameter_USCORET, sizeof(ns1__Parameter_USCORET *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Parameter_USCORET(struct soap *soap, ns1__Parameter_USCORET *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Parameter_USCORET))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Parameter_USCORET(struct soap *soap, ns1__Parameter_USCORET *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Parameter_USCORET);
	if (soap_out_PointerTons1__Parameter_USCORET(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Parameter_USCORET(struct soap *soap, const char *tag, int id, ns1__Parameter_USCORET *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Parameter_USCORET);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Parameter_USCORET ** SOAP_FMAC4 soap_get_PointerTons1__Parameter_USCORET(struct soap *soap, ns1__Parameter_USCORET **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Parameter_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Parameter_USCORET ** SOAP_FMAC4 soap_in_PointerTons1__Parameter_USCORET(struct soap *soap, const char *tag, ns1__Parameter_USCORET **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Parameter_USCORET **)soap_malloc(soap, sizeof(ns1__Parameter_USCORET *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Parameter_USCORET *)soap_instantiate_ns1__Parameter_USCORET(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Parameter_USCORET ** p = (ns1__Parameter_USCORET **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Parameter_USCORET, sizeof(ns1__Parameter_USCORET), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__IntRange_USCORET(struct soap *soap, ns1__IntRange_USCORET *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__IntRange_USCORET))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__IntRange_USCORET(struct soap *soap, ns1__IntRange_USCORET *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__IntRange_USCORET);
	if (soap_out_PointerTons1__IntRange_USCORET(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__IntRange_USCORET(struct soap *soap, const char *tag, int id, ns1__IntRange_USCORET *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__IntRange_USCORET);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__IntRange_USCORET ** SOAP_FMAC4 soap_get_PointerTons1__IntRange_USCORET(struct soap *soap, ns1__IntRange_USCORET **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__IntRange_USCORET(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__IntRange_USCORET ** SOAP_FMAC4 soap_in_PointerTons1__IntRange_USCORET(struct soap *soap, const char *tag, ns1__IntRange_USCORET **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__IntRange_USCORET **)soap_malloc(soap, sizeof(ns1__IntRange_USCORET *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__IntRange_USCORET *)soap_instantiate_ns1__IntRange_USCORET(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__IntRange_USCORET ** p = (ns1__IntRange_USCORET **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__IntRange_USCORET, sizeof(ns1__IntRange_USCORET), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
